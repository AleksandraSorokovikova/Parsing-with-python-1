<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <title>RxDart: магические трансформации потоков / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.c0af73e7.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.85eb77f0b17c8235e7b64b9f81ea5ec2.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" src="/js/ads.js" onload="window['zhY4i4nJ9K'] = true" data-vmid="checkad"></script><script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/post\/451292\/"},"headline":"RxDart: магические трансформации потоков","datePublished":"2019-05-11T10:15:25+03:00","dateModified":"2019-05-12T10:14:04+03:00","author":{"@type":"Person","name":"Валерий"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"Добро пожаловать &mdash; это третья часть моей серии статей об архитектуре Flutter.  Введение   Основы Dart Streams RxDart: магические трансформации потоков (этот пост...","url":"https:\/\/habr.com\/ru\/post\/451292\/#post-content-body","about":["h_dart","h_flutter","f_develop"],"image":["https:\/\/habrastorage.org\/getpro\/habr\/post_images\/ea5\/dfe\/1c6\/ea5dfe1c65f93367e3207e2a0fe68908.gif","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/8e0\/05a\/ecc\/8e005aecc11e119b7c856a4cadec9b11.gif","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/0bb\/73f\/2a2\/0bb73f2a2ccb82e6a920efbf2c395b0d.gif","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/e8e\/8d7\/2b3\/e8e8d72b36dddd0d3469107c6cdae2b1.gif","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/a2f\/9ba\/82b\/a2f9ba82b88b555841c21dc623c3d298.gif","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/5ef\/611\/847\/5ef611847db6bfa40237fb3622d93822.gif","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/633\/acb\/bee\/633acbbee01158bb7a6ad0450d39f712.gif"]}</script>
  <script src="//www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.49.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_eng"><meta data-vue-meta="ssr" property="og:title" content="RxDart: магические трансформации потоков" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="RxDart: магические трансформации потоков" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="RxDart: магические трансформации потоков" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="Добро пожаловать — это третья часть моей серии статей об архитектуре Flutter.

Введение  
Основы Dart Streams
RxDart: магические трансформации потоков (этот пост)
Основы RxVMS: RxCommand и..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="Добро пожаловать — это третья часть моей серии статей об архитектуре Flutter.

Введение  
Основы Dart Streams
RxDart: магические трансформации потоков (этот пост)
Основы RxVMS: RxCommand и..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="Добро пожаловать — это третья часть моей серии статей об архитектуре Flutter.

Введение  
Основы Dart Streams
RxDart: магические трансформации потоков (этот пост)
Основы RxVMS: RxCommand и..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="Добро пожаловать — это третья часть моей серии статей об архитектуре Flutter.

Введение  
Основы Dart Streams
RxDart: магические трансформации потоков (этот пост)
Основы RxVMS: RxCommand и..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="Добро пожаловать — это третья часть моей серии статей об архитектуре Flutter.

Введение  
Основы Dart Streams
RxDart: магические трансформации потоков (этот пост)
Основы RxVMS: RxCommand и..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habr.com/share/publication/451292/9e4e234cf01bea40e117e80de64de480/" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habr.com/share/publication/451292/9e4e234cf01bea40e117e80de64de480/" data-vmid="og:image"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habr.com/share/publication/451292/9e4e234cf01bea40e117e80de64de480/" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habr.com/share/publication/451292/9e4e234cf01bea40e117e80de64de480/" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habr.com/share/publication/451292/9e4e234cf01bea40e117e80de64de480/" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="451292" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2019-05-11T07:15:25.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/451292/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="https://habr.com/ru/post/451292/" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habr.com/share/publication/451292/9e4e234cf01bea40e117e80de64de480/" data-vmid="image:href">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="/ru/sandbox/start/" class="tm-header__become-author-btn">
            Как стать автором
          </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="/ru/all/" class="tm-main-menu__item">
        Все потоки
      </a> <a href="/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" data-async-called="true" class="tm-page"><div class="tm-page-width"><!----> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="/ru/users/rookie_cruekie/" title="rookie_cruekie" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="" height="24" loading="lazy" src="//habrastorage.org/r/w32/getpro/habr/avatars/47f/d4d/f50/47fd4df50c501c2de6c8e6f0a64fb8b0.jpg" width="24" class="tm-entity-image__pic"></div></a> <span class="tm-user-info__user"><a href="/ru/users/rookie_cruekie/" class="tm-user-info__username">
      rookie_cruekie
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2019-05-11T07:15:25.000Z" title="2019-05-11, 10:15">11  мая  2019 в 10:15</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>RxDart: магические трансформации потоков</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/dart/" class="tm-article-snippet__hubs-item-link"><span>Dart</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/flutter/" class="tm-article-snippet__hubs-item-link"><span>Flutter</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span></div> <div class="tm-article-snippet__labels"><div class="tm-article-snippet__label"><span>
        Перевод
      </span></div></div> <!----> <!----></div></div> <div class="tm-article-presenter__origin"><a href="https://www.burkharts.net/apps/blog/rxdart-magical-transformations-of-streams/" target="_blank" class="tm-article-presenter__origin-link">
                Автор оригинала:
                <span>
                  Thomas Burkhart
                </span></a></div> <div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-1"><div xmlns="http://www.w3.org/1999/xhtml"><p>Добро пожаловать — это третья часть моей серии статей об архитектуре Flutter.</p><br/>
<ul>
<li><a href="https://habr.com/ru/post/448776/">Введение </a> </li>
<li><a href="https://habr.com/ru/post/450950/">Основы Dart Streams</a></li>
<li><strong>RxDart: магические трансформации потоков (этот пост)</strong></li>
<li><a href="https://habr.com/ru/post/449872/">Основы RxVMS: RxCommand и GetIt</a></li>
<li>RxVMS: Службы и Менеджеры</li>
<li>RxVMS: самодостаточные виджеты</li>
<li>Аутентификация пользователя посредством RxVMS</li>
</ul><br/>
<p>На этот раз мы совершим небольшое погружение в магическое царство реактивных расширений (Rx). Я сосредоточусь на наиболее используемых функциях Rx и объясню их применение. Если вы не читали предыдущий пост, сейчас для этого самое время, прежде чем двигаться дальше.</p><br/>
<p><a href="https://github.com/ReactiveX/rxdart">RxDart</a> — это реализация концепции Rx для языка Dart, за что следует сказать спасибо <a href="https://github.com/frankpepermans">Frank Pepermans</a> и <a href="https://github.com/brianegan">Brian Egan</a>. Если ранее вы использовали Rx в других языках, то наверняка заметите разницу в именовании ряда функций, но это вряд ли вызовет у вас затруднения.</p><br/>
<p>Код для тестирования находится <a href="https://github.com/escamoteur/stream_rx_tutorial/tree/rx_magic">здесь</a>.</p><br/>
<p>До сих пор мы использовали потоки как способ передачи данных из одного места в другое в нашем приложении, но они могут сделать гораздо больше. Давайте взглянем на некоторые функции, которые Rx добавляет в Streams.</p><a name="habracut"></a><br/>
<h2 id="sozdanie-observables">Создание Observables</h2><br/>
<p>Как <a href="https://habr.com/ru/post/450950/">указывалось ранее</a>, Observables — это Rx-разновидности потоков с большими возможностями. Есть несколько интересных способов их создания:</p><br/>
<h3 id="iz-potoka">Из потока</h3><br/>
<p>Любой Stream может быть конвертирован в Observable путем передачи его в конструктор:</p><br/>
<pre><code class="cpp">var controller = new StreamController&lt;String>();

var streamObservable = new Observable(controller.stream);

streamObservable.listen(print);</code></pre><br/>
<h3 id="povtoryayuschiesya-sobytiya">Повторяющиеся события</h3><br/>
<pre><code class="cpp">var timerObservable = Observable.periodic(Duration(seconds: 1), (x) => x.toString() );

timerObservable.listen(print);</code></pre><br/>
<p>Этим способом будет сконструирован Observable, выводящий значения с определенным периодом. Так можно заменить таймер.</p><br/>
<h3 id="iz-odinochnogo-znacheniya">Из одиночного значения</h3><br/>
<p>Порой API ожидает Stream/Observable там, где у вас просто значение. Для таких случаев Observable имеет фабрику.</p><br/>
<pre><code class="cpp">var justObservable = Observable&lt;int>.just(42);

justObservable.listen(print);

// будет выведено значение: 42</code></pre><br/>
<h3 id="iz-future">Из Future</h3><br/>
<pre><code class="cpp">  Future&lt;String> asyncFunction() async {
    return Future.delayed(const Duration(seconds: 1), () => "AsyncRsult");
  }

  test('Create Observable from Future', () async {
    print('start');

    var fromFutureObservable = Observable.fromFuture(asyncFunction());

    fromFutureObservable.listen(print);</code></pre><br/>
<p>Создание <code>Observable</code> из <a href="https://api.dartlang.org/stable/2.3.0/dart-async/Future-class.html">Future</a> будет ждать завершения Future и выдавать значение его результата или <code>null</code>, если значение не возвращается. Еще один способ создания потока из Future — это вызов <code>toStream()</code> для любого Future.</p><br/>
<p>Вы можете задаться вопросом, какой смысл преобразовывать Future в Observable/Stream вместо того, чтобы просто ждать его. Будьте уверены, это станет понятным, когда мы исследуем доступные функции для манипулирования данными, пока они "в потоке".</p><br/>
<h3 id="subjects">Subjects</h3><br/>
<p><code>Subjects</code> являются заменой <code>StreamController</code> в RxDart, и именно так они и реализуются где-то в недрах библиотеки.</p><br/>
<p>Но их поведение слегка отличается от базовых StreamControllers:</p><br/>
<ul>
<li>вы можете применять <code>listen()</code> напрямую на Subject, без обращения к свойству Stream</li>
<li>доступно любое количество подписок, и все слушатели получают одни и те же данные одновременно</li>
<li>имеются три разновидности Subjects, которые объясняются ниже с примерами:</li>
</ul><br/>
<h4 id="publishsubjects">PublishSubjects</h4><br/>
<p><code>PublishSubjects</code> ведут себя словно <code>StreamControllers</code>, за исключением возможности множества слушателей:</p><br/>
<pre><code class="cpp">var subject = new PublishSubject&lt;String>();

subject.listen((item) => print(item)); 

subject.add("Item1");

// Добавим еще подписчика
subject.listen((item) => print(item.toUpperCase())); 

subject.add("Item2");
subject.add("Item3");

// Защита от завершения до приема всех данных 
await Future.delayed(Duration(seconds: 5));

// Завершение всех подписок
subject.close;</code></pre><br/>
<p>Запустите этот код и вы получите:</p><br/>
<pre><code class="cpp">Item1
ITEM2
Item2
ITEM3
Item3</code></pre><br/>
<p>Понятно, что второй слушатель, опоздавший на вечеринку (мы будем называть их поздними подписчиками), пропустил первый пункт. Чтобы избежать этого, можно использовать <code>BehaviourSubject</code></p><br/>
<h4 id="behavioursubject">BehaviourSubject</h4><br/>
<p>С <code>BehaviourSubject</code> каждый новый подписчик получит сперва последнее принятое значение:</p><br/>
<pre><code class="cpp">var subject = new BehaviorSubject&lt;String>();

subject.listen((item) => print(item)); 

subject.add("Item1");
subject.add("Item2");

subject.listen((item) => print(item.toUpperCase())); 

subject.add("Item3");</code></pre><br/>
<p>На выходе</p><br/>
<pre><code class="cpp">Item1
ITEM2
ITEM3
Item2
Item3</code></pre><br/>
<p>Вы можете видеть, что <code>Item1</code> потерян для второго подписчика, но он получает <code>Item2</code>. Вы можете быть удивлены тем, что второй подписчик получает <code>Item3</code> до того, как первый подписчик получает <code>Item2</code>. Это потому, что последовательность обслуживания подписчиков не гарантирована, хотя все подписчики получают данные в правильном порядке. <code>BehaviourSubject</code> кэширует только последний полученный элемент для поздних подписчиков. Если вам нужно кэшировать больше элементов, вы можете использовать <a href="https://pub.dev/documentation/rxdart/latest/rx/ReplaySubject-class.html">ReplaySubject</a>. В большинстве случаев это не нужно.</p><br/>
<h2 id="manipulirovanie-dannymi-na-letu">Манипулирование данными на лету</h2><br/>
<p><img src="/img/image-loader.svg" data-src="https://habrastorage.org/getpro/habr/post_images/ea5/dfe/1c6/ea5dfe1c65f93367e3207e2a0fe68908.gif"/> </p><br/>
<p>Истинная сила Rx заключается в том, что она позволяет обрабатывать данные в процессе передачи по потоку. Каждый из Rx-методов возвращает новый поток с результирующими данными (как на иллюстрации), значит, вы можете связать их вместе в один конвейер обработки, и это делает Rx чрезвычайно мощным инструментом.</p><br/>
<h3 id="map">Map</h3><br/>
<p>Если есть какая-либо операция Stream, которую я больше всего не хочу пропустить, то это <code>map()</code>. Что делает <code>map()</code>, так это то, что она принимает каждый передаваемый элемент данных и применяет к нему некую функцию, после чего помещает результат в результирующий поток. Простой пример:</p><br/>
<p><img src="/img/image-loader.svg" data-src="https://habrastorage.org/getpro/habr/post_images/8e0/05a/ecc/8e005aecc11e119b7c856a4cadec9b11.gif"/> </p><br/>
<pre><code class="cpp">var subject = new PublishSubject&lt;String>();

subject.map((item) => item.toUpperCase()).listen(print);

subject.add("Item1");
subject.add("Item2");
subject.add("Item3");</code></pre><br/>
<p>Результат:</p><br/>
<pre><code class="cpp">ITEM1
ITEM2
ITEM3</code></pre><br/>
<p>Но <code>map</code> не обязана возвращать тот же тип данных, который она получает в качестве входных. Следующий пример будет принимать целые числа вместо строк. Дополнительно мы будем связывать два преобразования:</p><br/>
<pre><code class="cpp">var subject = new PublishSubject&lt;int>();

subject.map((intValue) => intValue.toString())
    .map((item) => item.toUpperCase())
    .listen(print);

subject.add(1);
subject.add(2);
subject.add(3);</code></pre><br/>
<p>или что-то вроде этого:</p><br/>
<p><img src="/img/image-loader.svg" data-src="https://habrastorage.org/getpro/habr/post_images/0bb/73f/2a2/0bb73f2a2ccb82e6a920efbf2c395b0d.gif"/> </p><br/>
<pre><code class="cpp">class DataClass{}

class WrapperClass {
  final DataClass wrapped;

  WrapperClass(this.wrapped); 
}

var subject = new PublishSubject&lt;WrapperClass>();

subject.map&lt;WrapperClass>((a) => new WrapperClass(a));</code></pre><br/>
<p>Одно из наиболее полезных применений <code>.map</code> — это когда вы получаете данные в формате из некоторого REST API или из базы данных и хотите, чтобы они преобразовывались в ваши собственные объекты:</p><br/>
<pre><code class="cpp">class User {
  final String name;
  final String adress;
  final String phoneNumber;
  final int age;

  // в реальных проектах я бы рекомендовал какой-нибудь 
  // библиотечный сериализатор
  factory User.fromJson(String jsonString) {
    var jsonMap = json.decode(jsonString);

    return User(
      jsonMap['name'],
      jsonMap['adress'],
      jsonMap['phoneNumber'],
      jsonMap['age'],
    );
  }

  User(this.name, this.adress, this.phoneNumber, this.age);

  @override
  String toString() {
    return '$name - $adress - $phoneNumber - $age';
  }
}

void main() {
  test('Map', () {
    // каки-то данные
    var jsonStrings = [
      '{"name": "Jon Doe", "adress": "New York", "phoneNumber":"424242","age": 42 }',
      '{"name": "Stephen King", "adress": "Castle Rock", "phoneNumber":"123456","age": 71 }',
      '{"name": "Jon F. Kennedy", "adress": "Washington", "phoneNumber":"111111","age": 66 }',
    ];

    // симулируем некий json-поток, получаемый из внешнего API/DB.
    var dataStreamFromAPI = new PublishSubject&lt;String>();

    dataStreamFromAPI
        .map&lt;User>((jsonString) => User.fromJson(jsonString)) // json -> User
        .listen((user) => print(user.toString()));

    // Симулируем входные данные
    dataStreamFromAPI.add(jsonStrings[0]);
    dataStreamFromAPI.add(jsonStrings[1]);
    dataStreamFromAPI.add(jsonStrings[2]);
  });</code></pre><br/>
<p><em>Замечу, не только Streams, но и любой Iterable предлагает функцию <code>map</code>, которую вы можете использовать для преобразований в списках.</em></p><br/>
<h3 id="where">Where</h3><br/>
<p>Если вас интересуют только определенные значения, встречающиеся в потоке, вы можете использовать функцию <code>.where()</code> вместо использования оператора <code>if</code> в вашем слушателе, это более выразительно и проще для чтения:</p><br/>
<pre><code class="cpp">var subject = new PublishSubject&lt;int>();

subject.where((val) => val.isOdd)
    .listen( (val) => print('This only prints odd numbers: $val'));

subject.where((val) => val.isEven)
.listen( (val) => print('This only prints even numbers: $val'));

subject.add(1);
subject.add(2);
subject.add(3);

//выводит:
This only prints odd numbers: 1
This only prints even numbers: 2
This only prints odd numbers: 3</code></pre><br/>
<h3 id="debounce">Debounce</h3><br/>
<p>Это одна из маленьких жемчужин Rx! Представьте, что у вас есть поле поиска, которое осуществляет вызов API REST, если его текст изменен. Выполнение вызова API для каждого нажатия клавиши обходится дорого. Таким образом, вы хотели бы сделать вызов только если пользователь делает паузу на мгновение. Именно для этого используется функция <code>debounce()</code>, которая проглотит все входящие события, если за ними не последует пауза.</p><br/>
<pre><code class="cpp">var subject = new PublishSubject&lt;String>();

subject.debounce(new Duration(milliseconds: 500)).listen((s) => print(s));

subject.add('A');
subject.add('AB');

await Future.delayed(Duration(milliseconds: 200));

subject.add("ABC");
// Пока выводе нет

await Future.delayed(Duration(milliseconds: 700));

// а сейчас мы получим наше последнее значение: 'ABC'</code></pre><br/>
<p>Поэтому, если вы преобразуете обработчик <code>TextField.onChanged</code> в <code>Observable</code>, то получите элегантное решение.</p><br/>
<h3 id="expand">Expand</h3><br/>
<p>Если ваш исходный Stream испускает массивы объектов, а вы хотите обрабатывать каждый объект самостоятельно, вы можете использовать <code>.expand</code>, который сделает именно это:</p><br/>
<p><img src="/img/image-loader.svg" alt="image" data-src="https://habrastorage.org/getpro/habr/post_images/e8e/8d7/2b3/e8e8d72b36dddd0d3469107c6cdae2b1.gif"/></p><br/>
<p>Вы увидите применение этого метода ниже, в примере FireStore.</p><br/>
<h3 id="merge">Merge</h3><br/>
<p>Если у вас есть несколько разных потоков, но вы хотите обрабатывать их объекты вместе, вы можете использовать <code>.mergeWith</code> (в других реализациях Rx просто <code>merge</code>), который принимает массив потоков и возвращает один объединенный поток.</p><br/>
<p><img src="/img/image-loader.svg" alt="image" data-src="https://habrastorage.org/getpro/habr/post_images/a2f/9ba/82b/a2f9ba82b88b555841c21dc623c3d298.gif"/></p><br/>
<p><code>.mergeWith</code> не гарантирует соблюдение какого-либо порядка в потоках при их объединении. Данные испускаются в порядке входа.</p><br/>
<p>Например, если у вас есть два компонента, которые сообщают об ошибках через поток, и вы хотите, чтобы они вместе отображались в диалоге, вы можете сделать это следующим образом (псевдокод):</p><br/>
<pre><code class="cpp">@override
initState() {
  super.initState();

  component1.errors.mergeWith([component2.errors])
    .listen( (error) async => await showDialog(error.message));
}</code></pre><br/>
<p>или если вы хотите комбинированное отображение сообщений из нескольких социальных сетей, это может выглядеть так (псевдокод):</p><br/>
<pre><code class="cpp">final observableTwitter = getTwitterStream().map((data) => new MyAppPost.fromTwitter(data));
final observableFacebook = getFacebookStream().map((data) => new MyAppPost.fromFaceBook(data));
final postStream = observableTwitter.mergeWith([observableFacebook]);</code></pre><br/>
<h3 id="zipwith">ZipWith</h3><br/>
<p><code>zipWith</code> также объединяет один поток с другим. Но, в отличие от <code>.mergeWith</code>, он не отправляет данные, как только получает элемент от одного из своих исходных потоков. Он ожидает, пока не прибудут элементы из обоих исходных потоков, а затем объединяет их, используя предоставленную <code>zipper</code>-функцию:</p><br/>
<p><img src="/img/image-loader.svg" alt="image" data-src="https://habrastorage.org/getpro/habr/post_images/5ef/611/847/5ef611847db6bfa40237fb3622d93822.gif"/></p><br/>
<p>Сигнатура <code>zipWith</code> выглядит страшновато, но сейчас мы рассмотрим ее:</p><br/>
<pre><code class="cpp">// R : тип результирующего Stream/Observable
// S : тип второго Stream/Observable
// zipper: функция-сшивка
Observable&lt;R> zipWith&lt;S, R>(Stream&lt;S> other, R zipper(T t, S s))</code></pre><br/>
<p>Весьма упрощенный пример:</p><br/>
<pre><code class="cpp">new Observable.just(1) // .just() создает Observable, испускающий одно значение
    .zipWith(new Observable.just(2), (one, two) => one + two)
    .listen(print); // печатает 3</code></pre><br/>
<p>Более практичное применение — если вам нужно дождаться двух асинхронных функций, которые возвращают <code>Future</code>, и вы хотите обработать данные, как только будут возвращены оба результата. В этом слегка надуманном примере мы представляем два REST API: один возвращает <code>User</code>, другой — <code>Product</code> в виде строк JSON, и мы хотим дождаться обоих вызовов, прежде чем вернуть объект <code>Invoice</code>.</p><br/>
<pre><code class="cpp">class Invoice {
  final User user;
  final Product product;

  Invoice(this.user, this.product);

  printInvoice() {
    print(user.toString());
    print(product.toString());
  }
}

// Симуляция HTTP вызова, возвращающего Product, как JSON
Future&lt;String> getProduct() async {
  print("Started getting product");
  await Future.delayed(Duration(seconds: 2));
  print("Finished getting product");
  return '{"name": "Flux compensator", "price": 99999.99}';
}

// Симуляция HTTP вызова, возвращающего User, как JSON
Future&lt;String> getUser() async {
  print("Started getting User");
  await Future.delayed(Duration(seconds: 4));
  print("Finished getting User");
  return '{"name": "Jon Doe", "adress": "New York", "phoneNumber":"424242","age": 42 }';
}

void main() {
  test('zipWith', () async {
    var userObservable =
        Observable.fromFuture(getUser()).map&lt;User>((jsonString) => User.fromJson(jsonString));

    var productObservable = Observable.fromFuture(getProduct())
        .map&lt;Product>((jsonString) => Product.fromJson(jsonString));

    Observable&lt;Invoice> invoiceObservable = userObservable.zipWith&lt;Product, Invoice>(
        productObservable, (user, product) => Invoice(user, product));

    print("Start listening for invoices");
    invoiceObservable.listen((invoice) => invoice.printInvoice());

    // предотвращает раннее завершение теста в целях тестирования
    await Future.delayed(Duration(seconds: 5));
  });
}</code></pre><br/>
<p>Глядя на вывод, вы можете увидеть, как это выполняется асинхронно</p><br/>
<pre><code class="cpp">Started getting User
Started getting product
Start listening for invoices
Finished getting product
Finished getting User
Jon Doe - New York - 424242 - 42
Flux compensator - 99999.99</code></pre><br/>
<h3 id="combinelatest">CombineLatest</h3><br/>
<p><code>combineLatest</code> тоже объединяет значения потоков, но немного по-другому, чем <code>merge</code> и <code>zip</code>. Он прослушивает большее количество потоков и выдает объединенное значение всякий раз, когда приходит новое значение из одного из потоков. Интересно то, что он генерирует не только измененное значение, но и последние полученные значения всех других исходных потоков. Посмотрите внимательно на эту анимацию:</p><br/>
<p><img src="/img/image-loader.svg" alt="image" data-src="https://habrastorage.org/getpro/habr/post_images/633/acb/bee/633acbbee01158bb7a6ad0450d39f712.gif"/></p><br/>
<p>До того, как <code>combineLates</code> выдаст свое первое значение, все исходные потоки должны получить на вход хотя бы один элемент.</p><br/>
<p>В отличие от методов, которые использовались ранее, <code>combineLatest</code> — является статическим. Кроме того, поскольку Dart не допускает перегрузки операторов, существуют версии <code>combLastest</code> в зависимости от количества исходных потоков: <strong>combineLatest2...combineLatest9</strong></p><br/>
<p>Хорошее применение <code>combineLatest</code>, например, если у вас есть два <code>Observable&lt;bool></code>, которые сигнализируют о том, что некоторые части вашего приложения заняты, и вы хотите отобразить спиннер "Занято", если один из них занят. Это может выглядеть следующим образом (псевдокод):</p><br/>
<pre><code class="cpp">class Model {
  Observable&lt;bool> get isBusy => 
    Observable.combineLatest2(isBusyOne,isBusyTwo, (b1, b2) => b1 || b2);

  PublishSubject&lt;bool> isBusyOne;
  PublishSubject&lt;bool> isBusyTwo;
}</code></pre><br/>
<p>В вашем UI вы можете использовать <code>isBusy</code> с <code>StreamBuilder</code> для отображения <code>Spinner</code>, если полученное значение истинно.</p><br/>
<p><code>combineLatest</code> очень подходящая функция в комбинации с потоками <strong>FireStore snapshots</strong>.</p><br/>
<p>Представьте, что вы хотите создать приложение, которое отображает новостную ленту вместе с прогнозом погоды. Сообщения тикеров и данные о погоде хранятся в двух разных коллекциях FireStore. Оба обновляются независимо. Вы хотите отобразить обновления данных с помощью StreamBuilder. С <code>combineLatest</code> это легко:</p><br/>
<pre><code class="cpp">class WeatherForecast {
  final String forecastText;
  final GeoPoint location;

  factory WeatherForecast.fromMap(Map&lt;String, dynamic> map) {
    return WeatherForecast(map['forecastText'], map['location']);
  }

  WeatherForecast(this.forecastText, this.location);
}

class NewsMessage {
  final String newsText;
  final GeoPoint location;

  factory NewsMessage.fromMap(Map&lt;String, dynamic> map) {
    return NewsMessage(map['newsText'], map['location']);
  }

  NewsMessage(this.newsText, this.location);
}

class CombinedMessage {
  final WeatherForecast forecast;
  final NewsMessage newsMessage;

  CombinedMessage(this.forecast, this.newsMessage);
}

class Model {
  CollectionReference weatherCollection;
  CollectionReference newsCollection;

  Model() {
    weatherCollection = Firestore.instance.collection('weather');
    newsCollection = Firestore.instance.collection('news');
  }

  Observable&lt;CombinedMessage> getCombinedMessages() {
    Observable&lt;WeatherForecast> weatherForecasts = weatherCollection
        .snapshots()
        .expand((snapShot) => snapShot.documents)
        .map&lt;WeatherForecast>((document) => WeatherForecast.fromMap(document.data));

    Observable&lt;NewsMessage> news = newsCollection
        .snapshots()
        .expand((snapShot) => snapShot.documents)
        .map&lt;NewsMessage>((document) => NewsMessage.fromMap(document.data));

    return Observable.combineLatest2(
        weatherForecasts, news, (weather, news) => CombinedMessage(weather, news));
  }
}</code></pre><br/>
<p>В вашем UI это выглядело бы как-то так: <code>StreamBuilder&lt;CombinedMessage>(stream: model.getCombinedMessages(),...).</code></p><br/>
<h3 id="distinct">Distinct</h3><br/>
<p>В описанном выше сценарии может случиться, что <strong>isBusyOne</strong> и <strong>isBusyTwo</strong> выдают одно и то же значение, что приведет к обновлению пользовательского интерфейса с теми же данными. Чтобы предотвратить это, мы можем использовать <code>.distinct()</code>. Он гарантирует, что данные передаются по потоку только в том случае, если значение нового элемента отличается от последнего. Таким образом, мы изменили бы код на:</p><br/>
<pre><code class="cpp">  Observable&lt;bool> isBusy => isBusyOne.mergeWith([isBusyTwo]).distinct();</code></pre><br/>
<p>и это также демонстрирует, что мы можем комбинировать наши функции в различные цепочки по желанию.</p><br/>
<h3 id="asyncmap">AsyncMap</h3><br/>
<p>Помимо <code>map()</code> есть также функция <code>asyncMap</code>, которая позволяет использовать асинхронную функцию в качестве map-функции. Давайте представим немного другую настройку для нашего примера FireStore. Теперь необходимый <strong>WeatherForecast</strong> зависит от местоположения <strong>NewsMessage</strong> и должен обновляться только при получении нового <strong>NewsMessage</strong>:</p><br/>
<pre><code class="cpp">Observable&lt;CombinedMessage> getDependendMessages() {

  Observable&lt;NewsMessage> news = newsCollection.snapshots().expand((snapShot) {
    return snapShot.documents;
  }).map&lt;NewsMessage>((document) {
    return NewsMessage.fromMap(document.data);
  });

  return news.asyncMap((newsEntry) async {
    var weatherDocuments =
        await weatherCollection.where('location', isEqualTo: newsEntry.location).getDocuments();
    return new CombinedMessage(
        WeatherForecast.fromMap(weatherDocuments.documents.first.data), newsEntry);
  });
}</code></pre><br/>
<p>Observable, возвращаемый getDependendMessages, будет генерировать новое CombinedMessage каждый раз, когда изменяется newsCollection.</p><br/>
<h2 id="otladka-observables">Отладка Observables</h2><br/>
<p>Глядя на элегантные цепочки вызовов Rx кажется, что почти невозможно отладить выражение вроде этого:</p><br/>
<pre><code class="cpp">Observable&lt;NewsMessage> news = newsCollection
    .snapshots()
    .expand((snapShot) => snapShot.documents)
    .map&lt;NewsMessage>((document) => NewsMessage.fromMap(document.data));</code></pre><br/>
<p>Но имейте в виду, что <code>=></code> — это только краткая форма для анонимной функции. Используя <strong>Convert to block body</strong>, вы получите:</p><br/>
<pre><code class="cpp">Observable&lt;NewsMessage> news = newsCollection
        .snapshots()
        .expand((snapShot) {
          return snapShot.documents;
        })
        .map&lt;NewsMessage>((document) {
          return NewsMessage.fromMap(document.data);
        });</code></pre><br/>
<p>И теперь мы можем установить точку останова или добавить операторы печати на каждом этапе нашего "конвейера".</p><br/>
<h2 id="osteregaytes-pobochnyh-effektov">Остерегайтесь побочных эффектов</h2><br/>
<p><strong>Если вы хотите извлечь выгоду из Rx, чтобы сделать ваш код более надежным, всегда держите в голове, что Rx — это преобразование данных при их перемещении "по конвейерной ленте". Поэтому никогда не вызывайте функции, которые изменяют какие-либо переменные/состояния вне конвейера обработки, пока вы не достигнете функции .listen. </strong><br/>
Вместо того, чтобы делать так:</p><br/>
<pre><code class="cpp">Observable.fromFuture(getProduct())
        .map&lt;Product>((jsonString) { 
     var product = Product.fromJson(jsonString);
    database.save(product);
    setState((){ _product =  product });
    return product;
}).listen();</code></pre><br/>
<p>делайте так:</p><br/>
<pre><code class="cpp">Observable.fromFuture(getProduct())
        .map&lt;Product>((jsonString) => Product.fromJson(jsonString))
        .listen( (product) {
          database.save(product);  
          setState((){ _product =  product });
        });</code></pre><br/>
<p>Обязанность <code>map()</code> — преобразование данных в потоке, И НИЧЕГО БОЛЬШЕ! Если переданная функция отображения делает что-то еще, это будет рассматриваться как побочный эффект, плодящий потенциальные ошибки, который трудно обнаружить при чтении кода.</p><br/>
<h2 id="nekotorye-mysli-ob-osvobozhdenii-resursov">Некоторые мысли об освобождении ресурсов</h2><br/>
<p>Чтобы избежать утечек памяти, всегда вызывайте <code>cancel()</code> для подписок, <code>dispose()</code> для StreamControllers, <code>close()</code> для Subjects, как только они вам больше не нужны.</p><br/>
<h2 id="zaklyuchenie">Заключение</h2><br/>
<p>Поздравляю, если вы остались со мной до этого момента. Теперь вы не только можете использовать Rx, чтобы облегчить свою жизнь, но и подготовиться к следующим постам, в которых мы углубимся в детали <strong>RxVMS</strong>.</p></div></div> <!----> <!----></div> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bflutter%5D" class="tm-tags-list__link">flutter</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bdart%5D" class="tm-tags-list__link">dart</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%5D" class="tm-tags-list__link">практика программирования</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/hub/dart/" class="tm-hubs-list__link">
    Dart
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/flutter/" class="tm-hubs-list__link">
    Flutter
  </a></li></ul></div></div></article></div> <!----></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_medium"><title>Всего голосов 6: ↑6 и ↓0</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-rating"></use></svg> <span title="Всего голосов 6: ↑6 и ↓0" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_medium">+6</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">16K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    35
  </span></button> <!----> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> </div></div> <!----> <!----> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="/ru/users/rookie_cruekie/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><img alt="" src="//habrastorage.org/getpro/habr/avatars/47f/d4d/f50/47fd4df50c501c2de6c8e6f0a64fb8b0.jpg" class="tm-entity-image__pic"></div></a> <div class="tm-user-card__meta"><div title=" 20 голосов " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    16
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">0</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title_variant-article"><span class="tm-user-card__name tm-user-card__name_variant-article">Валерий</span> <a href="/ru/users/rookie_cruekie/" class="tm-user-card__nickname tm-user-card__nickname_variant-article">
          @rookie_cruekie
        </a> <!----></div> <p class="tm-user-card__short-info tm-user-card__short-info_variant-article">Программист</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-article"><!----> <!----> <!----> <!----> <!----></div></div> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----></section> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="/ru/post/451292/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментарии 2 
    </span></a> <!----></div></div></div> <div class="tm-ad-banner__container tm-page-article__banner"><!----> <div id="articleBottomBanner" class="tm-ad-banner"></div></div> <!----> <!----> <!----> <!----> </div></div></div></div></div> <div class="tm-page__sidebar"><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__ads tm-layout-sidebar__ads_initial"><div class="tm-ad-banner__container tm-layout-sidebar__banner"><!----> <div id="sidebarBanner" class="tm-ad-banner"></div></div></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----> <!----></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/post/451292/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/post/451292/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2021 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"451292":{"id":"451292","timePublished":"2019-05-11T07:15:25+00:00","isCorporative":false,"lang":"ru","titleHtml":"RxDart: магические трансформации потоков","leadData":{"textHtml":"\u003Cp\u003EДобро пожаловать — это третья часть моей серии статей об архитектуре Flutter.\u003C\u002Fp\u003E\u003Cbr\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F448776\u002F\"\u003EВведение \u003C\u002Fa\u003E \u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F450950\u002F\"\u003EОсновы Dart Streams\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cstrong\u003ERxDart: магические трансформации потоков (этот пост)\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F449872\u002F\"\u003EОсновы RxVMS: RxCommand и GetIt\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003ERxVMS: Службы и Менеджеры\u003C\u002Fli\u003E\r\n\u003Cli\u003ERxVMS: самодостаточные виджеты\u003C\u002Fli\u003E\r\n\u003Cli\u003EАутентификация пользователя посредством RxVMS\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u003E\r\n\u003Cp\u003EНа этот раз мы совершим небольшое погружение в магическое царство реактивных расширений (Rx). Я сосредоточусь на наиболее используемых функциях Rx и объясню их применение. Если вы не читали предыдущий пост, сейчас для этого самое время, прежде чем двигаться дальше.\u003C\u002Fp\u003E\u003Cbr\u003E\r\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002FReactiveX\u002Frxdart\"\u003ERxDart\u003C\u002Fa\u003E — это реализация концепции Rx для языка Dart, за что следует сказать спасибо \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Ffrankpepermans\"\u003EFrank Pepermans\u003C\u002Fa\u003E и \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fbrianegan\"\u003EBrian Egan\u003C\u002Fa\u003E. Если ранее вы использовали Rx в других языках, то наверняка заметите разницу в именовании ряда функций, но это вряд ли вызовет у вас затруднения.\u003C\u002Fp\u003E\u003Cbr\u003E\r\n\u003Cp\u003EКод для тестирования находится \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fescamoteur\u002Fstream_rx_tutorial\u002Ftree\u002Frx_magic\"\u003Eздесь\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cbr\u003E\r\n\u003Cp\u003EДо сих пор мы использовали потоки как способ передачи данных из одного места в другое в нашем приложении, но они могут сделать гораздо больше. Давайте взглянем на некоторые функции, которые Rx добавляет в Streams.\u003C\u002Fp\u003E","imageUrl":null,"buttonTextHtml":"Читать дальше →","image":null},"editorVersion":"1.0","postType":"article","postLabels":[{"type":"translation","data":{"originalAuthorName":"Thomas Burkhart","originalUrl":"https:\u002F\u002Fwww.burkharts.net\u002Fapps\u002Fblog\u002Frxdart-magical-transformations-of-streams\u002F"}}],"author":{"scoreStats":{"score":16,"votesCount":20},"rating":0,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"1319778","alias":"rookie_cruekie","fullname":"Валерий","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F47f\u002Fd4d\u002Ff50\u002F47fd4df50c501c2de6c8e6f0a64fb8b0.jpg","speciality":"Программист"},"statistics":{"commentsCount":2,"favoritesCount":35,"readingCount":15538,"score":6,"votesCount":6},"hubs":[{"relatedData":null,"id":"17712","alias":"dart","type":"collective","title":"Dart","titleHtml":"Dart","isProfiled":true},{"relatedData":null,"id":"22176","alias":"flutter","type":"collective","title":"Flutter","titleHtml":"Flutter","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Cp\u003EДобро пожаловать — это третья часть моей серии статей об архитектуре Flutter.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F448776\u002F\"\u003EВведение \u003C\u002Fa\u003E \u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F450950\u002F\"\u003EОсновы Dart Streams\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cstrong\u003ERxDart: магические трансформации потоков (этот пост)\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F449872\u002F\"\u003EОсновы RxVMS: RxCommand и GetIt\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003ERxVMS: Службы и Менеджеры\u003C\u002Fli\u003E\r\n\u003Cli\u003ERxVMS: самодостаточные виджеты\u003C\u002Fli\u003E\r\n\u003Cli\u003EАутентификация пользователя посредством RxVMS\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНа этот раз мы совершим небольшое погружение в магическое царство реактивных расширений (Rx). Я сосредоточусь на наиболее используемых функциях Rx и объясню их применение. Если вы не читали предыдущий пост, сейчас для этого самое время, прежде чем двигаться дальше.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002FReactiveX\u002Frxdart\"\u003ERxDart\u003C\u002Fa\u003E — это реализация концепции Rx для языка Dart, за что следует сказать спасибо \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Ffrankpepermans\"\u003EFrank Pepermans\u003C\u002Fa\u003E и \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fbrianegan\"\u003EBrian Egan\u003C\u002Fa\u003E. Если ранее вы использовали Rx в других языках, то наверняка заметите разницу в именовании ряда функций, но это вряд ли вызовет у вас затруднения.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКод для тестирования находится \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fescamoteur\u002Fstream_rx_tutorial\u002Ftree\u002Frx_magic\"\u003Eздесь\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДо сих пор мы использовали потоки как способ передачи данных из одного места в другое в нашем приложении, но они могут сделать гораздо больше. Давайте взглянем на некоторые функции, которые Rx добавляет в Streams.\u003C\u002Fp\u003E\u003Ca name=\"habracut\"\u003E\u003C\u002Fa\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"sozdanie-observables\"\u003EСоздание Observables\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКак \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F450950\u002F\"\u003Eуказывалось ранее\u003C\u002Fa\u003E, Observables — это Rx-разновидности потоков с большими возможностями. Есть несколько интересных способов их создания:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"iz-potoka\"\u003EИз потока\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЛюбой Stream может быть конвертирован в Observable путем передачи его в конструктор:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Evar controller = new StreamController&lt;String\u003E();\n\nvar streamObservable = new Observable(controller.stream);\n\nstreamObservable.listen(print);\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"povtoryayuschiesya-sobytiya\"\u003EПовторяющиеся события\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Evar timerObservable = Observable.periodic(Duration(seconds: 1), (x) =\u003E x.toString() );\n\ntimerObservable.listen(print);\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЭтим способом будет сконструирован Observable, выводящий значения с определенным периодом. Так можно заменить таймер.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"iz-odinochnogo-znacheniya\"\u003EИз одиночного значения\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПорой API ожидает Stream\u002FObservable там, где у вас просто значение. Для таких случаев Observable имеет фабрику.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Evar justObservable = Observable&lt;int\u003E.just(42);\n\njustObservable.listen(print);\n\n\u002F\u002F будет выведено значение: 42\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"iz-future\"\u003EИз Future\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E  Future&lt;String\u003E asyncFunction() async {\n    return Future.delayed(const Duration(seconds: 1), () =\u003E \"AsyncRsult\");\n  }\n\n  test('Create Observable from Future', () async {\n    print('start');\n\n    var fromFutureObservable = Observable.fromFuture(asyncFunction());\n\n    fromFutureObservable.listen(print);\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EСоздание \u003Ccode\u003EObservable\u003C\u002Fcode\u003E из \u003Ca href=\"https:\u002F\u002Fapi.dartlang.org\u002Fstable\u002F2.3.0\u002Fdart-async\u002FFuture-class.html\"\u003EFuture\u003C\u002Fa\u003E будет ждать завершения Future и выдавать значение его результата или \u003Ccode\u003Enull\u003C\u002Fcode\u003E, если значение не возвращается. Еще один способ создания потока из Future — это вызов \u003Ccode\u003EtoStream()\u003C\u002Fcode\u003E для любого Future.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВы можете задаться вопросом, какой смысл преобразовывать Future в Observable\u002FStream вместо того, чтобы просто ждать его. Будьте уверены, это станет понятным, когда мы исследуем доступные функции для манипулирования данными, пока они \"в потоке\".\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"subjects\"\u003ESubjects\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ccode\u003ESubjects\u003C\u002Fcode\u003E являются заменой \u003Ccode\u003EStreamController\u003C\u002Fcode\u003E в RxDart, и именно так они и реализуются где-то в недрах библиотеки.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНо их поведение слегка отличается от базовых StreamControllers:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003Eвы можете применять \u003Ccode\u003Elisten()\u003C\u002Fcode\u003E напрямую на Subject, без обращения к свойству Stream\u003C\u002Fli\u003E\r\n\u003Cli\u003Eдоступно любое количество подписок, и все слушатели получают одни и те же данные одновременно\u003C\u002Fli\u003E\r\n\u003Cli\u003Eимеются три разновидности Subjects, которые объясняются ниже с примерами:\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Ch4 id=\"publishsubjects\"\u003EPublishSubjects\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ccode\u003EPublishSubjects\u003C\u002Fcode\u003E ведут себя словно \u003Ccode\u003EStreamControllers\u003C\u002Fcode\u003E, за исключением возможности множества слушателей:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Evar subject = new PublishSubject&lt;String\u003E();\n\nsubject.listen((item) =\u003E print(item)); \n\nsubject.add(\"Item1\");\n\n\u002F\u002F Добавим еще подписчика\nsubject.listen((item) =\u003E print(item.toUpperCase())); \n\nsubject.add(\"Item2\");\nsubject.add(\"Item3\");\n\n\u002F\u002F Защита от завершения до приема всех данных \nawait Future.delayed(Duration(seconds: 5));\n\n\u002F\u002F Завершение всех подписок\nsubject.close;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЗапустите этот код и вы получите:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003EItem1\nITEM2\nItem2\nITEM3\nItem3\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПонятно, что второй слушатель, опоздавший на вечеринку (мы будем называть их поздними подписчиками), пропустил первый пункт. Чтобы избежать этого, можно использовать \u003Ccode\u003EBehaviourSubject\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch4 id=\"behavioursubject\"\u003EBehaviourSubject\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EС \u003Ccode\u003EBehaviourSubject\u003C\u002Fcode\u003E каждый новый подписчик получит сперва последнее принятое значение:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Evar subject = new BehaviorSubject&lt;String\u003E();\n\nsubject.listen((item) =\u003E print(item)); \n\nsubject.add(\"Item1\");\nsubject.add(\"Item2\");\n\nsubject.listen((item) =\u003E print(item.toUpperCase())); \n\nsubject.add(\"Item3\");\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНа выходе\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003EItem1\nITEM2\nITEM3\nItem2\nItem3\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВы можете видеть, что \u003Ccode\u003EItem1\u003C\u002Fcode\u003E потерян для второго подписчика, но он получает \u003Ccode\u003EItem2\u003C\u002Fcode\u003E. Вы можете быть удивлены тем, что второй подписчик получает \u003Ccode\u003EItem3\u003C\u002Fcode\u003E до того, как первый подписчик получает \u003Ccode\u003EItem2\u003C\u002Fcode\u003E. Это потому, что последовательность обслуживания подписчиков не гарантирована, хотя все подписчики получают данные в правильном порядке. \u003Ccode\u003EBehaviourSubject\u003C\u002Fcode\u003E кэширует только последний полученный элемент для поздних подписчиков. Если вам нужно кэшировать больше элементов, вы можете использовать \u003Ca href=\"https:\u002F\u002Fpub.dev\u002Fdocumentation\u002Frxdart\u002Flatest\u002Frx\u002FReplaySubject-class.html\"\u003EReplaySubject\u003C\u002Fa\u003E. В большинстве случаев это не нужно.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"manipulirovanie-dannymi-na-letu\"\u003EМанипулирование данными на лету\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002Fea5\u002Fdfe\u002F1c6\u002Fea5dfe1c65f93367e3207e2a0fe68908.gif\"\u002F\u003E \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИстинная сила Rx заключается в том, что она позволяет обрабатывать данные в процессе передачи по потоку. Каждый из Rx-методов возвращает новый поток с результирующими данными (как на иллюстрации), значит, вы можете связать их вместе в один конвейер обработки, и это делает Rx чрезвычайно мощным инструментом.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"map\"\u003EMap\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЕсли есть какая-либо операция Stream, которую я больше всего не хочу пропустить, то это \u003Ccode\u003Emap()\u003C\u002Fcode\u003E. Что делает \u003Ccode\u003Emap()\u003C\u002Fcode\u003E, так это то, что она принимает каждый передаваемый элемент данных и применяет к нему некую функцию, после чего помещает результат в результирующий поток. Простой пример:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F8e0\u002F05a\u002Fecc\u002F8e005aecc11e119b7c856a4cadec9b11.gif\"\u002F\u003E \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Evar subject = new PublishSubject&lt;String\u003E();\n\nsubject.map((item) =\u003E item.toUpperCase()).listen(print);\n\nsubject.add(\"Item1\");\nsubject.add(\"Item2\");\nsubject.add(\"Item3\");\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EРезультат:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003EITEM1\nITEM2\nITEM3\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНо \u003Ccode\u003Emap\u003C\u002Fcode\u003E не обязана возвращать тот же тип данных, который она получает в качестве входных. Следующий пример будет принимать целые числа вместо строк. Дополнительно мы будем связывать два преобразования:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Evar subject = new PublishSubject&lt;int\u003E();\n\nsubject.map((intValue) =\u003E intValue.toString())\n    .map((item) =\u003E item.toUpperCase())\n    .listen(print);\n\nsubject.add(1);\nsubject.add(2);\nsubject.add(3);\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003Eили что-то вроде этого:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F0bb\u002F73f\u002F2a2\u002F0bb73f2a2ccb82e6a920efbf2c395b0d.gif\"\u002F\u003E \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Eclass DataClass{}\n\nclass WrapperClass {\n  final DataClass wrapped;\n\n  WrapperClass(this.wrapped); \n}\n\nvar subject = new PublishSubject&lt;WrapperClass\u003E();\n\nsubject.map&lt;WrapperClass\u003E((a) =\u003E new WrapperClass(a));\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EОдно из наиболее полезных применений \u003Ccode\u003E.map\u003C\u002Fcode\u003E — это когда вы получаете данные в формате из некоторого REST API или из базы данных и хотите, чтобы они преобразовывались в ваши собственные объекты:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Eclass User {\n  final String name;\n  final String adress;\n  final String phoneNumber;\n  final int age;\n\n  \u002F\u002F в реальных проектах я бы рекомендовал какой-нибудь \n  \u002F\u002F библиотечный сериализатор\n  factory User.fromJson(String jsonString) {\n    var jsonMap = json.decode(jsonString);\n\n    return User(\n      jsonMap['name'],\n      jsonMap['adress'],\n      jsonMap['phoneNumber'],\n      jsonMap['age'],\n    );\n  }\n\n  User(this.name, this.adress, this.phoneNumber, this.age);\n\n  @override\n  String toString() {\n    return '$name - $adress - $phoneNumber - $age';\n  }\n}\n\nvoid main() {\n  test('Map', () {\n    \u002F\u002F каки-то данные\n    var jsonStrings = [\n      '{\"name\": \"Jon Doe\", \"adress\": \"New York\", \"phoneNumber\":\"424242\",\"age\": 42 }',\n      '{\"name\": \"Stephen King\", \"adress\": \"Castle Rock\", \"phoneNumber\":\"123456\",\"age\": 71 }',\n      '{\"name\": \"Jon F. Kennedy\", \"adress\": \"Washington\", \"phoneNumber\":\"111111\",\"age\": 66 }',\n    ];\n\n    \u002F\u002F симулируем некий json-поток, получаемый из внешнего API\u002FDB.\n    var dataStreamFromAPI = new PublishSubject&lt;String\u003E();\n\n    dataStreamFromAPI\n        .map&lt;User\u003E((jsonString) =\u003E User.fromJson(jsonString)) \u002F\u002F json -\u003E User\n        .listen((user) =\u003E print(user.toString()));\n\n    \u002F\u002F Симулируем входные данные\n    dataStreamFromAPI.add(jsonStrings[0]);\n    dataStreamFromAPI.add(jsonStrings[1]);\n    dataStreamFromAPI.add(jsonStrings[2]);\n  });\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cem\u003EЗамечу, не только Streams, но и любой Iterable предлагает функцию \u003Ccode\u003Emap\u003C\u002Fcode\u003E, которую вы можете использовать для преобразований в списках.\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"where\"\u003EWhere\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЕсли вас интересуют только определенные значения, встречающиеся в потоке, вы можете использовать функцию \u003Ccode\u003E.where()\u003C\u002Fcode\u003E вместо использования оператора \u003Ccode\u003Eif\u003C\u002Fcode\u003E в вашем слушателе, это более выразительно и проще для чтения:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Evar subject = new PublishSubject&lt;int\u003E();\n\nsubject.where((val) =\u003E val.isOdd)\n    .listen( (val) =\u003E print('This only prints odd numbers: $val'));\n\nsubject.where((val) =\u003E val.isEven)\n.listen( (val) =\u003E print('This only prints even numbers: $val'));\n\nsubject.add(1);\nsubject.add(2);\nsubject.add(3);\n\n\u002F\u002Fвыводит:\nThis only prints odd numbers: 1\nThis only prints even numbers: 2\nThis only prints odd numbers: 3\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"debounce\"\u003EDebounce\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЭто одна из маленьких жемчужин Rx! Представьте, что у вас есть поле поиска, которое осуществляет вызов API REST, если его текст изменен. Выполнение вызова API для каждого нажатия клавиши обходится дорого. Таким образом, вы хотели бы сделать вызов только если пользователь делает паузу на мгновение. Именно для этого используется функция \u003Ccode\u003Edebounce()\u003C\u002Fcode\u003E, которая проглотит все входящие события, если за ними не последует пауза.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Evar subject = new PublishSubject&lt;String\u003E();\n\nsubject.debounce(new Duration(milliseconds: 500)).listen((s) =\u003E print(s));\n\nsubject.add('A');\nsubject.add('AB');\n\nawait Future.delayed(Duration(milliseconds: 200));\n\nsubject.add(\"ABC\");\n\u002F\u002F Пока выводе нет\n\nawait Future.delayed(Duration(milliseconds: 700));\n\n\u002F\u002F а сейчас мы получим наше последнее значение: 'ABC'\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПоэтому, если вы преобразуете обработчик \u003Ccode\u003ETextField.onChanged\u003C\u002Fcode\u003E в \u003Ccode\u003EObservable\u003C\u002Fcode\u003E, то получите элегантное решение.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"expand\"\u003EExpand\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЕсли ваш исходный Stream испускает массивы объектов, а вы хотите обрабатывать каждый объект самостоятельно, вы можете использовать \u003Ccode\u003E.expand\u003C\u002Fcode\u003E, который сделает именно это:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"image\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002Fe8e\u002F8d7\u002F2b3\u002Fe8e8d72b36dddd0d3469107c6cdae2b1.gif\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВы увидите применение этого метода ниже, в примере FireStore.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"merge\"\u003EMerge\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЕсли у вас есть несколько разных потоков, но вы хотите обрабатывать их объекты вместе, вы можете использовать \u003Ccode\u003E.mergeWith\u003C\u002Fcode\u003E (в других реализациях Rx просто \u003Ccode\u003Emerge\u003C\u002Fcode\u003E), который принимает массив потоков и возвращает один объединенный поток.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"image\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002Fa2f\u002F9ba\u002F82b\u002Fa2f9ba82b88b555841c21dc623c3d298.gif\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ccode\u003E.mergeWith\u003C\u002Fcode\u003E не гарантирует соблюдение какого-либо порядка в потоках при их объединении. Данные испускаются в порядке входа.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНапример, если у вас есть два компонента, которые сообщают об ошибках через поток, и вы хотите, чтобы они вместе отображались в диалоге, вы можете сделать это следующим образом (псевдокод):\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E@override\ninitState() {\n  super.initState();\n\n  component1.errors.mergeWith([component2.errors])\n    .listen( (error) async =\u003E await showDialog(error.message));\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003Eили если вы хотите комбинированное отображение сообщений из нескольких социальных сетей, это может выглядеть так (псевдокод):\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Efinal observableTwitter = getTwitterStream().map((data) =\u003E new MyAppPost.fromTwitter(data));\nfinal observableFacebook = getFacebookStream().map((data) =\u003E new MyAppPost.fromFaceBook(data));\nfinal postStream = observableTwitter.mergeWith([observableFacebook]);\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"zipwith\"\u003EZipWith\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ccode\u003EzipWith\u003C\u002Fcode\u003E также объединяет один поток с другим. Но, в отличие от \u003Ccode\u003E.mergeWith\u003C\u002Fcode\u003E, он не отправляет данные, как только получает элемент от одного из своих исходных потоков. Он ожидает, пока не прибудут элементы из обоих исходных потоков, а затем объединяет их, используя предоставленную \u003Ccode\u003Ezipper\u003C\u002Fcode\u003E-функцию:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"image\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F5ef\u002F611\u002F847\u002F5ef611847db6bfa40237fb3622d93822.gif\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EСигнатура \u003Ccode\u003EzipWith\u003C\u002Fcode\u003E выглядит страшновато, но сейчас мы рассмотрим ее:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E\u002F\u002F R : тип результирующего Stream\u002FObservable\n\u002F\u002F S : тип второго Stream\u002FObservable\n\u002F\u002F zipper: функция-сшивка\nObservable&lt;R\u003E zipWith&lt;S, R\u003E(Stream&lt;S\u003E other, R zipper(T t, S s))\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВесьма упрощенный пример:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Enew Observable.just(1) \u002F\u002F .just() создает Observable, испускающий одно значение\n    .zipWith(new Observable.just(2), (one, two) =\u003E one + two)\n    .listen(print); \u002F\u002F печатает 3\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EБолее практичное применение — если вам нужно дождаться двух асинхронных функций, которые возвращают \u003Ccode\u003EFuture\u003C\u002Fcode\u003E, и вы хотите обработать данные, как только будут возвращены оба результата. В этом слегка надуманном примере мы представляем два REST API: один возвращает \u003Ccode\u003EUser\u003C\u002Fcode\u003E, другой — \u003Ccode\u003EProduct\u003C\u002Fcode\u003E в виде строк JSON, и мы хотим дождаться обоих вызовов, прежде чем вернуть объект \u003Ccode\u003EInvoice\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Eclass Invoice {\n  final User user;\n  final Product product;\n\n  Invoice(this.user, this.product);\n\n  printInvoice() {\n    print(user.toString());\n    print(product.toString());\n  }\n}\n\n\u002F\u002F Симуляция HTTP вызова, возвращающего Product, как JSON\nFuture&lt;String\u003E getProduct() async {\n  print(\"Started getting product\");\n  await Future.delayed(Duration(seconds: 2));\n  print(\"Finished getting product\");\n  return '{\"name\": \"Flux compensator\", \"price\": 99999.99}';\n}\n\n\u002F\u002F Симуляция HTTP вызова, возвращающего User, как JSON\nFuture&lt;String\u003E getUser() async {\n  print(\"Started getting User\");\n  await Future.delayed(Duration(seconds: 4));\n  print(\"Finished getting User\");\n  return '{\"name\": \"Jon Doe\", \"adress\": \"New York\", \"phoneNumber\":\"424242\",\"age\": 42 }';\n}\n\nvoid main() {\n  test('zipWith', () async {\n    var userObservable =\n        Observable.fromFuture(getUser()).map&lt;User\u003E((jsonString) =\u003E User.fromJson(jsonString));\n\n    var productObservable = Observable.fromFuture(getProduct())\n        .map&lt;Product\u003E((jsonString) =\u003E Product.fromJson(jsonString));\n\n    Observable&lt;Invoice\u003E invoiceObservable = userObservable.zipWith&lt;Product, Invoice\u003E(\n        productObservable, (user, product) =\u003E Invoice(user, product));\n\n    print(\"Start listening for invoices\");\n    invoiceObservable.listen((invoice) =\u003E invoice.printInvoice());\n\n    \u002F\u002F предотвращает раннее завершение теста в целях тестирования\n    await Future.delayed(Duration(seconds: 5));\n  });\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EГлядя на вывод, вы можете увидеть, как это выполняется асинхронно\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003EStarted getting User\nStarted getting product\nStart listening for invoices\nFinished getting product\nFinished getting User\nJon Doe - New York - 424242 - 42\nFlux compensator - 99999.99\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"combinelatest\"\u003ECombineLatest\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ccode\u003EcombineLatest\u003C\u002Fcode\u003E тоже объединяет значения потоков, но немного по-другому, чем \u003Ccode\u003Emerge\u003C\u002Fcode\u003E и \u003Ccode\u003Ezip\u003C\u002Fcode\u003E. Он прослушивает большее количество потоков и выдает объединенное значение всякий раз, когда приходит новое значение из одного из потоков. Интересно то, что он генерирует не только измененное значение, но и последние полученные значения всех других исходных потоков. Посмотрите внимательно на эту анимацию:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"image\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F633\u002Facb\u002Fbee\u002F633acbbee01158bb7a6ad0450d39f712.gif\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДо того, как \u003Ccode\u003EcombineLates\u003C\u002Fcode\u003E выдаст свое первое значение, все исходные потоки должны получить на вход хотя бы один элемент.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ отличие от методов, которые использовались ранее, \u003Ccode\u003EcombineLatest\u003C\u002Fcode\u003E — является статическим. Кроме того, поскольку Dart не допускает перегрузки операторов, существуют версии \u003Ccode\u003EcombLastest\u003C\u002Fcode\u003E в зависимости от количества исходных потоков: \u003Cstrong\u003EcombineLatest2...combineLatest9\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EХорошее применение \u003Ccode\u003EcombineLatest\u003C\u002Fcode\u003E, например, если у вас есть два \u003Ccode\u003EObservable&lt;bool\u003E\u003C\u002Fcode\u003E, которые сигнализируют о том, что некоторые части вашего приложения заняты, и вы хотите отобразить спиннер \"Занято\", если один из них занят. Это может выглядеть следующим образом (псевдокод):\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Eclass Model {\n  Observable&lt;bool\u003E get isBusy =\u003E \n    Observable.combineLatest2(isBusyOne,isBusyTwo, (b1, b2) =\u003E b1 || b2);\n\n  PublishSubject&lt;bool\u003E isBusyOne;\n  PublishSubject&lt;bool\u003E isBusyTwo;\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ вашем UI вы можете использовать \u003Ccode\u003EisBusy\u003C\u002Fcode\u003E с \u003Ccode\u003EStreamBuilder\u003C\u002Fcode\u003E для отображения \u003Ccode\u003ESpinner\u003C\u002Fcode\u003E, если полученное значение истинно.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Ccode\u003EcombineLatest\u003C\u002Fcode\u003E очень подходящая функция в комбинации с потоками \u003Cstrong\u003EFireStore snapshots\u003C\u002Fstrong\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПредставьте, что вы хотите создать приложение, которое отображает новостную ленту вместе с прогнозом погоды. Сообщения тикеров и данные о погоде хранятся в двух разных коллекциях FireStore. Оба обновляются независимо. Вы хотите отобразить обновления данных с помощью StreamBuilder. С \u003Ccode\u003EcombineLatest\u003C\u002Fcode\u003E это легко:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Eclass WeatherForecast {\n  final String forecastText;\n  final GeoPoint location;\n\n  factory WeatherForecast.fromMap(Map&lt;String, dynamic\u003E map) {\n    return WeatherForecast(map['forecastText'], map['location']);\n  }\n\n  WeatherForecast(this.forecastText, this.location);\n}\n\nclass NewsMessage {\n  final String newsText;\n  final GeoPoint location;\n\n  factory NewsMessage.fromMap(Map&lt;String, dynamic\u003E map) {\n    return NewsMessage(map['newsText'], map['location']);\n  }\n\n  NewsMessage(this.newsText, this.location);\n}\n\nclass CombinedMessage {\n  final WeatherForecast forecast;\n  final NewsMessage newsMessage;\n\n  CombinedMessage(this.forecast, this.newsMessage);\n}\n\nclass Model {\n  CollectionReference weatherCollection;\n  CollectionReference newsCollection;\n\n  Model() {\n    weatherCollection = Firestore.instance.collection('weather');\n    newsCollection = Firestore.instance.collection('news');\n  }\n\n  Observable&lt;CombinedMessage\u003E getCombinedMessages() {\n    Observable&lt;WeatherForecast\u003E weatherForecasts = weatherCollection\n        .snapshots()\n        .expand((snapShot) =\u003E snapShot.documents)\n        .map&lt;WeatherForecast\u003E((document) =\u003E WeatherForecast.fromMap(document.data));\n\n    Observable&lt;NewsMessage\u003E news = newsCollection\n        .snapshots()\n        .expand((snapShot) =\u003E snapShot.documents)\n        .map&lt;NewsMessage\u003E((document) =\u003E NewsMessage.fromMap(document.data));\n\n    return Observable.combineLatest2(\n        weatherForecasts, news, (weather, news) =\u003E CombinedMessage(weather, news));\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ вашем UI это выглядело бы как-то так: \u003Ccode\u003EStreamBuilder&lt;CombinedMessage\u003E(stream: model.getCombinedMessages(),...).\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"distinct\"\u003EDistinct\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ описанном выше сценарии может случиться, что \u003Cstrong\u003EisBusyOne\u003C\u002Fstrong\u003E и \u003Cstrong\u003EisBusyTwo\u003C\u002Fstrong\u003E выдают одно и то же значение, что приведет к обновлению пользовательского интерфейса с теми же данными. Чтобы предотвратить это, мы можем использовать \u003Ccode\u003E.distinct()\u003C\u002Fcode\u003E. Он гарантирует, что данные передаются по потоку только в том случае, если значение нового элемента отличается от последнего. Таким образом, мы изменили бы код на:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E  Observable&lt;bool\u003E isBusy =\u003E isBusyOne.mergeWith([isBusyTwo]).distinct();\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003Eи это также демонстрирует, что мы можем комбинировать наши функции в различные цепочки по желанию.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"asyncmap\"\u003EAsyncMap\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПомимо \u003Ccode\u003Emap()\u003C\u002Fcode\u003E есть также функция \u003Ccode\u003EasyncMap\u003C\u002Fcode\u003E, которая позволяет использовать асинхронную функцию в качестве map-функции. Давайте представим немного другую настройку для нашего примера FireStore. Теперь необходимый \u003Cstrong\u003EWeatherForecast\u003C\u002Fstrong\u003E зависит от местоположения \u003Cstrong\u003ENewsMessage\u003C\u002Fstrong\u003E и должен обновляться только при получении нового \u003Cstrong\u003ENewsMessage\u003C\u002Fstrong\u003E:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003EObservable&lt;CombinedMessage\u003E getDependendMessages() {\n\n  Observable&lt;NewsMessage\u003E news = newsCollection.snapshots().expand((snapShot) {\n    return snapShot.documents;\n  }).map&lt;NewsMessage\u003E((document) {\n    return NewsMessage.fromMap(document.data);\n  });\n\n  return news.asyncMap((newsEntry) async {\n    var weatherDocuments =\n        await weatherCollection.where('location', isEqualTo: newsEntry.location).getDocuments();\n    return new CombinedMessage(\n        WeatherForecast.fromMap(weatherDocuments.documents.first.data), newsEntry);\n  });\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EObservable, возвращаемый getDependendMessages, будет генерировать новое CombinedMessage каждый раз, когда изменяется newsCollection.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"otladka-observables\"\u003EОтладка Observables\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EГлядя на элегантные цепочки вызовов Rx кажется, что почти невозможно отладить выражение вроде этого:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003EObservable&lt;NewsMessage\u003E news = newsCollection\n    .snapshots()\n    .expand((snapShot) =\u003E snapShot.documents)\n    .map&lt;NewsMessage\u003E((document) =\u003E NewsMessage.fromMap(document.data));\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНо имейте в виду, что \u003Ccode\u003E=\u003E\u003C\u002Fcode\u003E — это только краткая форма для анонимной функции. Используя \u003Cstrong\u003EConvert to block body\u003C\u002Fstrong\u003E, вы получите:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003EObservable&lt;NewsMessage\u003E news = newsCollection\n        .snapshots()\n        .expand((snapShot) {\n          return snapShot.documents;\n        })\n        .map&lt;NewsMessage\u003E((document) {\n          return NewsMessage.fromMap(document.data);\n        });\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИ теперь мы можем установить точку останова или добавить операторы печати на каждом этапе нашего \"конвейера\".\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"osteregaytes-pobochnyh-effektov\"\u003EОстерегайтесь побочных эффектов\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cstrong\u003EЕсли вы хотите извлечь выгоду из Rx, чтобы сделать ваш код более надежным, всегда держите в голове, что Rx — это преобразование данных при их перемещении \"по конвейерной ленте\". Поэтому никогда не вызывайте функции, которые изменяют какие-либо переменные\u002Fсостояния вне конвейера обработки, пока вы не достигнете функции .listen. \u003C\u002Fstrong\u003E\u003Cbr\u002F\u003E\r\nВместо того, чтобы делать так:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003EObservable.fromFuture(getProduct())\n        .map&lt;Product\u003E((jsonString) { \n     var product = Product.fromJson(jsonString);\n    database.save(product);\n    setState((){ _product =  product });\n    return product;\n}).listen();\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003Eделайте так:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003EObservable.fromFuture(getProduct())\n        .map&lt;Product\u003E((jsonString) =\u003E Product.fromJson(jsonString))\n        .listen( (product) {\n          database.save(product);  \n          setState((){ _product =  product });\n        });\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EОбязанность \u003Ccode\u003Emap()\u003C\u002Fcode\u003E — преобразование данных в потоке, И НИЧЕГО БОЛЬШЕ! Если переданная функция отображения делает что-то еще, это будет рассматриваться как побочный эффект, плодящий потенциальные ошибки, который трудно обнаружить при чтении кода.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"nekotorye-mysli-ob-osvobozhdenii-resursov\"\u003EНекоторые мысли об освобождении ресурсов\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЧтобы избежать утечек памяти, всегда вызывайте \u003Ccode\u003Ecancel()\u003C\u002Fcode\u003E для подписок, \u003Ccode\u003Edispose()\u003C\u002Fcode\u003E для StreamControllers, \u003Ccode\u003Eclose()\u003C\u002Fcode\u003E для Subjects, как только они вам больше не нужны.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"zaklyuchenie\"\u003EЗаключение\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПоздравляю, если вы остались со мной до этого момента. Теперь вы не только можете использовать Rx, чтобы облегчить свою жизнь, но и подготовиться к следующим постам, в которых мы углубимся в детали \u003Cstrong\u003ERxVMS\u003C\u002Fstrong\u003E.\u003C\u002Fp\u003E\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"flutter"},{"titleHtml":"dart"},{"titleHtml":"практика программирования"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F451292\u002F9e4e234cf01bea40e117e80de64de480\u002F","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F451292\u002F9e4e234cf01bea40e117e80de64de480\u002F?format=vk","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F451292\\\u002F\"},\"headline\":\"RxDart: магические трансформации потоков\",\"datePublished\":\"2019-05-11T10:15:25+03:00\",\"dateModified\":\"2019-05-12T10:14:04+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"Валерий\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"Добро пожаловать &mdash; это третья часть моей серии статей об архитектуре Flutter.  Введение   Основы Dart Streams RxDart: магические трансформации потоков (этот пост...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F451292\\\u002F#post-content-body\",\"about\":[\"h_dart\",\"h_flutter\",\"f_develop\"],\"image\":[\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002Fea5\\\u002Fdfe\\\u002F1c6\\\u002Fea5dfe1c65f93367e3207e2a0fe68908.gif\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F8e0\\\u002F05a\\\u002Fecc\\\u002F8e005aecc11e119b7c856a4cadec9b11.gif\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F0bb\\\u002F73f\\\u002F2a2\\\u002F0bb73f2a2ccb82e6a920efbf2c395b0d.gif\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002Fe8e\\\u002F8d7\\\u002F2b3\\\u002Fe8e8d72b36dddd0d3469107c6cdae2b1.gif\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002Fa2f\\\u002F9ba\\\u002F82b\\\u002Fa2f9ba82b88b555841c21dc623c3d298.gif\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F5ef\\\u002F611\\\u002F847\\\u002F5ef611847db6bfa40237fb3622d93822.gif\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F633\\\u002Facb\\\u002Fbee\\\u002F633acbbee01158bb7a6ad0450d39f712.gif\"]}","metaDescription":"Добро пожаловать — это третья часть моей серии статей об архитектуре Flutter.\r\n\r\nВведение  \r\nОсновы Dart Streams\r\nRxDart: магические трансформации потоков (этот пост)\r\nОсновы RxVMS: RxCommand и...","mainImageUrl":null,"amp":false},"polls":[],"commentsEnabled":true,"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":false}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[],"hubs":"dart,flutter"},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{}},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"dfp":{"slotsDict":{}},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.c0af73e7.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
</body>
</html>
