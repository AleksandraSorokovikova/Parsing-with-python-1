<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <title>RESTinio — это асинхронный HTTP-сервер. Асинхронный / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.c0af73e7.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.85eb77f0b17c8235e7b64b9f81ea5ec2.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" src="/js/ads.js" onload="window['zhY4i4nJ9K'] = true" data-vmid="checkad"></script><script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/post\/451728\/"},"headline":"RESTinio — это асинхронный HTTP-сервер. Асинхронный","datePublished":"2019-05-14T15:08:16+03:00","dateModified":"2019-05-15T17:50:24+03:00","author":{"@type":"Person","name":"Евгений Охотников"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"Пару лет назад мы опубликовали RESTinio &mdash; свой небольшой OpenSource C++фреймворк для встраивания HTTP-сервера в C++ приложения. Мегапопулярным за это время RESTi...","url":"https:\/\/habr.com\/ru\/post\/451728\/#post-content-body","about":["h_open_source","h_programming","h_cpp","f_develop"],"image":["https:\/\/habr.com\/share\/publication\/451728\/0928096eb0c565c935aa0ef65160d156\/"]}</script>
  <script src="//www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.49.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_eng"><meta data-vue-meta="ssr" property="og:title" content="RESTinio — это асинхронный HTTP-сервер. Асинхронный" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="RESTinio — это асинхронный HTTP-сервер. Асинхронный" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="RESTinio — это асинхронный HTTP-сервер. Асинхронный" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="Пару лет назад мы опубликовали RESTinio — свой небольшой OpenSource C++фреймворк для встраивания HTTP-сервера в C++ приложения. Мегапопулярным за это время RESTinio не стал, но и не потерялся. Кто-то..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="Пару лет назад мы опубликовали RESTinio — свой небольшой OpenSource C++фреймворк для встраивания HTTP-сервера в C++ приложения. Мегапопулярным за это время RESTinio не стал, но и не потерялся. Кто-то..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="Пару лет назад мы опубликовали RESTinio — свой небольшой OpenSource C++фреймворк для встраивания HTTP-сервера в C++ приложения. Мегапопулярным за это время RESTinio не стал, но и не потерялся. Кто-то..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="Пару лет назад мы опубликовали RESTinio — свой небольшой OpenSource C++фреймворк для встраивания HTTP-сервера в C++ приложения. Мегапопулярным за это время RESTinio не стал, но и не потерялся. Кто-то..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="Пару лет назад мы опубликовали RESTinio — свой небольшой OpenSource C++фреймворк для встраивания HTTP-сервера в C++ приложения. Мегапопулярным за это время RESTinio не стал, но и не потерялся. Кто-то..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habr.com/share/publication/451728/0928096eb0c565c935aa0ef65160d156/" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habr.com/share/publication/451728/0928096eb0c565c935aa0ef65160d156/" data-vmid="og:image"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habr.com/share/publication/451728/0928096eb0c565c935aa0ef65160d156/" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habr.com/share/publication/451728/0928096eb0c565c935aa0ef65160d156/" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habr.com/share/publication/451728/0928096eb0c565c935aa0ef65160d156/" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="451728" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2019-05-14T12:08:16.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/451728/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="https://habr.com/ru/post/451728/" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habr.com/share/publication/451728/0928096eb0c565c935aa0ef65160d156/" data-vmid="image:href">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="/ru/sandbox/start/" class="tm-header__become-author-btn">
            Как стать автором
          </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="/ru/all/" class="tm-main-menu__item">
        Все потоки
      </a> <a href="/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" data-async-called="true" class="tm-page"><div class="tm-page-width"><!----> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="/ru/users/eao197/" title="eao197" class="tm-user-info__userpic"><div class="tm-entity-image"><svg height="24" width="24" class="tm-svg-img tm-image-placeholder tm-image-placeholder_lilac"><!----> <use xlink:href="/img/megazord-v24.ce74655c.svg#placeholder-user"></use></svg></div></a> <span class="tm-user-info__user"><a href="/ru/users/eao197/" class="tm-user-info__username">
      eao197
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2019-05-14T12:08:16.000Z" title="2019-05-14, 15:08">14  мая  2019 в 15:08</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>RESTinio — это асинхронный HTTP-сервер. Асинхронный</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/open_source/" class="tm-article-snippet__hubs-item-link"><span>Open source</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/programming/" class="tm-article-snippet__hubs-item-link"><span>Программирование</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/cpp/" class="tm-article-snippet__hubs-item-link"><span>C++</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span></div> <!----> <!----> <!----></div></div> <!----> <div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-1"><div xmlns="http://www.w3.org/1999/xhtml"><p>Пару лет назад мы опубликовали <a href="https://bitbucket.org/sobjectizerteam/restinio-0.4">RESTinio</a> — свой небольшой OpenSource C++фреймворк для встраивания HTTP-сервера в C++ приложения. Мегапопулярным за это время RESTinio не стал, но и <a href="https://www.reddit.com/r/cpp/comments/auvvf5/restful_style_apis_in_c/ehb7b7f/">не потерялся</a>. Кто-то выбирает его за "родную" поддержку Windows, кто-то за какие-то отдельные фичи (вроде поддержки sendfile), кто-то за соотношение возможностей, простоты использования и настраиваемости. Но, думаю, изначально многих RESTinio привлекает вот этим лаконичным "Hello, World"-ом:</p><br/>
<pre><code class="cpp">#include &lt;restinio/all.hpp>
int main()
{
    restinio::run(
        restinio::on_this_thread()
        .port(8080)
        .address("localhost")
        .request_handler([](auto req) {
            return req->create_response().set_body("Hello, World!").done();
        }));
    return 0;
}</code></pre><br/>
<p>Это, действительно, все, что нужно чтобы запустить HTTP-сервер внутри C++ приложения.</p><br/>
<p>И хотя мы всегда стараемся говорить, что ключевой фичей, ради которой мы вообще занялись RESTinio, была асинхронная обработка входящих запросов, все равно периодически сталкиваемся с вопросами о том, как быть, если внутри request_handler-а приходится выполнять длительные операции.</p><br/>
<p>А раз такой вопрос актуален, то можно еще раз о нем поговорить и привести парочку небольших примеров.</p><a name="habracut"></a><br/>
<h1 id="nebolshaya-otsylka-k-istokam">Небольшая отсылка к истокам</h1><br/>
<p>Мы решили сделать свой встраиваемый HTTP-сервер после того, как несколько раз подряд столкнулись с очень похожими задачами: нужно было организовать HTTP-вход для уже существующего C++ приложения или нужно было написать микросервис, в котором требовалось переиспользовать уже существующий "тяжелый" C++ный код. Общей чертой у этих задач было то, что прикладная обработка запроса могла растянуться на десятки секунд.</p><br/>
<p>Грубо говоря, HTTP-сервер за миллисекунду разбирался с новым HTTP-запросом, но для выдачи HTTP-ответа требовалось обратиться к каким-то другим сервисам или же провести какие-то длительные вычисления. Если выполнять обработку HTTP-запросов в синхронном режиме, то HTTP-серверу потребуется пул из тысяч рабочих нитей, что вряд ли можно считать хорошей идеей даже в современных условиях.</p><br/>
<p>Гораздо удобнее, когда HTTP-сервер сможет работать всего на одной рабочей нити, на которой выполняется ввод/вывод и вызываются обработчики запросов. Обработчик запроса просто делегирует реальную обработку какой-то другой рабочей нити и возвращает управление HTTP-серверу. Когда, сильно позже, где-то на другой рабочей нити будет готова информация для ответа на запрос, просто формируется HTTP-ответ, который автоматически подхватывает HTTP-сервер и отсылает этот ответ соответствующему клиенту.</p><br/>
<p>Поскольку мы так и не нашли удовлетворяющего нас готового варианта, который был бы прост и удобен в использовании, был кроссплатформенным и поддерживал бы Windows как "родную" платформу, обеспечивал бы более-менее приличную производительность, и, главное, был бы заточен именно под асинхронную работу, то в начале 2017 года занялись разработкой RESTinio.</p><br/>
<p>Мы хотели сделать асинхронный встраиваемый HTTP-сервер, простой в использовании, освобождающий пользователя от каких-то рутинных забот, при этом более-менее производительный, кроссплатформенный и допускающий гибкую настройку под разные условия. Вроде бы получилось, но об этом предоставим судить пользователям...</p><br/>
<h1 id="itak-est-vhodyaschiy-zapros-trebuyuschiy-mnogo-vremeni-na-obrabotku-chto-delat">Итак, есть входящий запрос, требующий много времени на обработку. Что делать?</h1><br/>
<h2 id="rabochie-niti-restinioasio">Рабочие нити RESTinio/Asio</h2><br/>
<p>Иногда пользователи RESTinio не задумываются о том, какие рабочие нити и как именно использует RESTinio. Например, кто-то может посчитать, что когда RESTinio запускается на одной рабочей нити (посредством <code>run(on_this_thread(...))</code>, как в примере выше), то на этой рабочей нити RESTinio только вызывает обработчики запросов. Тогда как для операций ввода-вывода RESTinio "под капотом" создает отдельную нить. И эта отдельная нить продолжает обслуживать новые подключения когда основная рабочая нить занята request_handler-ом.</p><br/>
<p>На самом деле все нити, которые пользователь выделяет RESTinio, используются и для выполнения операций ввода-вывода, и для вызова request_handler-ов. Поэтому, если вы запустили RESTinio-сервер через <code>run(on_this_thread(...))</code>, то внутри <code>run()</code> на текущей нити будут выполняться и операции ввода-вывода, и обработчики запросов.</p><br/>
<p>Грубо говоря, RESTinio запускает Asio-шный event-loop, внутри которого выполняется обработка новых подключений, чтение и парсинг данных из уже существующих подключений, запись готовых для отсылки данных, обработка закрытия соединений и т.п. Среди прочего, после того, как из очередного подключения вычитан и полностью разобран входящий запрос, для обработки этого запроса вызывается заданный пользователем request_handler.</p><br/>
<p>Соответственно, если request_handler блокирует работу текущей нити, то блокируется и работающий на этой же нити Asio-шный event-loop. Все просто.</p><br/>
<p>Если RESTinio запускается на пуле рабочих нитей (т.е. посредством <code>run(on_thread_pool(...))</code>, как <a href="https://bitbucket.org/sobjectizerteam/restinio-0.4/src/v.0.4.9/dev/sample/hello_world_delayed/main.cpp">вот в этом примере</a>), то происходит практически тоже самое: на каждой нити из пула запускается Asio-шный event-loop. Поэтому если какой-то request_handler начнет перемножать большие матрицы, то это заблокирует рабочую нить в пуле и на этой нити перестанут обслуживаться операции ввода-вывода.</p><br/>
<p>Поэтому при использовании RESTinio задача разработчика в том, чтобы его request_handler-ы завершались за разумное и, желательно, не очень большое время.</p><br/>
<h2 id="nuzhen-li-vam-pul-rabochih-potokov-dlya-restinioasio">Нужен ли вам пул рабочих потоков для RESTinio/Asio?</h2><br/>
<p>Итак, когда заданный пользователем request_handler блокирует длительной операций рабочую нить, на которой он вызван, то эта нить теряет возможность обрабатывать операции ввода-вывода. Но что делать, если request_handler-у нужно много времени для формирования ответа? Допустим, он делает какую-то тяжелую вычислительную операцию, время которой в принципе нельзя ужать до нескольких миллисекунд?</p><br/>
<p>Кто-то из пользователей может подумать, что раз RESTinio может работать на пуле рабочих нитей, то достаточно указать размер пула побольше и все.</p><br/>
<p>К сожалению, это будет работать лишь в простых случаях, когда у вас немного параллельных подключений. Да и интенсивность запросов невысока. Если же счет параллельных запросов идет на тысячи (да хотя бы всего лишь на несколько сотен), то легко получить ситуацию, когда все рабочие нити пула будут заняты обработкой уже принятых запросов. А для выполнения операций ввода-вывода нитей уже не останется. В результате чего сервер потеряет "отзывчивость". В том числе RESTinio потеряет возможность обрабатывать тайм-ауты, которые RESTinio автоматически отсчитывает при приеме новых подключений и при обработке запросов.</p><br/>
<p>Поэтому, если для обслуживания входящих запросов вам требуется выполнять длительные блокирующие операции, то лучше выделить для RESTinio всего одну рабочую нить, а вот большой пул рабочих потоков отрядить для выполнения этих самых операций. Обработчик запроса будет всего лишь класть очередной запрос в какую-то очередь, откуда запрос будет извлекаться и отдаваться на обработку.</p><br/>
<p>Пример этой схемы мы подробно рассматривали когда рассказывали о своем <a href="https://stiffstream.com/en/docs/shrimp-demo.html">демо-проекте Shrimp</a> вот в этой статье: "<a href="https://habr.com/post/416387/">Shrimp: масштабируем и раздаем по HTTP картинки на современном C++ посредством ImageMagic++, SObjectizer и RESTinio</a>".</p><br/>
<h2 id="primery-delegirovaniya-obrabotki-zaprosov-na-otdelnye-rabochie-niti">Примеры делегирования обработки запросов на отдельные рабочие нити</h2><br/>
<p>Выше я попытался объяснить, почему не стоит выполнять длительную обработку прямо внутри request_handler-а. Откуда проистекает очевидное следствие: длительная обработка запроса должна быть делегирована каким-то другим рабочим нитям. Давайте посмотрим на то, как это может выглядеть.</p><br/>
<p>В двух примерах ниже нам потребуется единственная рабочая нить для запуска RESTinio и еще одна рабочая нить для имитации длительной обработки запросов. А также нам потребуется какая-то очередь сообщений для передачи запросов от нити RESTinio к отдельной рабочей нити.</p><br/>
<p>Делать новую реализацию thread-safe message queue на коленке для этих двух примеров мне было не с руки, поэтому я воспользовался родным для меня SObjectizer-ом и его mchain-ами, которые суть CSP-шные каналы. Подробнее про mchain-ы можно прочитать здесь: "<a href="https://habr.com/post/358120/">Обмен информацией между рабочими нитям без боли? CSP-шные каналы нам в помощь</a>".</p><br/>
<h3 id="sohranenie-obekta-request_handle">Сохранение объекта request_handle</h3><br/>
<p>Базовый прием, на котором строится делегирование обработки запросов, — это передача куда-то объекта <code>request_handle_t</code>.</p><br/>
<p>Когда RESTinio для обработки входящего запроса вызывает заданный пользователем request_handler, в этот request_handler передается объект типа <code>request_handle_t</code>. Данный тип является ни чем иным, как умным указателем на параметры полученного запроса. Так что если кому-то удобно думать, что <code>request_handle_t</code> — это <code>shared_ptr</code>, то смело можно так думать. Это <code>shared_ptr</code> и есть.</p><br/>
<p>А раз <code>request_handle_t</code> — это <code>shared_ptr</code>, то мы можем смело этот умный указатель куда-то передать. Что мы и будем делать в показанных ниже примерах.</p><br/>
<p>Итак, нам потребуется отдельная рабочая нить и канал для связи с ней. Создадим это все:</p><br/>
<pre><code class="cpp">int main()
{
    // Запускаем SObjectizer.
    so_5::wrapped_env_t sobj;

    // Объект std::thread для нити обработки запросов.
    std::thread processing_thread;
    // При выходе из main для этой нити нужно вызвать join.
    // Делаем это через RAII.
    auto processing_thread_joiner = so_5::auto_join(processing_thread);

    // Канал для передачи запросов на обработку.
    auto req_ch = so_5::create_mchain(sobj);
    // Канал нужно закрыть при выходе из main.
    // Делаем это через RAII.
    auto ch_closer = so_5::auto_close_drop_content(req_ch);

    // Теперь можем запустить отдельную нить.
    // Если далее произойдет выход из main() по какой-то причине,
    // то канал принудительно будет закрыт, а для нити будет вызван join().
    processing_thread = std::thread{
            processing_thread_func, req_ch
    };</code></pre><br/>
<p>Тело самой рабочей нити находится внутри функции <code>processing_thread_func()</code>, которую мы рассмотрим чуть позже.</p><br/>
<p>Сейчас у нас уже есть отдельная рабочая нить и канал для связи с ней. Можно запустить RESTinio-сервер:</p><br/>
<pre><code class="cpp">    // Свойства, которыми должен обладать наш сервер.
    struct traits_t : public restinio::default_traits_t
    {
        using logger_t = restinio::shared_ostream_logger_t;
    };

    restinio::run(
        restinio::on_this_thread&lt;traits_t>()
            .port(8080)
            .address("localhost")
            .request_handler([req_ch](auto req) {
                // Обрабатываем только GET-запросы для корневого каталога.
                if(restinio::http_method_t::http_get == req->header().method() &amp;&amp;
                        "/" == req->header().path())
                {
                    // Делегируем обработку отдельной нити.
                    so_5::send&lt;handle_request>(req_ch, req);
                    return restinio::request_accepted();
                }
                else
                    return restinio::request_rejected();
            })
            .cleanup_func([&amp;] {
                // Закрываем канал запросов для отдельной нити.
                // Лучше сделать это вручную, т.к. внутри req_ch
                // могут быть ждущие своей очереди запросы и их следует
                // уничтожить пока сервер еще существует.
                so_5::close_drop_content(req_ch);
            }));</code></pre><br/>
<p>Логика у этого сервера очень простая. Если пришел GET-запрос для '/', то мы делегируем обработку запроса отдельной нити. Для этого выполняем две важных операции:</p><br/>
<ul>
<li>отсылаем объект <code>request_handle_t</code> в CSP-шный канал. Пока этот объект хранится внутри CSP-шного канала или где-то еще, то RESTinio знает, что запрос еще жив;</li>
<li>возвращаем значение <code>restinio::request_accepted()</code> из обработчика запроса. Это дает RESTinio понять, что запрос принят к обработке и нельзя закрывать соединение с клиентом.</li>
</ul><br/>
<p>Тот факт, что request_handler сразу не сформировал ответ RESTinio нисколько не смущает. Раз вернули <code>restinio::request_accepted()</code>, значит пользователь взял на себя ответственность за обработку запроса и когда-нибудь ответ на запрос будет сформирован.</p><br/>
<p>Если же обработчик запроса вернул <code>restinio::request_rejected()</code>, то RESTinio понимает, что запрос обработан не будет и вернет клиенту ошибку 501.</p><br/>
<p>Итак, зафиксируем предварительный итог: экземпляр <code>request_handle_t</code> может быть передан куда-то, поскольку это, по сути, <code>std::shared_ptr</code>. Пока этот экземпляр жив, RESTinio считает, что запрос находится в обработке. Если обработчик запроса возвратил <code>restinio::request_accepted()</code>, то RESTinio не будет волноваться о том, что ответ на запрос не был сформирован вот прямо сейчас.</p><br/>
<p>Теперь мы можем посмотреть на реализацию этой самой отдельной нити:</p><br/>
<pre><code class="cpp">void processing_thread_func(so_5::mchain_t req_ch)
{
    // Генератор случайных чисел для определения задержки
    // при имитации обработки запроса.
    std::random_device rd;
    std::mt19937 generator{rd()};
    std::uniform_int_distribution&lt;> pause_generator{350, 3500};

    // Отдельный канал для отложенных сообщений timeout_elapsed.
    auto delayed_ch = so_5::create_mchain(req_ch->environment());

    // Выставляем этот флаг если какой-то канал закрывается.
    bool stop = false;
    select(
        so_5::from_all()
            // Реакция на закрытие любого из каналов.
            .on_close([&amp;stop](const auto &amp;) { stop = true; })
            // Предикат для выхода из select().
            // Завершаем select() как только канал оказывается закрыт.
            .stop_on([&amp;stop]{ return stop; }),

        // Читаем сообщения handle_request из канала общения с RESTinio.
        case_(req_ch,
            [&amp;](handle_request cmd) {
                // Случайная задержка для обработки запроса.
                const std::chrono::milliseconds pause{pause_generator(generator)};

                // Отсылаем самим себе отложенное сообщение.
                so_5::send_delayed&lt;timeout_elapsed>(delayed_ch,
                        // Это задержка для timeout_elapsed.
                        pause,
                        // Все остальное идет в конструктор timeout_elapsed.
                        cmd.m_req,
                        pause);
            }),

        // Читаем сообщения timeout_elapsed.
        case_(delayed_ch,
            [](timeout_elapsed cmd) {
                // Формируем актуальный ответ на запрос.
                cmd.m_req->create_response()
                        .set_body("Hello, World! (pause:"
                                + std::to_string(cmd.m_pause.count())
                                + "ms)")
                        .done();
            })
    );
}</code></pre><br/>
<p>Здесь очень простая логика: мы получаем исходный запрос в виде сообщения <code>handle_request</code> и пересылаем его сами себе в виде отложенного на некоторое случайное время сообщения <code>timeout_elapsed</code>. Реальную обработку запроса делаем лишь при получении <code>timeout_elapsed</code>.</p><br/>
<p><strong>Upd.</strong> Когда на отдельной рабочей нити вызывается метод <code>done()</code>, то RESTinio уведомляется о том, что появился готовый ответ, который нужно записать в TCP-соединение. RESTinio инициирует операцию записи, но сама I/O-операция будет выполнена не там, где вызван <code>done()</code>, а там, где RESTinio выполняет ввод-вывод и вызывает request_handler-ы. Т.е. в данном примере <code>done()</code> вызывается на отдельной рабочей нити, а операция записи будет выполнена на основной нити, там, где работает <code>restinio::run()</code>.</p><br/>
<p>Сами упомянутые сообщения имеют следующий вид:</p><br/>
<pre><code class="cpp">struct handle_request
{
    restinio::request_handle_t m_req;
};

struct timeout_elapsed
{
    restinio::request_handle_t m_req;
    std::chrono::milliseconds m_pause;
};</code></pre><br/>
<p>Т.е. отдельная рабочая нить берет <code>request_handle_t</code> и сохраняет его до того времени, пока не появится возможность сформировать полный ответ. А когда такая возможность появляется, у сохраненного объекта-запроса вызывается <code>create_response()</code> и ответ отдается RESTinio. После чего RESTinio уже на своем рабочем контексте записывает ответ в соединение с соответствующим клиентом.</p><br/>
<p>Здесь экземпляр <code>request_handle_t</code> хранится в отложенном сообщении <code>timeout_elapsed</code>, поскольку никакой реальной обработки в этом примитивном примере нет. В реальном приложении <code>request_handle_t</code> может храниться в какой-то очереди или внутри какого-то объекта, созданного для обработки запроса.</p><br/>
<p>Полный код этого примера можно найти <a href="https://bitbucket.org/sobjectizerteam/restinio-0.4/src/v.0.4.9/dev/sample/async_handling_with_sobjectizer/main.cpp">среди штатных примеров RESTinio</a>.</p><br/>
<h4 id="neskolko-nebolshih-poyasneniy-po-kodu">Несколько небольших пояснений по коду</h4><br/>
<p>Вот эта конструкция задает RESTinio свойства, которыми должен обладать RESTinio-сервер:</p><br/>
<pre><code class="cpp">    // Свойства, которыми должен обладать наш сервер.
    struct traits_t : public restinio::default_traits_t
    {
        using logger_t = restinio::shared_ostream_logger_t;
    };

    restinio::run(
        restinio::on_this_thread&lt;traits_t>()</code></pre><br/>
<p>Для данного примера мне нужно, чтобы RESTinio логировал свои действия по обработке запросов. Поэтому я задаю <code>logger_t</code>, отличный от используемого по умолчанию <code>null_logger_t</code>. Но т.к. RESTinio будет работать, фактически, на нескольких нитях (входящие запросы RESTinio обрабатывает на основной нити, а вот ответы к нему приходят с отдельной рабочей нити), то нужен thread-safe logger, коим и является <code>shared_ostream_logger_t</code>.</p><br/>
<p>Внутри <code>processing_thread_func()</code> используется SObjectizer-овская функция <code>select()</code>, в чем-то аналогичная Go-шной конструкции select: можно читать и обрабатывать сообщения сразу из нескольких каналов. Функция <code>select()</code> работает до тех пор, пока не будут закрыты все переданные ей каналы. Или пока ей принудительно не скажут, что пора завершаться.</p><br/>
<p>При этом если закрывается канал для связи с RESTinio-сервером, то продолжать работу смысла нет. Поэтому в <code>select()</code> определяется реакция на закрытие любого из каналов: как только какой-то канал закрывается, взводится флаг stop. А это приведет к завершению работы <code>select()</code> и выходу из <code>processing_thread_func()</code>.</p><br/>
<h3 id="sohranenie-obekta-response_builder">Сохранение объекта response_builder</h3><br/>
<p>В предыдущем примере мы рассмотрели простой случай, когда есть возможность сохранить <code>request_handle_t</code> до того момента, пока мы сможем отдать сразу весь ответ на запрос.</p><br/>
<p>Но могут быть и более сложные сценарии, когда, например, нужно отдавать ответ по частям. Т.е., мы получаем запрос, сразу можем сформировать лишь первую часть ответа. Формируем ее. Потом, спустя какое-то время, у нас появляется возможность сформировать вторую часть ответа. Потом, спустя еще какое-то время, мы можем сформировать следующую часть и т.д.</p><br/>
<p>Причем нам может быть желательно, чтобы все эти части уходили по мере того, как мы их формируем. Т.е. сперва первая часть ответа, чтобы клиент мог ее вычитать, затем вторая, затем третья и т.д.</p><br/>
<p>RESTinio позволяет сделать это за счет <a href="https://stiffstream.com/en/docs/restinio/0.4/responsebuilder.html">responce_builder-ов разного типа</a>. В частности, таких типов, как <a href="https://stiffstream.com/en/docs/restinio/0.4/responsebuilder.html#user-controlled-output-response-builder">user_controlled_output</a> и <a href="https://stiffstream.com/en/docs/restinio/0.4/responsebuilder.html#chunked-transfer-encoding-output-builder">chunked_output</a>.</p><br/>
<p>В этом случае нем недостаточно сохранить <code>request_handle_t</code>, ведь <code>request_handle_t</code> будет полезен только до первого вызова <code>create_reponse()</code>. Далее нам нужно работать с response_builder-ом. Ну и...</p><br/>
<p>Ну и ничего страшного. Response_builder — это moveable тип, чем-то похожий на unique_ptr. Так что мы его так же можем сохранить до тех пор, пока он нам потребуется. А чтобы показать, как это выглядит, немного переделаем рассмотренный выше пример. Сделаем так, чтобы функция <code>processing_thread_func()</code> формировала ответ частями.</p><br/>
<p>Это совсем не сложно.</p><br/>
<p>Сперва нам нужно определиться с типами, которые потребуются новой <code>processing_thread_func()</code>:</p><br/>
<pre><code class="cpp">struct handle_request
{
   restinio::request_handle_t m_req;
};

// Тип нашего ответа на запрос.
using output_t = restinio::chunked_output_t;

// И типа reponse_builder-а для нашего запроса.
using response_t = restinio::response_builder_t&lt;output_t>;

// Отложенное сообщение для формирования ответа.
struct timeout_elapsed
{
   response_t m_resp;
   int m_counter;
};</code></pre><br/>
<p>Сообщение <code>handle_request</code> остается без изменений. А вот в сообщении <code>timeout_elapsed</code> мы теперь храним не <code>request_handle_t</code>, а response_builder нужного нам типа. Плюс счетчик оставшихся частей. Как только этот счетчик обнуляется, обслуживание запроса завершается.</p><br/>
<p>Теперь мы можем посмотреть на новый вариант функции <code>processing_thread_func()</code>:</p><br/>
<pre><code class="cpp">void processing_thread_func(so_5::mchain_t req_ch)
{
   std::random_device rd;
   std::mt19937 generator{rd()};
   std::uniform_int_distribution&lt;> pause_generator{350, 3500};

   auto delayed_ch = so_5::create_mchain(req_ch->environment());

   bool stop = false;
   select(
      so_5::from_all()
         .on_close([&amp;stop](const auto &amp;) { stop = true; })
         .stop_on([&amp;stop]{ return stop; }),

      case_(req_ch,
         [&amp;](handle_request cmd) {
            // Начинаем обработку запроса сразу, как только получаем его.
            auto resp = cmd.m_req->create_response&lt;output_t>();

            resp.append_header( restinio::http_field::server, "RESTinio" )
               .append_header_date_field()
               .append_header( restinio::http_field::content_type,
                     "text/plain; charset=utf-8" );

            // Первая часть ответа сформирована, заставляем RESTinio
            // отослать ее клиенту.
            resp.flush();

            // Обработку остальных частей откладываем на случайное время.
            so_5::send_delayed&lt;so_5::mutable_msg&lt;timeout_elapsed>>(delayed_ch,
                  // Пауза перед отсылкой следующей части.
                  std::chrono::milliseconds{pause_generator(generator)},
                  // Аргументы для конструктора timeout_elapsed.
                  // Обращаем внимание на перемещение response_builder-а внутрь сообщения.
                  std::move(resp),
                  3);
         }),

      case_(delayed_ch,
         [&amp;](so_5::mutable_mhood_t&lt;timeout_elapsed> cmd) {
            // Пришло время сформировать следующую часть ответа.
            cmd->m_resp.append_chunk( "this is the next part of the response\n" );
            // Заставляем RESTinio отослать ее клиенту.
            cmd->m_resp.flush();

            cmd->m_counter -= 1;

            if( 0 != cmd->m_counter )
            {
               // Нужно продолжать отсылку частей ответа через случайный интервал.
               so_5::send_delayed(
                     delayed_ch,
                     std::chrono::milliseconds{pause_generator(generator)},
                     std::move(cmd));
            }
            else
               // Все, ответ полностью сформирован.
               cmd->m_resp.done();
         })
   );
}</code></pre><br/>
<p>Т.е. здесь ответ начинает формироваться сразу, как только запрос приходит на отдельную рабочую нить. И первая часть сразу же отсылается клиенту. А вот оставшиеся части формируются через случайные интервалы времени.</p><br/>
<p><strong>Upd.</strong> С методом <code>flush()</code> такая же ситуация, как и с методом <code>done()</code>: RESTinio инициирует операцию записи, но сама I/O-операция будет выполнена не там, где вызван <code>flush()</code>, а там, где RESTinio выполняет ввод-вывод и вызывает request_handler-ы. Т.е. в данном примере <code>flush()</code> вызывается на отдельной рабочей нити, а операция записи будет выполнена на основной нити, там, где работает <code>restinio::run()</code>.</p><br/>
<p>Если запустить данный пример и сделать запрос, то след работы RESTinio будет выглядеть следующим образом:</p><br/>
<pre><code class="plaintext">[2019-05-13 15:02:35.106] TRACE: starting server on 127.0.0.1:8080
[2019-05-13 15:02:35.106]  INFO: init accept #0
[2019-05-13 15:02:35.106]  INFO: server started on 127.0.0.1:8080
[2019-05-13 15:02:39.050] TRACE: accept connection from 127.0.0.1:49280 on socket #0
[2019-05-13 15:02:39.050] TRACE: [connection:1] start connection with 127.0.0.1:49280
[2019-05-13 15:02:39.050] TRACE: [connection:1] start waiting for request
[2019-05-13 15:02:39.050] TRACE: [connection:1] continue reading request
[2019-05-13 15:02:39.050] TRACE: [connection:1] received 78 bytes
[2019-05-13 15:02:39.050] TRACE: [connection:1] request received (#0): GET /
[2019-05-13 15:02:39.050] TRACE: [connection:1] append response (#0), flags: { not_final_parts, connection_keepalive }, write group size: 1
[2019-05-13 15:02:39.050] TRACE: [connection:1] start next write group for response (#0), size: 1
[2019-05-13 15:02:39.050] TRACE: [connection:1] start response (#0): HTTP/1.1 200 OK
[2019-05-13 15:02:39.050] TRACE: [connection:1] sending resp data, buf count: 1, total size: 167
[2019-05-13 15:02:39.050] TRACE: [connection:1] outgoing data was sent: 167 bytes
[2019-05-13 15:02:39.050] TRACE: [connection:1] finishing current write group
[2019-05-13 15:02:39.050] TRACE: [connection:1] should keep alive
[2019-05-13 15:02:40.190] TRACE: [connection:1] append response (#0), flags: { not_final_parts, connection_keepalive }, write group size: 3
[2019-05-13 15:02:40.190] TRACE: [connection:1] start next write group for response (#0), size: 3
[2019-05-13 15:02:40.190] TRACE: [connection:1] sending resp data, buf count: 3, total size: 42
[2019-05-13 15:02:40.190] TRACE: [connection:1] outgoing data was sent: 42 bytes
[2019-05-13 15:02:40.190] TRACE: [connection:1] finishing current write group
[2019-05-13 15:02:40.190] TRACE: [connection:1] should keep alive
[2019-05-13 15:02:43.542] TRACE: [connection:1] append response (#0), flags: { not_final_parts, connection_keepalive }, write group size: 3
[2019-05-13 15:02:43.542] TRACE: [connection:1] start next write group for response (#0), size: 3
[2019-05-13 15:02:43.542] TRACE: [connection:1] sending resp data, buf count: 3, total size: 42
[2019-05-13 15:02:43.542] TRACE: [connection:1] outgoing data was sent: 42 bytes
[2019-05-13 15:02:43.542] TRACE: [connection:1] finishing current write group
[2019-05-13 15:02:43.542] TRACE: [connection:1] should keep alive
[2019-05-13 15:02:46.297] TRACE: [connection:1] append response (#0), flags: { not_final_parts, connection_keepalive }, write group size: 3
[2019-05-13 15:02:46.297] TRACE: [connection:1] start next write group for response (#0), size: 3
[2019-05-13 15:02:46.297] TRACE: [connection:1] sending resp data, buf count: 3, total size: 42
[2019-05-13 15:02:46.297] TRACE: [connection:1] append response (#0), flags: { final_parts, connection_keepalive }, write group size: 1
[2019-05-13 15:02:46.297] TRACE: [connection:1] outgoing data was sent: 42 bytes
[2019-05-13 15:02:46.298] TRACE: [connection:1] finishing current write group
[2019-05-13 15:02:46.298] TRACE: [connection:1] should keep alive
[2019-05-13 15:02:46.298] TRACE: [connection:1] start next write group for response (#0), size: 1
[2019-05-13 15:02:46.298] TRACE: [connection:1] sending resp data, buf count: 1, total size: 5
[2019-05-13 15:02:46.298] TRACE: [connection:1] outgoing data was sent: 5 bytes
[2019-05-13 15:02:46.298] TRACE: [connection:1] finishing current write group
[2019-05-13 15:02:46.298] TRACE: [connection:1] should keep alive
[2019-05-13 15:02:46.298] TRACE: [connection:1] start waiting for request
[2019-05-13 15:02:46.298] TRACE: [connection:1] continue reading request
[2019-05-13 15:02:46.298] TRACE: [connection:1] EOF and no request, close connection
[2019-05-13 15:02:46.298] TRACE: [connection:1] close
[2019-05-13 15:02:46.298] TRACE: [connection:1] close: close socket
[2019-05-13 15:02:46.298] TRACE: [connection:1] close: timer canceled
[2019-05-13 15:02:46.298] TRACE: [connection:1] close: reset responses data
[2019-05-13 15:02:46.298] TRACE: [connection:1] destructor called</code></pre><br/>
<p>Здесь можно увидеть, как RESTinio принимает запрос и сразу же отсылает первую часть ответа размером 167 байт. Затем через разные промежутки времени отсылаются остальные части ответа и, когда клиент получает весь ответ и закрывает соединение со своей стороны, RESTinio закрывает соединение у себя и освобождает связанные с ним ресурсы.</p><br/>
<p>Данный пример показывает, что при использовании RESTinio можно сохранить где-то в прикладном коде объект response_builder и задействовать этот объект тогда, когда появляется возможность сформировать очередную часть ответа клиенту.</p><br/>
<p>В примере я применял отложенные сообщения. Но в реальном коде у нас могут быть, скажем, асинхронные запросы к внешним сервисам. В этом случае мы можем ассоциировать response_builder с асинхронным запросом. Когда ответ на запрос поступит, мы воспользуемся responce_builder для отдачи клиенту части нужной клиенту информации, а сами сделаем асинхронный запрос к следующему сервису и т.д.</p><br/>
<p>Полный код примера можно увидеть <a href="https://gist.github.com/eao197/e3d93b292dee3967c6a84e2646d7b8ba">здесь</a>.</p><br/>
<h2 id="chto-budet-esli-obrabotka-zaprosa-zaymet-slishkom-mnogo-vremeni">Что будет, если обработка запроса займет слишком много времени?</h2><br/>
<p>Допустим, в своем request_handler-е мы делегировали обработку запроса какой-то другой рабочей нити. Что произойдет, если эта нить будет настолько занята, что сможет приступить к обработке запроса только через час или два?</p><br/>
<p>Когда RESTinio отдает запрос на обработку, начинается отсчет тайм-аута для request_handler-а. Как только этот тайм-аут истечет, а ответ не будет сформирован, RESTinio просто напросто закроет соединение на своей стороне. То, что затем будет сформировано в качестве ответа будет проигнорировано. Вот, например:</p><br/>
<pre><code class="plaintext">[2019-05-13 15:32:23.618] TRACE: starting server on 127.0.0.1:8080
[2019-05-13 15:32:23.618]  INFO: init accept #0
[2019-05-13 15:32:23.618]  INFO: server started on 127.0.0.1:8080
[2019-05-13 15:32:26.768] TRACE: accept connection from 127.0.0.1:49502 on socket #0
[2019-05-13 15:32:26.768] TRACE: [connection:1] start connection with 127.0.0.1:49502
[2019-05-13 15:32:26.768] TRACE: [connection:1] start waiting for request
[2019-05-13 15:32:26.768] TRACE: [connection:1] continue reading request
[2019-05-13 15:32:26.768] TRACE: [connection:1] received 78 bytes
[2019-05-13 15:32:26.768] TRACE: [connection:1] request received (#0): GET /
[2019-05-13 15:32:30.768] TRACE: [connection:1] handle request timed out
[2019-05-13 15:32:30.768] TRACE: [connection:1] close
[2019-05-13 15:32:30.768] TRACE: [connection:1] close: close socket
[2019-05-13 15:32:30.768] TRACE: [connection:1] close: timer canceled
[2019-05-13 15:32:30.768] TRACE: [connection:1] close: reset responses data
[2019-05-13 15:32:31.768]  WARN: [connection:1] try to write response, while socket is closed
[2019-05-13 15:32:31.768] TRACE: [connection:1] destructor called</code></pre><br/>
<p>Здесь истек тайм-аут для обработчика запроса и соединение было закрыто. Затем, когда через секунду ответ попытались записать, то RESTinio проигнорировал эту попытку, т.к. соединения с клиентом уже нет.</p><br/>
<p>Управлять величиной тайм-аута можно посредством параметра <code>handle_request_timeout</code>, который задается в параметрах RESTinio-сервера (подробнее <a href="https://stiffstream.com/en/docs/restinio/0.4/serversettings.html">здесь</a>).</p><br/>
<h1 id="zaklyuchenie">Заключение</h1><br/>
<p>Надеюсь, мне удалось показать, что асинхронная обработка запросов в RESTinio — это не сложно, и не страшно. Так что, если вы решили попробовать RESTinio, то имейте в виду, что асинхронность является одной из основных возможностей RESTinio, поэтому грех от нее отказываться.</p><br/>
<p>Ну а если вы смотрели RESTinio и не решились взять наш фреймворк в работу, то поделитесь, пожалуйста, своими соображениями: почему отказались? Чего-то не хватило? Что-то не понравилось? Где-то что-то сделано лучше?</p><br/>
<p>PS. На Хабре про RESTinio мы рассказываем пока сильно меньше, чем про SObjectizer, но несколько публикаций было. Так что, если кто-то узнал про RESTinio впервые, то вот некоторые из них: "<a href="https://habr.com/post/345788/">Трехэтажные C++ные шаблоны в реализации встраиваемого асинхронного HTTP-сервера с человеческим лицом</a>", "<a href="https://habr.com/post/349728/">Асинхронные HTTP-запросы на C++: входящие через RESTinio, исходящие через libcurl. Часть 1</a>", "<a href="https://habr.com/post/416387/">Shrimp: масштабируем и раздаем по HTTP картинки на современном C++ посредством ImageMagic++, SObjectizer и RESTinio</a>"</p></div></div> <!----> <!----></div> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bc%2B%2B%5D" class="tm-tags-list__link">c++</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bc%2B%2B14%5D" class="tm-tags-list__link">c++14</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bc%2B%2B%20%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B8%5D" class="tm-tags-list__link">c++ библиотеки</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Brestinio%5D" class="tm-tags-list__link">restinio</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bhttp-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%5D" class="tm-tags-list__link">http-сервер</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Brestful%5D" class="tm-tags-list__link">restful</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Brestful%20http%5D" class="tm-tags-list__link">restful http</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/hub/open_source/" class="tm-hubs-list__link">
    Open source
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/programming/" class="tm-hubs-list__link">
    Программирование
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/cpp/" class="tm-hubs-list__link">
    C++
  </a></li></ul></div></div></article></div> <!----></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_medium"><title>Всего голосов 18: ↑18 и ↓0</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-rating"></use></svg> <span title="Всего голосов 18: ↑18 и ↓0" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_medium">+18</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">7.7K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    75
  </span></button> <!----> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> </div></div> <!----> <!----> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="/ru/users/eao197/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><svg class="tm-svg-img tm-image-placeholder tm-image-placeholder_lilac"><!----> <use xlink:href="/img/megazord-v24.ce74655c.svg#placeholder-user"></use></svg></div></a> <div class="tm-user-card__meta"><div title=" 123 голоса " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    71
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">0.1</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title_variant-article"><span class="tm-user-card__name tm-user-card__name_variant-article">Евгений Охотников</span> <a href="/ru/users/eao197/" class="tm-user-card__nickname tm-user-card__nickname_variant-article">
          @eao197
        </a> <!----></div> <p class="tm-user-card__short-info tm-user-card__short-info_variant-article">Проджект-лид</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-article"><!----> <!----> <!----> <!----> <!----></div></div> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----></section> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="/ru/post/451728/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментарии 8 
    </span></a> <!----></div></div></div> <div class="tm-ad-banner__container tm-page-article__banner"><!----> <div id="articleBottomBanner" class="tm-ad-banner"></div></div> <!----> <!----> <!----> <!----> </div></div></div></div></div> <div class="tm-page__sidebar"><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__ads tm-layout-sidebar__ads_initial"><div class="tm-ad-banner__container tm-layout-sidebar__banner"><!----> <div id="sidebarBanner" class="tm-ad-banner"></div></div></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----> <!----></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/post/451728/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/post/451728/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2021 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"451728":{"id":"451728","timePublished":"2019-05-14T12:08:16+00:00","isCorporative":false,"lang":"ru","titleHtml":"RESTinio — это асинхронный HTTP-сервер. Асинхронный","leadData":{"textHtml":"\u003Cp\u003EПару лет назад мы опубликовали \u003Ca href=\"https:\u002F\u002Fbitbucket.org\u002Fsobjectizerteam\u002Frestinio-0.4\"\u003ERESTinio\u003C\u002Fa\u003E — свой небольшой OpenSource C++фреймворк для встраивания HTTP-сервера в C++ приложения. Мегапопулярным за это время RESTinio не стал, но и \u003Ca href=\"https:\u002F\u002Fwww.reddit.com\u002Fr\u002Fcpp\u002Fcomments\u002Fauvvf5\u002Frestful_style_apis_in_c\u002Fehb7b7f\u002F\"\u003Eне потерялся\u003C\u002Fa\u003E. Кто-то выбирает его за \"родную\" поддержку Windows, кто-то за какие-то отдельные фичи (вроде поддержки sendfile), кто-то за соотношение возможностей, простоты использования и настраиваемости. Но, думаю, изначально многих RESTinio привлекает вот этим лаконичным \"Hello, World\"-ом:\u003C\u002Fp\u003E\u003Cbr\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E#include &lt;restinio\u002Fall.hpp&gt;\nint main()\n{\n    restinio::run(\n        restinio::on_this_thread()\n        .port(8080)\n        .address(\"localhost\")\n        .request_handler([](auto req) {\n            return req-&gt;create_response().set_body(\"Hello, World!\").done();\n        }));\n    return 0;\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u003E\r\n\u003Cp\u003EЭто, действительно, все, что нужно чтобы запустить HTTP-сервер внутри C++ приложения.\u003C\u002Fp\u003E\u003Cbr\u003E\r\n\u003Cp\u003EИ хотя мы всегда стараемся говорить, что ключевой фичей, ради которой мы вообще занялись RESTinio, была асинхронная обработка входящих запросов, все равно периодически сталкиваемся с вопросами о том, как быть, если внутри request_handler-а приходится выполнять длительные операции.\u003C\u002Fp\u003E\u003Cbr\u003E\r\n\u003Cp\u003EА раз такой вопрос актуален, то можно еще раз о нем поговорить и привести парочку небольших примеров.\u003C\u002Fp\u003E","imageUrl":null,"buttonTextHtml":"Читать дальше →","image":null},"editorVersion":"1.0","postType":"article","postLabels":[],"author":{"scoreStats":{"score":71,"votesCount":123},"rating":0.1,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"1225749","alias":"eao197","fullname":"Евгений Охотников","avatarUrl":null,"speciality":"Проджект-лид"},"statistics":{"commentsCount":8,"favoritesCount":75,"readingCount":7654,"score":18,"votesCount":18},"hubs":[{"relatedData":null,"id":"144","alias":"open_source","type":"collective","title":"Open source","titleHtml":"Open source","isProfiled":true},{"relatedData":null,"id":"359","alias":"programming","type":"collective","title":"Программирование","titleHtml":"Программирование","isProfiled":true},{"relatedData":null,"id":"559","alias":"cpp","type":"collective","title":"C++","titleHtml":"C++","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Cp\u003EПару лет назад мы опубликовали \u003Ca href=\"https:\u002F\u002Fbitbucket.org\u002Fsobjectizerteam\u002Frestinio-0.4\"\u003ERESTinio\u003C\u002Fa\u003E — свой небольшой OpenSource C++фреймворк для встраивания HTTP-сервера в C++ приложения. Мегапопулярным за это время RESTinio не стал, но и \u003Ca href=\"https:\u002F\u002Fwww.reddit.com\u002Fr\u002Fcpp\u002Fcomments\u002Fauvvf5\u002Frestful_style_apis_in_c\u002Fehb7b7f\u002F\"\u003Eне потерялся\u003C\u002Fa\u003E. Кто-то выбирает его за \"родную\" поддержку Windows, кто-то за какие-то отдельные фичи (вроде поддержки sendfile), кто-то за соотношение возможностей, простоты использования и настраиваемости. Но, думаю, изначально многих RESTinio привлекает вот этим лаконичным \"Hello, World\"-ом:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E#include &lt;restinio\u002Fall.hpp\u003E\nint main()\n{\n    restinio::run(\n        restinio::on_this_thread()\n        .port(8080)\n        .address(\"localhost\")\n        .request_handler([](auto req) {\n            return req-\u003Ecreate_response().set_body(\"Hello, World!\").done();\n        }));\n    return 0;\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЭто, действительно, все, что нужно чтобы запустить HTTP-сервер внутри C++ приложения.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИ хотя мы всегда стараемся говорить, что ключевой фичей, ради которой мы вообще занялись RESTinio, была асинхронная обработка входящих запросов, все равно периодически сталкиваемся с вопросами о том, как быть, если внутри request_handler-а приходится выполнять длительные операции.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EА раз такой вопрос актуален, то можно еще раз о нем поговорить и привести парочку небольших примеров.\u003C\u002Fp\u003E\u003Ca name=\"habracut\"\u003E\u003C\u002Fa\u003E\u003Cbr\u002F\u003E\r\n\u003Ch1 id=\"nebolshaya-otsylka-k-istokam\"\u003EНебольшая отсылка к истокам\u003C\u002Fh1\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EМы решили сделать свой встраиваемый HTTP-сервер после того, как несколько раз подряд столкнулись с очень похожими задачами: нужно было организовать HTTP-вход для уже существующего C++ приложения или нужно было написать микросервис, в котором требовалось переиспользовать уже существующий \"тяжелый\" C++ный код. Общей чертой у этих задач было то, что прикладная обработка запроса могла растянуться на десятки секунд.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EГрубо говоря, HTTP-сервер за миллисекунду разбирался с новым HTTP-запросом, но для выдачи HTTP-ответа требовалось обратиться к каким-то другим сервисам или же провести какие-то длительные вычисления. Если выполнять обработку HTTP-запросов в синхронном режиме, то HTTP-серверу потребуется пул из тысяч рабочих нитей, что вряд ли можно считать хорошей идеей даже в современных условиях.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EГораздо удобнее, когда HTTP-сервер сможет работать всего на одной рабочей нити, на которой выполняется ввод\u002Fвывод и вызываются обработчики запросов. Обработчик запроса просто делегирует реальную обработку какой-то другой рабочей нити и возвращает управление HTTP-серверу. Когда, сильно позже, где-то на другой рабочей нити будет готова информация для ответа на запрос, просто формируется HTTP-ответ, который автоматически подхватывает HTTP-сервер и отсылает этот ответ соответствующему клиенту.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПоскольку мы так и не нашли удовлетворяющего нас готового варианта, который был бы прост и удобен в использовании, был кроссплатформенным и поддерживал бы Windows как \"родную\" платформу, обеспечивал бы более-менее приличную производительность, и, главное, был бы заточен именно под асинхронную работу, то в начале 2017 года занялись разработкой RESTinio.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EМы хотели сделать асинхронный встраиваемый HTTP-сервер, простой в использовании, освобождающий пользователя от каких-то рутинных забот, при этом более-менее производительный, кроссплатформенный и допускающий гибкую настройку под разные условия. Вроде бы получилось, но об этом предоставим судить пользователям...\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch1 id=\"itak-est-vhodyaschiy-zapros-trebuyuschiy-mnogo-vremeni-na-obrabotku-chto-delat\"\u003EИтак, есть входящий запрос, требующий много времени на обработку. Что делать?\u003C\u002Fh1\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"rabochie-niti-restinioasio\"\u003EРабочие нити RESTinio\u002FAsio\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИногда пользователи RESTinio не задумываются о том, какие рабочие нити и как именно использует RESTinio. Например, кто-то может посчитать, что когда RESTinio запускается на одной рабочей нити (посредством \u003Ccode\u003Erun(on_this_thread(...))\u003C\u002Fcode\u003E, как в примере выше), то на этой рабочей нити RESTinio только вызывает обработчики запросов. Тогда как для операций ввода-вывода RESTinio \"под капотом\" создает отдельную нить. И эта отдельная нить продолжает обслуживать новые подключения когда основная рабочая нить занята request_handler-ом.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНа самом деле все нити, которые пользователь выделяет RESTinio, используются и для выполнения операций ввода-вывода, и для вызова request_handler-ов. Поэтому, если вы запустили RESTinio-сервер через \u003Ccode\u003Erun(on_this_thread(...))\u003C\u002Fcode\u003E, то внутри \u003Ccode\u003Erun()\u003C\u002Fcode\u003E на текущей нити будут выполняться и операции ввода-вывода, и обработчики запросов.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EГрубо говоря, RESTinio запускает Asio-шный event-loop, внутри которого выполняется обработка новых подключений, чтение и парсинг данных из уже существующих подключений, запись готовых для отсылки данных, обработка закрытия соединений и т.п. Среди прочего, после того, как из очередного подключения вычитан и полностью разобран входящий запрос, для обработки этого запроса вызывается заданный пользователем request_handler.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EСоответственно, если request_handler блокирует работу текущей нити, то блокируется и работающий на этой же нити Asio-шный event-loop. Все просто.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЕсли RESTinio запускается на пуле рабочих нитей (т.е. посредством \u003Ccode\u003Erun(on_thread_pool(...))\u003C\u002Fcode\u003E, как \u003Ca href=\"https:\u002F\u002Fbitbucket.org\u002Fsobjectizerteam\u002Frestinio-0.4\u002Fsrc\u002Fv.0.4.9\u002Fdev\u002Fsample\u002Fhello_world_delayed\u002Fmain.cpp\"\u003Eвот в этом примере\u003C\u002Fa\u003E), то происходит практически тоже самое: на каждой нити из пула запускается Asio-шный event-loop. Поэтому если какой-то request_handler начнет перемножать большие матрицы, то это заблокирует рабочую нить в пуле и на этой нити перестанут обслуживаться операции ввода-вывода.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПоэтому при использовании RESTinio задача разработчика в том, чтобы его request_handler-ы завершались за разумное и, желательно, не очень большое время.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"nuzhen-li-vam-pul-rabochih-potokov-dlya-restinioasio\"\u003EНужен ли вам пул рабочих потоков для RESTinio\u002FAsio?\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИтак, когда заданный пользователем request_handler блокирует длительной операций рабочую нить, на которой он вызван, то эта нить теряет возможность обрабатывать операции ввода-вывода. Но что делать, если request_handler-у нужно много времени для формирования ответа? Допустим, он делает какую-то тяжелую вычислительную операцию, время которой в принципе нельзя ужать до нескольких миллисекунд?\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКто-то из пользователей может подумать, что раз RESTinio может работать на пуле рабочих нитей, то достаточно указать размер пула побольше и все.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EК сожалению, это будет работать лишь в простых случаях, когда у вас немного параллельных подключений. Да и интенсивность запросов невысока. Если же счет параллельных запросов идет на тысячи (да хотя бы всего лишь на несколько сотен), то легко получить ситуацию, когда все рабочие нити пула будут заняты обработкой уже принятых запросов. А для выполнения операций ввода-вывода нитей уже не останется. В результате чего сервер потеряет \"отзывчивость\". В том числе RESTinio потеряет возможность обрабатывать тайм-ауты, которые RESTinio автоматически отсчитывает при приеме новых подключений и при обработке запросов.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПоэтому, если для обслуживания входящих запросов вам требуется выполнять длительные блокирующие операции, то лучше выделить для RESTinio всего одну рабочую нить, а вот большой пул рабочих потоков отрядить для выполнения этих самых операций. Обработчик запроса будет всего лишь класть очередной запрос в какую-то очередь, откуда запрос будет извлекаться и отдаваться на обработку.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПример этой схемы мы подробно рассматривали когда рассказывали о своем \u003Ca href=\"https:\u002F\u002Fstiffstream.com\u002Fen\u002Fdocs\u002Fshrimp-demo.html\"\u003Eдемо-проекте Shrimp\u003C\u002Fa\u003E вот в этой статье: \"\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fpost\u002F416387\u002F\"\u003EShrimp: масштабируем и раздаем по HTTP картинки на современном C++ посредством ImageMagic++, SObjectizer и RESTinio\u003C\u002Fa\u003E\".\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"primery-delegirovaniya-obrabotki-zaprosov-na-otdelnye-rabochie-niti\"\u003EПримеры делегирования обработки запросов на отдельные рабочие нити\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВыше я попытался объяснить, почему не стоит выполнять длительную обработку прямо внутри request_handler-а. Откуда проистекает очевидное следствие: длительная обработка запроса должна быть делегирована каким-то другим рабочим нитям. Давайте посмотрим на то, как это может выглядеть.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ двух примерах ниже нам потребуется единственная рабочая нить для запуска RESTinio и еще одна рабочая нить для имитации длительной обработки запросов. А также нам потребуется какая-то очередь сообщений для передачи запросов от нити RESTinio к отдельной рабочей нити.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДелать новую реализацию thread-safe message queue на коленке для этих двух примеров мне было не с руки, поэтому я воспользовался родным для меня SObjectizer-ом и его mchain-ами, которые суть CSP-шные каналы. Подробнее про mchain-ы можно прочитать здесь: \"\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fpost\u002F358120\u002F\"\u003EОбмен информацией между рабочими нитям без боли? CSP-шные каналы нам в помощь\u003C\u002Fa\u003E\".\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"sohranenie-obekta-request_handle\"\u003EСохранение объекта request_handle\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EБазовый прием, на котором строится делегирование обработки запросов, — это передача куда-то объекта \u003Ccode\u003Erequest_handle_t\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКогда RESTinio для обработки входящего запроса вызывает заданный пользователем request_handler, в этот request_handler передается объект типа \u003Ccode\u003Erequest_handle_t\u003C\u002Fcode\u003E. Данный тип является ни чем иным, как умным указателем на параметры полученного запроса. Так что если кому-то удобно думать, что \u003Ccode\u003Erequest_handle_t\u003C\u002Fcode\u003E — это \u003Ccode\u003Eshared_ptr\u003C\u002Fcode\u003E, то смело можно так думать. Это \u003Ccode\u003Eshared_ptr\u003C\u002Fcode\u003E и есть.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EА раз \u003Ccode\u003Erequest_handle_t\u003C\u002Fcode\u003E — это \u003Ccode\u003Eshared_ptr\u003C\u002Fcode\u003E, то мы можем смело этот умный указатель куда-то передать. Что мы и будем делать в показанных ниже примерах.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИтак, нам потребуется отдельная рабочая нить и канал для связи с ней. Создадим это все:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Eint main()\n{\n    \u002F\u002F Запускаем SObjectizer.\n    so_5::wrapped_env_t sobj;\n\n    \u002F\u002F Объект std::thread для нити обработки запросов.\n    std::thread processing_thread;\n    \u002F\u002F При выходе из main для этой нити нужно вызвать join.\n    \u002F\u002F Делаем это через RAII.\n    auto processing_thread_joiner = so_5::auto_join(processing_thread);\n\n    \u002F\u002F Канал для передачи запросов на обработку.\n    auto req_ch = so_5::create_mchain(sobj);\n    \u002F\u002F Канал нужно закрыть при выходе из main.\n    \u002F\u002F Делаем это через RAII.\n    auto ch_closer = so_5::auto_close_drop_content(req_ch);\n\n    \u002F\u002F Теперь можем запустить отдельную нить.\n    \u002F\u002F Если далее произойдет выход из main() по какой-то причине,\n    \u002F\u002F то канал принудительно будет закрыт, а для нити будет вызван join().\n    processing_thread = std::thread{\n            processing_thread_func, req_ch\n    };\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТело самой рабочей нити находится внутри функции \u003Ccode\u003Eprocessing_thread_func()\u003C\u002Fcode\u003E, которую мы рассмотрим чуть позже.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EСейчас у нас уже есть отдельная рабочая нить и канал для связи с ней. Можно запустить RESTinio-сервер:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E    \u002F\u002F Свойства, которыми должен обладать наш сервер.\n    struct traits_t : public restinio::default_traits_t\n    {\n        using logger_t = restinio::shared_ostream_logger_t;\n    };\n\n    restinio::run(\n        restinio::on_this_thread&lt;traits_t\u003E()\n            .port(8080)\n            .address(\"localhost\")\n            .request_handler([req_ch](auto req) {\n                \u002F\u002F Обрабатываем только GET-запросы для корневого каталога.\n                if(restinio::http_method_t::http_get == req-\u003Eheader().method() &amp;&amp;\n                        \"\u002F\" == req-\u003Eheader().path())\n                {\n                    \u002F\u002F Делегируем обработку отдельной нити.\n                    so_5::send&lt;handle_request\u003E(req_ch, req);\n                    return restinio::request_accepted();\n                }\n                else\n                    return restinio::request_rejected();\n            })\n            .cleanup_func([&amp;] {\n                \u002F\u002F Закрываем канал запросов для отдельной нити.\n                \u002F\u002F Лучше сделать это вручную, т.к. внутри req_ch\n                \u002F\u002F могут быть ждущие своей очереди запросы и их следует\n                \u002F\u002F уничтожить пока сервер еще существует.\n                so_5::close_drop_content(req_ch);\n            }));\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЛогика у этого сервера очень простая. Если пришел GET-запрос для '\u002F', то мы делегируем обработку запроса отдельной нити. Для этого выполняем две важных операции:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003Eотсылаем объект \u003Ccode\u003Erequest_handle_t\u003C\u002Fcode\u003E в CSP-шный канал. Пока этот объект хранится внутри CSP-шного канала или где-то еще, то RESTinio знает, что запрос еще жив;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eвозвращаем значение \u003Ccode\u003Erestinio::request_accepted()\u003C\u002Fcode\u003E из обработчика запроса. Это дает RESTinio понять, что запрос принят к обработке и нельзя закрывать соединение с клиентом.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТот факт, что request_handler сразу не сформировал ответ RESTinio нисколько не смущает. Раз вернули \u003Ccode\u003Erestinio::request_accepted()\u003C\u002Fcode\u003E, значит пользователь взял на себя ответственность за обработку запроса и когда-нибудь ответ на запрос будет сформирован.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЕсли же обработчик запроса вернул \u003Ccode\u003Erestinio::request_rejected()\u003C\u002Fcode\u003E, то RESTinio понимает, что запрос обработан не будет и вернет клиенту ошибку 501.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИтак, зафиксируем предварительный итог: экземпляр \u003Ccode\u003Erequest_handle_t\u003C\u002Fcode\u003E может быть передан куда-то, поскольку это, по сути, \u003Ccode\u003Estd::shared_ptr\u003C\u002Fcode\u003E. Пока этот экземпляр жив, RESTinio считает, что запрос находится в обработке. Если обработчик запроса возвратил \u003Ccode\u003Erestinio::request_accepted()\u003C\u002Fcode\u003E, то RESTinio не будет волноваться о том, что ответ на запрос не был сформирован вот прямо сейчас.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТеперь мы можем посмотреть на реализацию этой самой отдельной нити:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Evoid processing_thread_func(so_5::mchain_t req_ch)\n{\n    \u002F\u002F Генератор случайных чисел для определения задержки\n    \u002F\u002F при имитации обработки запроса.\n    std::random_device rd;\n    std::mt19937 generator{rd()};\n    std::uniform_int_distribution&lt;\u003E pause_generator{350, 3500};\n\n    \u002F\u002F Отдельный канал для отложенных сообщений timeout_elapsed.\n    auto delayed_ch = so_5::create_mchain(req_ch-\u003Eenvironment());\n\n    \u002F\u002F Выставляем этот флаг если какой-то канал закрывается.\n    bool stop = false;\n    select(\n        so_5::from_all()\n            \u002F\u002F Реакция на закрытие любого из каналов.\n            .on_close([&amp;stop](const auto &amp;) { stop = true; })\n            \u002F\u002F Предикат для выхода из select().\n            \u002F\u002F Завершаем select() как только канал оказывается закрыт.\n            .stop_on([&amp;stop]{ return stop; }),\n\n        \u002F\u002F Читаем сообщения handle_request из канала общения с RESTinio.\n        case_(req_ch,\n            [&amp;](handle_request cmd) {\n                \u002F\u002F Случайная задержка для обработки запроса.\n                const std::chrono::milliseconds pause{pause_generator(generator)};\n\n                \u002F\u002F Отсылаем самим себе отложенное сообщение.\n                so_5::send_delayed&lt;timeout_elapsed\u003E(delayed_ch,\n                        \u002F\u002F Это задержка для timeout_elapsed.\n                        pause,\n                        \u002F\u002F Все остальное идет в конструктор timeout_elapsed.\n                        cmd.m_req,\n                        pause);\n            }),\n\n        \u002F\u002F Читаем сообщения timeout_elapsed.\n        case_(delayed_ch,\n            [](timeout_elapsed cmd) {\n                \u002F\u002F Формируем актуальный ответ на запрос.\n                cmd.m_req-\u003Ecreate_response()\n                        .set_body(\"Hello, World! (pause:\"\n                                + std::to_string(cmd.m_pause.count())\n                                + \"ms)\")\n                        .done();\n            })\n    );\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЗдесь очень простая логика: мы получаем исходный запрос в виде сообщения \u003Ccode\u003Ehandle_request\u003C\u002Fcode\u003E и пересылаем его сами себе в виде отложенного на некоторое случайное время сообщения \u003Ccode\u003Etimeout_elapsed\u003C\u002Fcode\u003E. Реальную обработку запроса делаем лишь при получении \u003Ccode\u003Etimeout_elapsed\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cstrong\u003EUpd.\u003C\u002Fstrong\u003E Когда на отдельной рабочей нити вызывается метод \u003Ccode\u003Edone()\u003C\u002Fcode\u003E, то RESTinio уведомляется о том, что появился готовый ответ, который нужно записать в TCP-соединение. RESTinio инициирует операцию записи, но сама I\u002FO-операция будет выполнена не там, где вызван \u003Ccode\u003Edone()\u003C\u002Fcode\u003E, а там, где RESTinio выполняет ввод-вывод и вызывает request_handler-ы. Т.е. в данном примере \u003Ccode\u003Edone()\u003C\u002Fcode\u003E вызывается на отдельной рабочей нити, а операция записи будет выполнена на основной нити, там, где работает \u003Ccode\u003Erestinio::run()\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EСами упомянутые сообщения имеют следующий вид:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Estruct handle_request\n{\n    restinio::request_handle_t m_req;\n};\n\nstruct timeout_elapsed\n{\n    restinio::request_handle_t m_req;\n    std::chrono::milliseconds m_pause;\n};\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТ.е. отдельная рабочая нить берет \u003Ccode\u003Erequest_handle_t\u003C\u002Fcode\u003E и сохраняет его до того времени, пока не появится возможность сформировать полный ответ. А когда такая возможность появляется, у сохраненного объекта-запроса вызывается \u003Ccode\u003Ecreate_response()\u003C\u002Fcode\u003E и ответ отдается RESTinio. После чего RESTinio уже на своем рабочем контексте записывает ответ в соединение с соответствующим клиентом.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЗдесь экземпляр \u003Ccode\u003Erequest_handle_t\u003C\u002Fcode\u003E хранится в отложенном сообщении \u003Ccode\u003Etimeout_elapsed\u003C\u002Fcode\u003E, поскольку никакой реальной обработки в этом примитивном примере нет. В реальном приложении \u003Ccode\u003Erequest_handle_t\u003C\u002Fcode\u003E может храниться в какой-то очереди или внутри какого-то объекта, созданного для обработки запроса.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПолный код этого примера можно найти \u003Ca href=\"https:\u002F\u002Fbitbucket.org\u002Fsobjectizerteam\u002Frestinio-0.4\u002Fsrc\u002Fv.0.4.9\u002Fdev\u002Fsample\u002Fasync_handling_with_sobjectizer\u002Fmain.cpp\"\u003Eсреди штатных примеров RESTinio\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch4 id=\"neskolko-nebolshih-poyasneniy-po-kodu\"\u003EНесколько небольших пояснений по коду\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВот эта конструкция задает RESTinio свойства, которыми должен обладать RESTinio-сервер:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E    \u002F\u002F Свойства, которыми должен обладать наш сервер.\n    struct traits_t : public restinio::default_traits_t\n    {\n        using logger_t = restinio::shared_ostream_logger_t;\n    };\n\n    restinio::run(\n        restinio::on_this_thread&lt;traits_t\u003E()\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДля данного примера мне нужно, чтобы RESTinio логировал свои действия по обработке запросов. Поэтому я задаю \u003Ccode\u003Elogger_t\u003C\u002Fcode\u003E, отличный от используемого по умолчанию \u003Ccode\u003Enull_logger_t\u003C\u002Fcode\u003E. Но т.к. RESTinio будет работать, фактически, на нескольких нитях (входящие запросы RESTinio обрабатывает на основной нити, а вот ответы к нему приходят с отдельной рабочей нити), то нужен thread-safe logger, коим и является \u003Ccode\u003Eshared_ostream_logger_t\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВнутри \u003Ccode\u003Eprocessing_thread_func()\u003C\u002Fcode\u003E используется SObjectizer-овская функция \u003Ccode\u003Eselect()\u003C\u002Fcode\u003E, в чем-то аналогичная Go-шной конструкции select: можно читать и обрабатывать сообщения сразу из нескольких каналов. Функция \u003Ccode\u003Eselect()\u003C\u002Fcode\u003E работает до тех пор, пока не будут закрыты все переданные ей каналы. Или пока ей принудительно не скажут, что пора завершаться.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПри этом если закрывается канал для связи с RESTinio-сервером, то продолжать работу смысла нет. Поэтому в \u003Ccode\u003Eselect()\u003C\u002Fcode\u003E определяется реакция на закрытие любого из каналов: как только какой-то канал закрывается, взводится флаг stop. А это приведет к завершению работы \u003Ccode\u003Eselect()\u003C\u002Fcode\u003E и выходу из \u003Ccode\u003Eprocessing_thread_func()\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"sohranenie-obekta-response_builder\"\u003EСохранение объекта response_builder\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ предыдущем примере мы рассмотрели простой случай, когда есть возможность сохранить \u003Ccode\u003Erequest_handle_t\u003C\u002Fcode\u003E до того момента, пока мы сможем отдать сразу весь ответ на запрос.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНо могут быть и более сложные сценарии, когда, например, нужно отдавать ответ по частям. Т.е., мы получаем запрос, сразу можем сформировать лишь первую часть ответа. Формируем ее. Потом, спустя какое-то время, у нас появляется возможность сформировать вторую часть ответа. Потом, спустя еще какое-то время, мы можем сформировать следующую часть и т.д.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПричем нам может быть желательно, чтобы все эти части уходили по мере того, как мы их формируем. Т.е. сперва первая часть ответа, чтобы клиент мог ее вычитать, затем вторая, затем третья и т.д.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003ERESTinio позволяет сделать это за счет \u003Ca href=\"https:\u002F\u002Fstiffstream.com\u002Fen\u002Fdocs\u002Frestinio\u002F0.4\u002Fresponsebuilder.html\"\u003Eresponce_builder-ов разного типа\u003C\u002Fa\u003E. В частности, таких типов, как \u003Ca href=\"https:\u002F\u002Fstiffstream.com\u002Fen\u002Fdocs\u002Frestinio\u002F0.4\u002Fresponsebuilder.html#user-controlled-output-response-builder\"\u003Euser_controlled_output\u003C\u002Fa\u003E и \u003Ca href=\"https:\u002F\u002Fstiffstream.com\u002Fen\u002Fdocs\u002Frestinio\u002F0.4\u002Fresponsebuilder.html#chunked-transfer-encoding-output-builder\"\u003Echunked_output\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ этом случае нем недостаточно сохранить \u003Ccode\u003Erequest_handle_t\u003C\u002Fcode\u003E, ведь \u003Ccode\u003Erequest_handle_t\u003C\u002Fcode\u003E будет полезен только до первого вызова \u003Ccode\u003Ecreate_reponse()\u003C\u002Fcode\u003E. Далее нам нужно работать с response_builder-ом. Ну и...\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНу и ничего страшного. Response_builder — это moveable тип, чем-то похожий на unique_ptr. Так что мы его так же можем сохранить до тех пор, пока он нам потребуется. А чтобы показать, как это выглядит, немного переделаем рассмотренный выше пример. Сделаем так, чтобы функция \u003Ccode\u003Eprocessing_thread_func()\u003C\u002Fcode\u003E формировала ответ частями.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЭто совсем не сложно.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EСперва нам нужно определиться с типами, которые потребуются новой \u003Ccode\u003Eprocessing_thread_func()\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Estruct handle_request\n{\n   restinio::request_handle_t m_req;\n};\n\n\u002F\u002F Тип нашего ответа на запрос.\nusing output_t = restinio::chunked_output_t;\n\n\u002F\u002F И типа reponse_builder-а для нашего запроса.\nusing response_t = restinio::response_builder_t&lt;output_t\u003E;\n\n\u002F\u002F Отложенное сообщение для формирования ответа.\nstruct timeout_elapsed\n{\n   response_t m_resp;\n   int m_counter;\n};\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EСообщение \u003Ccode\u003Ehandle_request\u003C\u002Fcode\u003E остается без изменений. А вот в сообщении \u003Ccode\u003Etimeout_elapsed\u003C\u002Fcode\u003E мы теперь храним не \u003Ccode\u003Erequest_handle_t\u003C\u002Fcode\u003E, а response_builder нужного нам типа. Плюс счетчик оставшихся частей. Как только этот счетчик обнуляется, обслуживание запроса завершается.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТеперь мы можем посмотреть на новый вариант функции \u003Ccode\u003Eprocessing_thread_func()\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Evoid processing_thread_func(so_5::mchain_t req_ch)\n{\n   std::random_device rd;\n   std::mt19937 generator{rd()};\n   std::uniform_int_distribution&lt;\u003E pause_generator{350, 3500};\n\n   auto delayed_ch = so_5::create_mchain(req_ch-\u003Eenvironment());\n\n   bool stop = false;\n   select(\n      so_5::from_all()\n         .on_close([&amp;stop](const auto &amp;) { stop = true; })\n         .stop_on([&amp;stop]{ return stop; }),\n\n      case_(req_ch,\n         [&amp;](handle_request cmd) {\n            \u002F\u002F Начинаем обработку запроса сразу, как только получаем его.\n            auto resp = cmd.m_req-\u003Ecreate_response&lt;output_t\u003E();\n\n            resp.append_header( restinio::http_field::server, \"RESTinio\" )\n               .append_header_date_field()\n               .append_header( restinio::http_field::content_type,\n                     \"text\u002Fplain; charset=utf-8\" );\n\n            \u002F\u002F Первая часть ответа сформирована, заставляем RESTinio\n            \u002F\u002F отослать ее клиенту.\n            resp.flush();\n\n            \u002F\u002F Обработку остальных частей откладываем на случайное время.\n            so_5::send_delayed&lt;so_5::mutable_msg&lt;timeout_elapsed\u003E\u003E(delayed_ch,\n                  \u002F\u002F Пауза перед отсылкой следующей части.\n                  std::chrono::milliseconds{pause_generator(generator)},\n                  \u002F\u002F Аргументы для конструктора timeout_elapsed.\n                  \u002F\u002F Обращаем внимание на перемещение response_builder-а внутрь сообщения.\n                  std::move(resp),\n                  3);\n         }),\n\n      case_(delayed_ch,\n         [&amp;](so_5::mutable_mhood_t&lt;timeout_elapsed\u003E cmd) {\n            \u002F\u002F Пришло время сформировать следующую часть ответа.\n            cmd-\u003Em_resp.append_chunk( \"this is the next part of the response\\n\" );\n            \u002F\u002F Заставляем RESTinio отослать ее клиенту.\n            cmd-\u003Em_resp.flush();\n\n            cmd-\u003Em_counter -= 1;\n\n            if( 0 != cmd-\u003Em_counter )\n            {\n               \u002F\u002F Нужно продолжать отсылку частей ответа через случайный интервал.\n               so_5::send_delayed(\n                     delayed_ch,\n                     std::chrono::milliseconds{pause_generator(generator)},\n                     std::move(cmd));\n            }\n            else\n               \u002F\u002F Все, ответ полностью сформирован.\n               cmd-\u003Em_resp.done();\n         })\n   );\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТ.е. здесь ответ начинает формироваться сразу, как только запрос приходит на отдельную рабочую нить. И первая часть сразу же отсылается клиенту. А вот оставшиеся части формируются через случайные интервалы времени.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cstrong\u003EUpd.\u003C\u002Fstrong\u003E С методом \u003Ccode\u003Eflush()\u003C\u002Fcode\u003E такая же ситуация, как и с методом \u003Ccode\u003Edone()\u003C\u002Fcode\u003E: RESTinio инициирует операцию записи, но сама I\u002FO-операция будет выполнена не там, где вызван \u003Ccode\u003Eflush()\u003C\u002Fcode\u003E, а там, где RESTinio выполняет ввод-вывод и вызывает request_handler-ы. Т.е. в данном примере \u003Ccode\u003Eflush()\u003C\u002Fcode\u003E вызывается на отдельной рабочей нити, а операция записи будет выполнена на основной нити, там, где работает \u003Ccode\u003Erestinio::run()\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЕсли запустить данный пример и сделать запрос, то след работы RESTinio будет выглядеть следующим образом:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003E[2019-05-13 15:02:35.106] TRACE: starting server on 127.0.0.1:8080\n[2019-05-13 15:02:35.106]  INFO: init accept #0\n[2019-05-13 15:02:35.106]  INFO: server started on 127.0.0.1:8080\n[2019-05-13 15:02:39.050] TRACE: accept connection from 127.0.0.1:49280 on socket #0\n[2019-05-13 15:02:39.050] TRACE: [connection:1] start connection with 127.0.0.1:49280\n[2019-05-13 15:02:39.050] TRACE: [connection:1] start waiting for request\n[2019-05-13 15:02:39.050] TRACE: [connection:1] continue reading request\n[2019-05-13 15:02:39.050] TRACE: [connection:1] received 78 bytes\n[2019-05-13 15:02:39.050] TRACE: [connection:1] request received (#0): GET \u002F\n[2019-05-13 15:02:39.050] TRACE: [connection:1] append response (#0), flags: { not_final_parts, connection_keepalive }, write group size: 1\n[2019-05-13 15:02:39.050] TRACE: [connection:1] start next write group for response (#0), size: 1\n[2019-05-13 15:02:39.050] TRACE: [connection:1] start response (#0): HTTP\u002F1.1 200 OK\n[2019-05-13 15:02:39.050] TRACE: [connection:1] sending resp data, buf count: 1, total size: 167\n[2019-05-13 15:02:39.050] TRACE: [connection:1] outgoing data was sent: 167 bytes\n[2019-05-13 15:02:39.050] TRACE: [connection:1] finishing current write group\n[2019-05-13 15:02:39.050] TRACE: [connection:1] should keep alive\n[2019-05-13 15:02:40.190] TRACE: [connection:1] append response (#0), flags: { not_final_parts, connection_keepalive }, write group size: 3\n[2019-05-13 15:02:40.190] TRACE: [connection:1] start next write group for response (#0), size: 3\n[2019-05-13 15:02:40.190] TRACE: [connection:1] sending resp data, buf count: 3, total size: 42\n[2019-05-13 15:02:40.190] TRACE: [connection:1] outgoing data was sent: 42 bytes\n[2019-05-13 15:02:40.190] TRACE: [connection:1] finishing current write group\n[2019-05-13 15:02:40.190] TRACE: [connection:1] should keep alive\n[2019-05-13 15:02:43.542] TRACE: [connection:1] append response (#0), flags: { not_final_parts, connection_keepalive }, write group size: 3\n[2019-05-13 15:02:43.542] TRACE: [connection:1] start next write group for response (#0), size: 3\n[2019-05-13 15:02:43.542] TRACE: [connection:1] sending resp data, buf count: 3, total size: 42\n[2019-05-13 15:02:43.542] TRACE: [connection:1] outgoing data was sent: 42 bytes\n[2019-05-13 15:02:43.542] TRACE: [connection:1] finishing current write group\n[2019-05-13 15:02:43.542] TRACE: [connection:1] should keep alive\n[2019-05-13 15:02:46.297] TRACE: [connection:1] append response (#0), flags: { not_final_parts, connection_keepalive }, write group size: 3\n[2019-05-13 15:02:46.297] TRACE: [connection:1] start next write group for response (#0), size: 3\n[2019-05-13 15:02:46.297] TRACE: [connection:1] sending resp data, buf count: 3, total size: 42\n[2019-05-13 15:02:46.297] TRACE: [connection:1] append response (#0), flags: { final_parts, connection_keepalive }, write group size: 1\n[2019-05-13 15:02:46.297] TRACE: [connection:1] outgoing data was sent: 42 bytes\n[2019-05-13 15:02:46.298] TRACE: [connection:1] finishing current write group\n[2019-05-13 15:02:46.298] TRACE: [connection:1] should keep alive\n[2019-05-13 15:02:46.298] TRACE: [connection:1] start next write group for response (#0), size: 1\n[2019-05-13 15:02:46.298] TRACE: [connection:1] sending resp data, buf count: 1, total size: 5\n[2019-05-13 15:02:46.298] TRACE: [connection:1] outgoing data was sent: 5 bytes\n[2019-05-13 15:02:46.298] TRACE: [connection:1] finishing current write group\n[2019-05-13 15:02:46.298] TRACE: [connection:1] should keep alive\n[2019-05-13 15:02:46.298] TRACE: [connection:1] start waiting for request\n[2019-05-13 15:02:46.298] TRACE: [connection:1] continue reading request\n[2019-05-13 15:02:46.298] TRACE: [connection:1] EOF and no request, close connection\n[2019-05-13 15:02:46.298] TRACE: [connection:1] close\n[2019-05-13 15:02:46.298] TRACE: [connection:1] close: close socket\n[2019-05-13 15:02:46.298] TRACE: [connection:1] close: timer canceled\n[2019-05-13 15:02:46.298] TRACE: [connection:1] close: reset responses data\n[2019-05-13 15:02:46.298] TRACE: [connection:1] destructor called\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЗдесь можно увидеть, как RESTinio принимает запрос и сразу же отсылает первую часть ответа размером 167 байт. Затем через разные промежутки времени отсылаются остальные части ответа и, когда клиент получает весь ответ и закрывает соединение со своей стороны, RESTinio закрывает соединение у себя и освобождает связанные с ним ресурсы.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДанный пример показывает, что при использовании RESTinio можно сохранить где-то в прикладном коде объект response_builder и задействовать этот объект тогда, когда появляется возможность сформировать очередную часть ответа клиенту.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ примере я применял отложенные сообщения. Но в реальном коде у нас могут быть, скажем, асинхронные запросы к внешним сервисам. В этом случае мы можем ассоциировать response_builder с асинхронным запросом. Когда ответ на запрос поступит, мы воспользуемся responce_builder для отдачи клиенту части нужной клиенту информации, а сами сделаем асинхронный запрос к следующему сервису и т.д.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПолный код примера можно увидеть \u003Ca href=\"https:\u002F\u002Fgist.github.com\u002Feao197\u002Fe3d93b292dee3967c6a84e2646d7b8ba\"\u003Eздесь\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"chto-budet-esli-obrabotka-zaprosa-zaymet-slishkom-mnogo-vremeni\"\u003EЧто будет, если обработка запроса займет слишком много времени?\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДопустим, в своем request_handler-е мы делегировали обработку запроса какой-то другой рабочей нити. Что произойдет, если эта нить будет настолько занята, что сможет приступить к обработке запроса только через час или два?\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКогда RESTinio отдает запрос на обработку, начинается отсчет тайм-аута для request_handler-а. Как только этот тайм-аут истечет, а ответ не будет сформирован, RESTinio просто напросто закроет соединение на своей стороне. То, что затем будет сформировано в качестве ответа будет проигнорировано. Вот, например:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003E[2019-05-13 15:32:23.618] TRACE: starting server on 127.0.0.1:8080\n[2019-05-13 15:32:23.618]  INFO: init accept #0\n[2019-05-13 15:32:23.618]  INFO: server started on 127.0.0.1:8080\n[2019-05-13 15:32:26.768] TRACE: accept connection from 127.0.0.1:49502 on socket #0\n[2019-05-13 15:32:26.768] TRACE: [connection:1] start connection with 127.0.0.1:49502\n[2019-05-13 15:32:26.768] TRACE: [connection:1] start waiting for request\n[2019-05-13 15:32:26.768] TRACE: [connection:1] continue reading request\n[2019-05-13 15:32:26.768] TRACE: [connection:1] received 78 bytes\n[2019-05-13 15:32:26.768] TRACE: [connection:1] request received (#0): GET \u002F\n[2019-05-13 15:32:30.768] TRACE: [connection:1] handle request timed out\n[2019-05-13 15:32:30.768] TRACE: [connection:1] close\n[2019-05-13 15:32:30.768] TRACE: [connection:1] close: close socket\n[2019-05-13 15:32:30.768] TRACE: [connection:1] close: timer canceled\n[2019-05-13 15:32:30.768] TRACE: [connection:1] close: reset responses data\n[2019-05-13 15:32:31.768]  WARN: [connection:1] try to write response, while socket is closed\n[2019-05-13 15:32:31.768] TRACE: [connection:1] destructor called\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЗдесь истек тайм-аут для обработчика запроса и соединение было закрыто. Затем, когда через секунду ответ попытались записать, то RESTinio проигнорировал эту попытку, т.к. соединения с клиентом уже нет.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EУправлять величиной тайм-аута можно посредством параметра \u003Ccode\u003Ehandle_request_timeout\u003C\u002Fcode\u003E, который задается в параметрах RESTinio-сервера (подробнее \u003Ca href=\"https:\u002F\u002Fstiffstream.com\u002Fen\u002Fdocs\u002Frestinio\u002F0.4\u002Fserversettings.html\"\u003Eздесь\u003C\u002Fa\u003E).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch1 id=\"zaklyuchenie\"\u003EЗаключение\u003C\u002Fh1\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНадеюсь, мне удалось показать, что асинхронная обработка запросов в RESTinio — это не сложно, и не страшно. Так что, если вы решили попробовать RESTinio, то имейте в виду, что асинхронность является одной из основных возможностей RESTinio, поэтому грех от нее отказываться.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНу а если вы смотрели RESTinio и не решились взять наш фреймворк в работу, то поделитесь, пожалуйста, своими соображениями: почему отказались? Чего-то не хватило? Что-то не понравилось? Где-то что-то сделано лучше?\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EPS. На Хабре про RESTinio мы рассказываем пока сильно меньше, чем про SObjectizer, но несколько публикаций было. Так что, если кто-то узнал про RESTinio впервые, то вот некоторые из них: \"\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fpost\u002F345788\u002F\"\u003EТрехэтажные C++ные шаблоны в реализации встраиваемого асинхронного HTTP-сервера с человеческим лицом\u003C\u002Fa\u003E\", \"\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fpost\u002F349728\u002F\"\u003EАсинхронные HTTP-запросы на C++: входящие через RESTinio, исходящие через libcurl. Часть 1\u003C\u002Fa\u003E\", \"\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fpost\u002F416387\u002F\"\u003EShrimp: масштабируем и раздаем по HTTP картинки на современном C++ посредством ImageMagic++, SObjectizer и RESTinio\u003C\u002Fa\u003E\"\u003C\u002Fp\u003E\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"c++"},{"titleHtml":"c++14"},{"titleHtml":"c++ библиотеки"},{"titleHtml":"restinio"},{"titleHtml":"http-сервер"},{"titleHtml":"restful"},{"titleHtml":"restful http"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F451728\u002F0928096eb0c565c935aa0ef65160d156\u002F","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F451728\u002F0928096eb0c565c935aa0ef65160d156\u002F?format=vk","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F451728\\\u002F\"},\"headline\":\"RESTinio — это асинхронный HTTP-сервер. Асинхронный\",\"datePublished\":\"2019-05-14T15:08:16+03:00\",\"dateModified\":\"2019-05-15T17:50:24+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"Евгений Охотников\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"Пару лет назад мы опубликовали RESTinio &mdash; свой небольшой OpenSource C++фреймворк для встраивания HTTP-сервера в C++ приложения. Мегапопулярным за это время RESTi...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F451728\\\u002F#post-content-body\",\"about\":[\"h_open_source\",\"h_programming\",\"h_cpp\",\"f_develop\"],\"image\":[\"https:\\\u002F\\\u002Fhabr.com\\\u002Fshare\\\u002Fpublication\\\u002F451728\\\u002F0928096eb0c565c935aa0ef65160d156\\\u002F\"]}","metaDescription":"Пару лет назад мы опубликовали RESTinio — свой небольшой OpenSource C++фреймворк для встраивания HTTP-сервера в C++ приложения. Мегапопулярным за это время RESTinio не стал, но и не потерялся. Кто-то...","mainImageUrl":null,"amp":false},"polls":[],"commentsEnabled":true,"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":false}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[],"hubs":"open_source,programming,cpp"},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{}},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"dfp":{"slotsDict":{}},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.c0af73e7.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
</body>
</html>
