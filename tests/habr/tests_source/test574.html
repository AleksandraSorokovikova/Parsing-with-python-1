<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <title>QEMU.js: теперь по-серьёзному и с WASM / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.c0af73e7.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.85eb77f0b17c8235e7b64b9f81ea5ec2.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" src="/js/ads.js" onload="window['zhY4i4nJ9K'] = true" data-vmid="checkad"></script><script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/post\/451306\/"},"headline":"QEMU.js: теперь по-серьёзному и с WASM","datePublished":"2019-05-12T18:31:29+03:00","dateModified":"2019-05-14T12:29:17+03:00","author":{"@type":"Person","name":"Анатолий Тросиненко"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"Когда-то давно я смеха ради решил доказать обратимость процесса и научиться генерировать JavaScript (а точнее, Asm.js) из машинного кода. Для эксперимента был вы...","url":"https:\/\/habr.com\/ru\/post\/451306\/#post-content-body","about":["h_crazydev","h_javascript","h_virtualization","h_c","h_webassembly","f_develop","f_admin"],"image":["https:\/\/habr.com\/share\/publication\/451306\/bfa2736941912e0a8d4a4cf2d76b953d\/"]}</script>
  <script src="//www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.49.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_eng"><meta data-vue-meta="ssr" property="og:title" content="QEMU.js: теперь по-серьёзному и с WASM" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="QEMU.js: теперь по-серьёзному и с WASM" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="QEMU.js: теперь по-серьёзному и с WASM" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="Когда-то давно я смеха ради решил доказать обратимость процесса и научиться генерировать JavaScript (а точнее, Asm.js) из машинного кода. Для эксперимента был выбран QEMU, некоторое время спустя была..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="Когда-то давно я смеха ради решил доказать обратимость процесса и научиться генерировать JavaScript (а точнее, Asm.js) из машинного кода. Для эксперимента был выбран QEMU, некоторое время спустя была..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="Когда-то давно я смеха ради решил доказать обратимость процесса и научиться генерировать JavaScript (а точнее, Asm.js) из машинного кода. Для эксперимента был выбран QEMU, некоторое время спустя была..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="Когда-то давно я смеха ради решил доказать обратимость процесса и научиться генерировать JavaScript (а точнее, Asm.js) из машинного кода. Для эксперимента был выбран QEMU, некоторое время спустя была..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="Когда-то давно я смеха ради решил доказать обратимость процесса и научиться генерировать JavaScript (а точнее, Asm.js) из машинного кода. Для эксперимента был выбран QEMU, некоторое время спустя была..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habr.com/share/publication/451306/bfa2736941912e0a8d4a4cf2d76b953d/" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habr.com/share/publication/451306/bfa2736941912e0a8d4a4cf2d76b953d/" data-vmid="og:image"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habr.com/share/publication/451306/bfa2736941912e0a8d4a4cf2d76b953d/" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habr.com/share/publication/451306/bfa2736941912e0a8d4a4cf2d76b953d/" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habr.com/share/publication/451306/bfa2736941912e0a8d4a4cf2d76b953d/" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="451306" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2019-05-12T15:31:29.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/451306/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="https://habr.com/ru/post/451306/" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habr.com/share/publication/451306/bfa2736941912e0a8d4a4cf2d76b953d/" data-vmid="image:href">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="/ru/sandbox/start/" class="tm-header__become-author-btn">
            Как стать автором
          </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="/ru/all/" class="tm-main-menu__item">
        Все потоки
      </a> <a href="/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" data-async-called="true" class="tm-page"><div class="tm-page-width"><!----> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="/ru/users/atrosinenko/" title="atrosinenko" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="" height="24" loading="lazy" src="//habrastorage.org/r/w32/getpro/habr/avatars/8f8/f3e/46b/8f8f3e46bca8b92fefc6717372c219bb.png" width="24" class="tm-entity-image__pic"></div></a> <span class="tm-user-info__user"><a href="/ru/users/atrosinenko/" class="tm-user-info__username">
      atrosinenko
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2019-05-12T15:31:29.000Z" title="2019-05-12, 18:31">12  мая  2019 в 18:31</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>QEMU.js: теперь по-серьёзному и с WASM</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/crazydev/" class="tm-article-snippet__hubs-item-link"><span>Ненормальное программирование</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/javascript/" class="tm-article-snippet__hubs-item-link"><span>JavaScript</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/virtualization/" class="tm-article-snippet__hubs-item-link"><span>Виртуализация</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/c/" class="tm-article-snippet__hubs-item-link"><span>C</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/webassembly/" class="tm-article-snippet__hubs-item-link"><span>WebAssembly</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span></div> <!----> <!----> <!----></div></div> <!----> <div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-1"><div xmlns="http://www.w3.org/1999/xhtml"><p>Когда-то давно я смеха ради решил <em>доказать обратимость процесса</em> и научиться генерировать JavaScript (а точнее, Asm.js) из машинного кода. Для эксперимента был выбран QEMU, некоторое время спустя была написана статья на Хабр. В комментариях мне посоветовали переделать проект на WebAssembly, да и самому бросать <em>почти законченный</em> проект как-то не хотелось… Работа шла, но уж очень медленно, и вот, недавно в той статье появился <a href="https://habr.com/ru/post/315770/#comment_20090916">комментарий</a> на тему «Так и чем всё закончилось?». На мой развёрнутый ответ я услышал «Это тянет на статью». Ну, раз тянет, то будет статья. Может, кому пригодится. Из неё читатель узнает некоторые факты про устройство бекендов кодогенерации QEMU, а также как написать Just-in-Time компилятор для веб-приложения.</p><a name="habracut"></a><br/>
<h2 id="zadachi">Задачи</h2><br/>
<p>Поскольку «кое-как» портировать QEMU на JavaScript я уже научился, в этот раз было решено делать по уму и не повторять старых ошибок.</p><br/>
<h3 id="oshibka-nomer-raz-otvetvitsya-ot-point-release">Ошибка номер раз: ответвиться от point release</h3><br/>
<p>Первой моей ошибкой было ответвить свою версию от upstream-версии 2.4.1. Тогда мне казалось это хорошей идеей: если point release существует, значит он, наверное, стабильнее простого 2.4, а уж тем более ветки <code>master</code>. А поскольку я планировал добавить изрядное количество своих багов, то чужие мне были ну вообще не нужны. Так оно, наверное, и получилось. Но вот незадача: QEMU не стоит на месте, а в какой-то момент там даже анонсировали оптимизацию генерируемого кода процентов на 10. «Ага, сейчас вмёржу» подумал я <del>и обломался</del>. Тут надо сделать отступление: в связи с однопоточным характером QEMU.js и тем, что оригинальный QEMU не предполагает отсутствия многопоточности (то есть для него критична возможность одновременной работы нескольких несвязанных code path, а не просто «заюзать все ядра»), главные функции потоков пришлось «вывернуть» для возможности вызова снаружи. Это создало некие естественные проблемы при слиянии. Однако тот факт, что часть изменений из ветки <code>master</code>, с которой я пытался слить свой код, также были cherry picked в point release (а значит, и в мою ветку) тоже, вероятно, удобства бы не добавил.</p><br/>
<p>В общем, я решил, что всё равно прототип имеет смысл <del>выкинуть</del> разобрать на запчасти и построить новую версию с нуля на базе чего-нибудь посвежее и теперь уже из <code>master</code>.</p><br/>
<h3 id="oshibka-nomer-dva-tlp-metodologiya">Ошибка номер два: ТЛП-методология</h3><br/>
<p>В сущности, это и не ошибка, в общем-то — просто особенность создания проекта в условиях полного непонимания как «куда и как двигаться?», так и вообще «а дойдём ли?». В этих условиях <em>тяп-ляп программирование</em> было оправданным вариантом, но, естественно, совершенно не хотелось это повторять без необходимости. В этот раз хотелось сделать по уму: атомарные коммиты, осознанные изменения кода (а не «stringing random characters together until it compiles (with warnings)», как про кого-то однажды сказал Линус Торвальдс, если верить Викицитатнику) и т.д.</p><br/>
<h3 id="oshibka-nomer-tri-ne-znaya-brodu-lezt-v-vodu">Ошибка номер три: не зная броду лезть в воду</h3><br/>
<p>От этого я и сейчас до конца не избавился, но теперь решил идти не по пути совсем уж наименьшего сопротивления, и сделать «по взрослому», а именно, написать свой TCG backend с нуля, чтобы потом не говорить, мол «Да, это, конечно, медленно, но я же не могу всё контролировать — TCI так написан...». Кроме того, изначально это казалось очевидным решением, поскольку <em>я же бинарный код генерирую</em>. Как говорится, «Собрал Гент<strong>у</strong>, да не ту»: код-то, конечно, бинарный, но управление на него просто так не передать — его нужно явным образом запихнуть в браузер на компиляцию, получив в результате некий объект из мира JS, который ещё нужно куда-то сохранить. Впрочем, на <del>нормальных</del>RISC-архитектурах, насколько я понимаю, типичной ситуацией является необходимость явно сбросить кеш инструкций для перегенерированного кода — если это и не то, что нам нужно, то, во всяком случае, близко. Кроме того, из прошлой своей попытки я усвоил, что управление на середину блока трансляции вроде как не передаётся, поэтому байткод, интерпретируемый с любого смещения, нам особо и не нужен, и можно просто генерировать по функции на TB.</p><br/>
<h2 id="prishli-i-pnuli">Пришли и пнули</h2><br/>
<p>Хотя переписывать код я начал ещё в июле, но волшебный пендель подкрался незаметно: обычно письма с GitHub приходят как уведомления об ответах на Issues и Pull requests, а тут, <em>внезапно</em> упоминание в треде <a href="https://github.com/WebAssembly/binaryen/issues/1494">Binaryen as a qemu backend</a> в контексте, «Вот он что-то подобное делал, может скажет что-нибудь». Речь шла об использовании родственной Emscripten-у библиотеки <a href="https://github.com/WebAssembly/binaryen">Binaryen</a> для создания WASM JIT. Ну я и сказал, что у вас там лицензия Apache 2.0, а QEMU как единое целое распространяется под GPLv2, и они не очень совместимые. Внезапно оказалось, что лицензию можно <em>как-то поправить</em> (не знаю: может, поменять, может, двойное лицензирование, может, ещё что-то...). Это меня, конечно, обрадовало, потому что я уже несколько раз к тому времени присматривался к <a href="http://webassembly.github.io/spec/core/binary/index.html">бинарному формату</a> WebAssembly, и мне было как-то грустно и непонятно. Здесь же была библиотека, которая и базовые блоки с графом переходов сожрёт, и байткод выдаст, и даже сама его запустит в интерпретаторе, если потребуется.</p><br/>
<p>Потом ещё было <a href="https://marc.info/?l=qemu-devel&amp;m=154688067607265&amp;w=2">письмо</a> в списке рассылки QEMU, но это уже скорее к вопросу, «А кому оно вообще надо?». А оно, <strong>внезапно</strong>, оказалось надо. Как минимум, можно наскрести такие возможности использования, если оно будет более-менее шустро работать:</p><br/>
<ul>
<li>запуск чего-нибудь обучающего вообще без установки</li>
<li>виртуализация на iOS, где по слухам единственное приложение, имеющее право на кодогенерацию на лету — это JS-движок (а правда ли это?)</li>
<li>демонстрация мини-ОС — однодискетные, встроенные, всякие прошивки и т.д...</li>
</ul><br/>
<h2 id="osobennosti-brauzernoy-sredy-vypolneniya">Особенности браузерной среды выполнения</h2><br/>
<p>Как я уже говорил, QEMU завязан на многопоточность, а в браузере её нет. Ну, то есть как нет… Сначала её не было вообще, потом появились WebWorkers — насколько я понимаю, это многопоточность, основанная на передаче сообщений <strong>без совместно изменяемых переменных</strong>. Естественно, это создаёт значительные проблемы при портировании существующего кода, основанного на shared memory модели. Потом под давлением общественности была реализована и она под названием <code>SharedArrayBuffers</code>. Её постепенно ввели, отпраздновали её запуск в разных браузерах, потом отпраздновали новый год, а потом Meltdown… После чего пришли к выводу, что загрубляй-не загрубляй измерение времени, а с помощью shared memory и потока, инкрементирующего счётчик, всё равно <a href="https://security.stackexchange.com/questions/177033/how-can-sharedarraybuffer-be-used-for-timing-attacks">довольно точно получится</a>. Так и отключили многопоточность с общей памятью. Вроде бы, её потом включали обратно, но, как стало понятно из первого эксперимента, и без неё жизнь есть, а раз так, то попробуем сделать, не закладываясь на многопоточность.</p><br/>
<p>Вторая особенность заключается в невозможности низкоуровневых манипуляций со стеком: нельзя просто взять, сохранить текущий контекст и переключиться на новый с новым стеком. Стек вызовов управляется виртуальной машиной JS. Казалось бы, в чём проблема, раз уж мы всё равно решили управляться с бывшими потоками полностью вручную? Дело в том, что блочный ввод-вывод в QEMU реализован через корутины, и вот тут бы нам и пригодились низкоуровневые манипуляции стеком. К счастью, Emscipten уже содержит механизм для асинхронных операций, даже два: <a href="https://emscripten.org/docs/porting/asyncify.html">Asyncify</a> и <a href="https://emscripten.org/docs/porting/emterpreter.html">Emterpreter</a>. Первый работает через значительное раздувание генерируемого JavaScript-кода и уже не поддерживается. Второй является текущим «правильным способом» и работает через генерацию байткода для собственного интерпретатора. Работает, конечно, медленно, но зато не раздувает код. Правда, поддержку корутин для этого механизма пришлось контрибутить самостоятельно (там уже были корутины, написанные под Asyncify и была реализация приблизительно того же API для Emterpreter, нужно было просто их соединить).</p><br/>
<p>На данный момент я ещё не успел разделить код на компилируемый в WASM и интерпретируемый с помощью Emterpreter, поэтому блочные устройства ещё не работают (смотрите в следующих сериях, как говорится...). То есть, в итоге должно получиться вот такое забавное слоистое нечто:</p><br/>
<ul>
<li>интерпретируемый блочный ввод-вывод. Ну а что, вы правда ожидали эмулируемый NVMe с нативной производительностью? :)</li>
<li>статически скомпилированный основной код QEMU (транслятор, остальные эмулируемые устройства и т.д.)</li>
<li>динамически компилируемый в WASM гостевой код</li>
</ul><br/>
<h2 id="osobennosti-ishodnikov-qemu">Особенности исходников QEMU</h2><br/>
<p>Как вы, наверное, уже догадались, код эмуляции гостевых архитектур и код генерации хостовых машинных инструкций у QEMU разделён. На самом деле, там даже ещё чуть хитрее:</p><br/>
<ul>
<li>есть гостевые архитектуры</li>
<li>есть <em>акселераторы</em>, а именно, KVM для аппаратной виртуализации на Linux (для совместимых между собой гостевых и хостовых систем), TCG для JIT-кодогенерации где попало. Начиная с QEMU 2.9 появилась поддержка стандарта аппаратной виртуализации HAXM на Windows (<a href="https://wiki.qemu.org/Hosts/W32">подробности</a>)</li>
<li>если используется TCG, а не аппаратная виртуализация, то у него есть отдельная поддержка кодогенерации под каждую хостовую архитектуру, а также под универсальный интерпретатор</li>
<li>… а вокруг всего этого — эмулируемая периферия, пользовательский интерфейс, миграция, record-replay, и т.д.</li>
</ul><br/>
<p><em>Кстати, знаете ли вы:</em> QEMU может эмулировать не только компьютер целиком, но и процессор для отдельного пользовательского процесса в хостовом ядре, чем пользуется, например, фаззер AFL для инструментации бинарников. Возможно, кто-то захочет портировать этот режим работы QEMU на JS? ;)</p><br/>
<p>Как и большинство давно существующих свободных программ, QEMU собирается через вызов <code>configure</code> и <code>make</code>. Предположим, вы решили что-то добавить: TCG-бекенд, реализацию потоков, что-то ещё. Не спешите радоваться/ужасаться (нужное подчеркнуть) перспективе общения с Autoconf — на самом деле, <code>configure</code> у QEMU, по всей видимости, самописный и не из чего не генерируется.</p><br/>
<h2 id="webassembly">WebAssembly</h2><br/>
<p>Так что же это за штука — WebAssembly (он же WASM)? Это замена Asm.js, теперь уже не прикидывающаяся валидным JavaScript кодом. Напротив, оно сугубо бинарное и оптимизированное, и даже просто записать в него целое число не очень-то и просто: оно для компактности хранится в формате <a href="https://en.wikipedia.org/wiki/LEB128">LEB128</a>.</p><br/>
<p>Возможно, вы слышали об алгоритме relooping для Asm.js — это восстановление «высокоуровневых» инструкций управления потоком выполнения (то есть if-then-else, циклы и т.д.), под которые заточены JS-движки, из низкоуровневого LLVM IR, более близкого к машинному коду, выполняемому процессором. Естественно, промежуточное представление QEMU ближе ко второму. Казалось бы, вот он, байткод, конец мучений… И тут блоки, if-then-else и циклы!..</p><br/>
<p>И в этом заключается ещё одна причина, почему полезен Binaryen: он, естественно, может принимать высокоуровневые блоки, близкие к тому, что будет сохранено в WASM. Но также он может выдавать код из графа базовых блоков и переходов между ними. Ну а о том, что он скрывает за удобным C/C++ API формат хранения WebAssembly, я уже сказал.</p><br/>
<h2 id="tcg-tiny-code-generator">TCG (Tiny Code Generator)</h2><br/>
<p>TCG <a href="https://github.com/qemu/qemu/blob/master/tcg/README">изначально был</a> бекендом для компилятора C. Потом он, видимо, не выдержал конкуренции с GCC, но в итоге нашёл своё место в составе QEMU в качестве механизма кодогенерации под хостовую платформу. Также есть и TCG-бекенд, генерирующий некий абстрактный байткод, который тут же и исполняет интерпретатор, но от его использования я решил уйти в этот раз. Впрочем, тот факт, что в QEMU уже есть возможность включить переход на сгенерированный TB через функцию <code>tcg_qemu_tb_exec</code>, мне оказался очень кстати.</p><br/>
<p>Чтобы добавить новый TCG-бекенд в QEMU, нужно создать подкаталог <code>tcg/&lt;имя архитектуры></code> (в данном случае, <code>tcg/binaryen</code>), а в нём два файла: <code>tcg-target.h</code> и <code>tcg-target.inc.c</code> и <a href="https://github.com/atrosinenko/qemujs/blob/abeace64b1e5b52a6ab17bdd4a0e08eb911e98d2/configure#L6827">прописать</a> всё это дело в <code>configure</code>. Можно положить туда и другие файлы, но, как можно догадаться из названий этих двух, они оба будут куда-то включаться: один как обычный заголовочный файл (он инклудится в <code>tcg/tcg.h</code>, а тот уже в другие файлы в каталогах <code>tcg</code>, <code>accel</code> и не только), другой — только как code snippet в <code>tcg/tcg.c</code>, зато он имеет доступ к его static-функциям.</p><br/>
<p>Решив, что я потрачу слишком много времени на детальные разбирательства, как оно устроено, я просто скопировал «скелеты» этих двух файлов из другой реализации бекенда, честно указав это в заголовке лицензии.</p><br/>
<p>Файл <code>tcg-target.h</code> содержит преимущественно настройки в виде <code>#define</code>-ов:</p><br/>
<ul>
<li>сколько регистров и какой ширины есть на целевой архитектуре (у нас — сколько хотим, столько и есть — вопрос больше того, что будет генерироваться в более эффективный код браузером на «совсем целевой» архитектуре...)</li>
<li>выравнивание хостовых инструкций: на x86, да и в TCI, инструкции вообще не выравниваются, я же собираюсь класть в буфер кода и не инструкции вовсе, а указатели на структуры библиотеки Binaryen, поэтому скажу: 4 байта</li>
<li>какие опциональные инструкции может генерировать бекенд — включаем всё, что найдём в Binaryen, остальное пусть акселератор разбивает на более простые сам</li>
<li>какой приблизительно размер TLB-кеша запрашивает бекенд. Дело в том, что в QEMU всё по-серьёзному: хотя и есть функции-помощники, осуществляющие load/store с учётом гостевого MMU (а куда сейчас без него?), но свой кеш трансляции они сохраняют в виде структуры, обработку которой удобно встраивать прямо в блоки трансляции. Вопрос же в том, какое смещение в этой структуре наиболее эффективно обрабатывается маленькой и быстрой последовательностью команд</li>
<li>здесь же можно подкрутить назначение одного-двух зарезервированных регистров, включить вызов TB через функцию и опционально описать пару мелких <code>inline</code>-функций вроде <code>flush_icache_range</code> (но это не наш случай)</li>
</ul><br/>
<p>Файл <code>tcg-target.inc.c</code>, естественно, обычно намного больше по размеру и содержит несколько обязательных функций:</p><br/>
<ul>
<li>инициализация, указывающая в том числе ограничения на то, какая инструкция с какими операндами может работать. Нагло скопирована мною из другого бекенда</li>
<li>функция, принимающая одну инструкцию внутреннего байткода</li>
<li>сюда же можно положить вспомогательные функции, а также здесь можно пользоваться статическими функциями из <code>tcg/tcg.c</code></li>
</ul><br/>
<p>Для себя я избрал следующую стратегию: в первых словах очередного блока трансляции я записывал четыре указателя: метку начала (некое значение в окрестности <code>0xFFFFFFFF</code>, по которому определялось текущее состояние TB), контекст, сгенерированный модуль, и magic number для отладки. Сначала метка выставлялась в <code>0xFFFFFFFF - n</code>, где <code>n</code> — небольшое положительное число, и при каждом выполнении через интерпретатор увеличивалась на 1. Когда она доходила до <code>0xFFFFFFFE</code>, происходила компиляция, модуль сохранялся в таблице функций, импортированной в небольшой «запускатор», в который и уходило выполнение из <code>tcg_qemu_tb_exec</code>, а модуль удалялся из памяти QEMU.</p><br/>
<p>Перефразируя классику, «Костыль, как много в этом звуке для сердца прогера сплелось...». Тем не менее, память куда-то утекала. Причём это была память, управляемая QEMU! У меня был код, который при записи очередной инструкции (ну, то есть, указателя) удалял ту, ссылка на которую была на этом месте ранее, но это не помогало. Вообще-то, в простейшем случае QEMU выделяет при старте память и пишет туда генерируемый код. Когда буфер заканчивается, код выкидывается, и на его место начинает записываться следующий.</p><br/>
<p>Поизучав код, я понял, что костыль с magic number позволял не упасть на разрушении кучи, освободив что-нибудь не то на неинициализированном буфере при первом проходе. Но кто переписывает буфер в обход моей функции потом? Как и советуют разработчики Emscripten, упёршись в проблему, я портировал получившийся код обратно в нативное приложение, натравил на него Mozilla Record-Replay… В общем, в итоге я понял простую вещь: для каждого блока выделяется <code>struct TranslationBlock</code> с его описанием. Угадайте, где… Правильно, непосредственно перед блоком прямо в буфере. Осознав это, я решил завязывать с костылями (хотя бы некоторыми), и просто выкинул magic number, а оставшиеся слова перенёс в <code>struct TranslationBlock</code>, заведя односвязный список, по которому можно быстро пройтись при сбросе кеша трансляции, и освободить память.</p><br/>
<p>Некоторые костыли остались: например, помеченные указатели в буфере кода — часть из них просто являются <code>BinaryenExpressionRef</code>, то есть смотрят на выражения, которые нужно линейно положить в генерируемый базовый блок, часть — условие перехода между ББ, часть — куда переходить. Ну и есть уже подготовленные блоки для Relooper, которые нужно соединить по условиям. Чтобы их различать, используется предположение, что все они выровнены хотя бы на четыре байта, поэтому можно спокойно использовать младшие два бита под метку, нужно только не забывать её убирать при необходимости. Кстати, такие метки уже используются в QEMU для обозначения причины выхода из цикла TCG.</p><br/>
<h2 id="ispolzovanie-binaryen">Использование Binaryen</h2><br/>
<p>Модули в WebAssembly содержат функции, каждая из которых содержит тело, представляющее из себя выражение. Выражения — это унарные и бинарные операции, блоки, состоящие из списков других выражений, control flow и т.д. Как я уже говорил, control flow здесь организуется именно как высокоуровневые ветвления, циклы, вызовы функций и т.д. Аргументы функциям передаются не на стеке, а явно, как и в JS. Есть и глобальные переменные, но я их не использовал, поэтому про них не расскажу.</p><br/>
<p>Также у функций есть нумерованные с нуля локальные переменные, имеющие тип: int32 / int64 / float / double. При этом первые n локальных переменных — это переданные функции аргументы. Обратите внимание, что хоть здесь всё и не совсем низкоуровневое в плане потока управления, но целые числа всё же не несут в себе признак «знаковое/беззнаковое»: как будет вести себя число, зависит от кода операции.</p><br/>
<p>Вообще говоря, Binaryen предоставляет <a href="https://github.com/WebAssembly/binaryen/wiki/Compiling-to-WebAssembly-with-Binaryen#c-api">простой C-API</a>: вы создаёте модуль, <strong>в нём</strong> создаёте выражения — унарные, бинарные, блоки из других выражений, control flow и т.д. Потом вы создаёте функцию, в качестве тела которой нужно указать выражение. Если у вас, как и у меня, есть низкоуровневый граф переходов — вам поможет компонент relooper. Насколько я понимаю, использовать высокоуровневое управление потоком выполнения в блоке можно, покуда оно не выходит за пределы блока — то есть сделать внутреннее ветвление fast path / slow path внутри встроенного кода обработки TLB-кеша можно, но вмешиваться в «наружный» поток управления — нет. Когда вы освобождаете relooper, освобождаются его блоки, когда освобождаете модуль — исчезают выражения, функции и т.д., выделенные в его <em>арене</em>.</p><br/>
<p>Впрочем, если вы хотите интерпретировать код на ходу без лишних созданий и удалений экземпляра интерпретатора, может иметь смысл вынести эту логику в файл на C++, и оттуда непосредственно управлять всем C++ API библиотеки, минуя готовые обёртки.</p><br/>
<p>Таким образом, чтобы сгенерировать код, нужно</p><br/>
<pre><code class="cpp">// настроить глобальные параметры (можно поменять потом)
BinaryenSetAPITracing(0);

BinaryenSetOptimizeLevel(3);
BinaryenSetShrinkLevel(2);

// создать модуль
BinaryenModuleRef MODULE = BinaryenModuleCreate();

// описать типы функций (как создаваемых, так и вызываемых)
helper_type  BinaryenAddFunctionType(MODULE, "helper-func", BinaryenTypeInt32(), int32_helper_args, ARRAY_SIZE(int32_helper_args));
// (int23_helper_args приоб^Wсоздаются отдельно)

// сконструировать супер-мега выражение
// ... ну тут уж вы как-нибудь сами :)

// потом создать функцию
BinaryenAddFunction(MODULE, "tb_fun", tb_func_type, func_locals, FUNC_LOCALS_COUNT, expr);
BinaryenAddFunctionExport(MODULE, "tb_fun", "tb_fun");
...
BinaryenSetMemory(MODULE, (1 &lt;&lt; 15) - 1, -1, NULL, NULL, NULL, NULL, NULL, 0, 0);
BinaryenAddMemoryImport(MODULE, NULL, "env", "memory", 0);
BinaryenAddTableImport(MODULE, NULL, "env", "tb_funcs");

// запросить валидацию и оптимизацию при желании
assert (BinaryenModuleValidate(MODULE));
BinaryenModuleOptimize(MODULE);</code></pre><br/>
<p>… если что забыл — извините, это просто чтобы представлять масштабы, а подробности — они в документации.</p><br/>
<p>А теперь начинается крекс-фекс-пекс, примерно такой:</p><br/>
<pre><code class="cpp">static char buf[1 &lt;&lt; 20];
BinaryenModuleOptimize(MODULE);
BinaryenSetMemory(MODULE, 0, -1, NULL, NULL, NULL, NULL, NULL, 0, 0);
int sz = BinaryenModuleWrite(MODULE, buf, sizeof(buf));
BinaryenModuleDispose(MODULE);
EM_ASM({
  var module = new WebAssembly.Module(new Uint8Array(wasmMemory.buffer, $0, $1));
  var fptr = $2;
  var instance = new WebAssembly.Instance(module, {
      'env': {
          'memory': wasmMemory,
          // ...
      }
  );
  // и вот уже у вас есть instance!
}, buf, sz);</code></pre><br/>
<p>Чтобы как-то связать между собой мир QEMU и JS и при этом заходить в скомпилированные функции быстро, был создан массив (таблица функций для импорта в запускатор), и туда клались сгенерированные функции. Чтобы быстро вычислять индекс, в качестве него изначально использовался индекс нулевого слова translation block, но потом индекс, вычисленный по такой формуле стал просто вписываться в поле в <code>struct TranslationBlock</code>.</p><br/>
<p>Кстати, <a href="https://atrosinenko.github.io/qemujs-demo/new/shell.html">демо</a> <em>(пока что с мутной лицензией)</em> работает нормально только в Firefox. Разработчики Chrome были <em>как-то не готовы</em> к тому, что кто-то захочет создавать более тысячи инстансов модулей WebAssembly, поэтому просто выделяли по гигабайту виртуального адресного пространства на каждый...</p><br/>
<p>Пока что на этом всё. Возможно, будет ещё одна статья, если она кому-то интересна. А именно, осталось как минимум <em>всего лишь</em> заставить работать блочные устройства. Возможно, имеет смысл также сделать компиляцию WebAssembly модулей асинхронной, как это и принято в мире JS, раз уж всё равно имеется интерпретатор, который может это всё выполнять, пока нативный модуль не готов.</p><br/>
<p><strong><strong>Напоследок загадка:</strong></strong> вы собрали бинарник на 32-битной архитектуре, но код через операции с памятью лезет из Binaryen, куда-то на стек или ещё куда-то в верхние 2 Гб 32-битного адресного пространства. Проблема в том, что с точки зрения Binaryen это обращение по слишком большому результирующему адресу. Как это обойти?</p><br/>
<div class="spoiler"><b class="spoiler_title">По-админски</b><div class="spoiler_text"><p>Я это в итоге не тестировал, но первая мысль была «А что, если поставить 32-битный Linux?» Тогда верхняя часть адресного пространства будет занята ядром. Вопрос только в том, сколько будет занято: 1 или 2 Gb.</p></div></div><br/>
<div class="spoiler"><b class="spoiler_title">По-программистски (вариант для практиков)</b><div class="spoiler_text"><p>Надуем пузырь в верхней части адресного пространства. Я сам не понимаю, почему оно работает — там же <strong>уже</strong> должен быть стек. Но «мы практики: у нас всё работает, но никто не знает почему...».</p><br/>
<pre><code class="cpp">// 2gbubble.c
// Usage: LD_PRELOAD=2gbubble.so &lt;program>

#include &lt;sys/mman.h>
#include &lt;assert.h>

void __attribute__((constructor)) constr(void)
{
  assert(MAP_FAILED != mmap(1u >> 31, (1u >> 31) - (1u >> 20), PROT_NONE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0));
}</code></pre><br/>
<p>… с Valgrind-ом, правда, не совместимо, но, к счастью, Valgrind сам очень эффективно оттуда всех вытесняет :)</p><br/>
<p><em>Возможно, кто-то даст лучшее объяснение, как работает этот мой код...</em></p></div></div></div></div> <!----> <!----></div> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bqemu%5D" class="tm-tags-list__link">qemu</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bqemu.js%5D" class="tm-tags-list__link">qemu.js</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bwebassembly%5D" class="tm-tags-list__link">webassembly</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bwasm%5D" class="tm-tags-list__link">wasm</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bjit%5D" class="tm-tags-list__link">jit</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Btcg%5D" class="tm-tags-list__link">tcg</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/hub/crazydev/" class="tm-hubs-list__link">
    Ненормальное программирование
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/javascript/" class="tm-hubs-list__link">
    JavaScript
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/virtualization/" class="tm-hubs-list__link">
    Виртуализация
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/c/" class="tm-hubs-list__link">
    C
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/webassembly/" class="tm-hubs-list__link">
    WebAssembly
  </a></li></ul></div></div></article></div> <!----></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_medium"><title>Всего голосов 55: ↑55 и ↓0</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-rating"></use></svg> <span title="Всего голосов 55: ↑55 и ↓0" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_medium">+55</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">12K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    60
  </span></button> <!----> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> </div></div> <!----> <!----> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="/ru/users/atrosinenko/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><img alt="" src="//habrastorage.org/getpro/habr/avatars/8f8/f3e/46b/8f8f3e46bca8b92fefc6717372c219bb.png" class="tm-entity-image__pic"></div></a> <div class="tm-user-card__meta"><div title=" 111 голосов " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    111
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">0</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title_variant-article"><span class="tm-user-card__name tm-user-card__name_variant-article">Анатолий Тросиненко</span> <a href="/ru/users/atrosinenko/" class="tm-user-card__nickname tm-user-card__nickname_variant-article">
          @atrosinenko
        </a> <!----></div> <p class="tm-user-card__short-info tm-user-card__short-info_variant-article">Программист</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-article"><!----> <!----> <!----> <!----> <!----></div></div> <div class="tm-article-author__user-contacts"><a href="https://atrosinenko.github.io/" rel="noopener" target="_blank" class="tm-article-author__contact">
      Сайт
    </a><a href="https://vk.com/anatoly.trosinenko" rel="noopener" target="_blank" class="tm-article-author__contact">
      ВКонтакте
    </a><a href="https://github.com/atrosinenko/" rel="noopener" target="_blank" class="tm-article-author__contact">
      Github
    </a></div></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----></section> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="/ru/post/451306/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментарии 8 
    </span></a> <!----></div></div></div> <div class="tm-ad-banner__container tm-page-article__banner"><!----> <div id="articleBottomBanner" class="tm-ad-banner"></div></div> <!----> <!----> <!----> <!----> </div></div></div></div></div> <div class="tm-page__sidebar"><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__ads tm-layout-sidebar__ads_initial"><div class="tm-ad-banner__container tm-layout-sidebar__banner"><!----> <div id="sidebarBanner" class="tm-ad-banner"></div></div></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----> <!----></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/post/451306/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/post/451306/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2021 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"451306":{"id":"451306","timePublished":"2019-05-12T15:31:29+00:00","isCorporative":false,"lang":"ru","titleHtml":"QEMU.js: теперь по-серьёзному и с WASM","leadData":{"textHtml":"\u003Cp\u003EКогда-то давно я смеха ради решил \u003Cem\u003Eдоказать обратимость процесса\u003C\u002Fem\u003E и научиться генерировать JavaScript (а точнее, Asm.js) из машинного кода. Для эксперимента был выбран QEMU, некоторое время спустя была написана статья на Хабр. В комментариях мне посоветовали переделать проект на WebAssembly, да и самому бросать \u003Cem\u003Eпочти законченный\u003C\u002Fem\u003E проект как-то не хотелось… Работа шла, но уж очень медленно, и вот, недавно в той статье появился \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F315770\u002F#comment_20090916\"\u003Eкомментарий\u003C\u002Fa\u003E на тему «Так и чем всё закончилось?». На мой развёрнутый ответ я услышал «Это тянет на статью». Ну, раз тянет, то будет статья. Может, кому пригодится. Из неё читатель узнает некоторые факты про устройство бекендов кодогенерации QEMU, а также как написать Just-in-Time компилятор для веб-приложения.\u003C\u002Fp\u003E","imageUrl":null,"buttonTextHtml":"Читать дальше →","image":null},"editorVersion":"1.0","postType":"article","postLabels":[],"author":{"scoreStats":{"score":111,"votesCount":111},"rating":0,"relatedData":null,"contacts":[{"title":"Сайт","url":"https:\u002F\u002Fatrosinenko.github.io\u002F","value":"https:\u002F\u002Fatrosinenko.github.io\u002F"},{"title":"ВКонтакте","url":"https:\u002F\u002Fvk.com\u002Fanatoly.trosinenko","value":"anatoly.trosinenko"},{"title":"Github","url":"https:\u002F\u002Fgithub.com\u002Fatrosinenko\u002F","value":"atrosinenko"}],"authorContacts":[{"title":"Сайт","url":"https:\u002F\u002Fatrosinenko.github.io\u002F","value":"https:\u002F\u002Fatrosinenko.github.io\u002F"},{"title":"ВКонтакте","url":"https:\u002F\u002Fvk.com\u002Fanatoly.trosinenko","value":"anatoly.trosinenko"},{"title":"Github","url":"https:\u002F\u002Fgithub.com\u002Fatrosinenko\u002F","value":"atrosinenko"}],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"1354288","alias":"atrosinenko","fullname":"Анатолий Тросиненко","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F8f8\u002Ff3e\u002F46b\u002F8f8f3e46bca8b92fefc6717372c219bb.png","speciality":"Программист"},"statistics":{"commentsCount":8,"favoritesCount":60,"readingCount":11536,"score":55,"votesCount":55},"hubs":[{"relatedData":null,"id":"84","alias":"crazydev","type":"collective","title":"Ненормальное программирование","titleHtml":"Ненормальное программирование","isProfiled":true},{"relatedData":null,"id":"357","alias":"javascript","type":"collective","title":"JavaScript","titleHtml":"JavaScript","isProfiled":true},{"relatedData":null,"id":"7312","alias":"virtualization","type":"collective","title":"Виртуализация","titleHtml":"Виртуализация","isProfiled":true},{"relatedData":null,"id":"17717","alias":"c","type":"collective","title":"C","titleHtml":"C","isProfiled":true},{"relatedData":null,"id":"22083","alias":"webassembly","type":"collective","title":"WebAssembly","titleHtml":"WebAssembly","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"},{"id":"6","alias":"admin","title":"Администрирование"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Cp\u003EКогда-то давно я смеха ради решил \u003Cem\u003Eдоказать обратимость процесса\u003C\u002Fem\u003E и научиться генерировать JavaScript (а точнее, Asm.js) из машинного кода. Для эксперимента был выбран QEMU, некоторое время спустя была написана статья на Хабр. В комментариях мне посоветовали переделать проект на WebAssembly, да и самому бросать \u003Cem\u003Eпочти законченный\u003C\u002Fem\u003E проект как-то не хотелось… Работа шла, но уж очень медленно, и вот, недавно в той статье появился \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F315770\u002F#comment_20090916\"\u003Eкомментарий\u003C\u002Fa\u003E на тему «Так и чем всё закончилось?». На мой развёрнутый ответ я услышал «Это тянет на статью». Ну, раз тянет, то будет статья. Может, кому пригодится. Из неё читатель узнает некоторые факты про устройство бекендов кодогенерации QEMU, а также как написать Just-in-Time компилятор для веб-приложения.\u003C\u002Fp\u003E\u003Ca name=\"habracut\"\u003E\u003C\u002Fa\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"zadachi\"\u003EЗадачи\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПоскольку «кое-как» портировать QEMU на JavaScript я уже научился, в этот раз было решено делать по уму и не повторять старых ошибок.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"oshibka-nomer-raz-otvetvitsya-ot-point-release\"\u003EОшибка номер раз: ответвиться от point release\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПервой моей ошибкой было ответвить свою версию от upstream-версии 2.4.1. Тогда мне казалось это хорошей идеей: если point release существует, значит он, наверное, стабильнее простого 2.4, а уж тем более ветки \u003Ccode\u003Emaster\u003C\u002Fcode\u003E. А поскольку я планировал добавить изрядное количество своих багов, то чужие мне были ну вообще не нужны. Так оно, наверное, и получилось. Но вот незадача: QEMU не стоит на месте, а в какой-то момент там даже анонсировали оптимизацию генерируемого кода процентов на 10. «Ага, сейчас вмёржу» подумал я \u003Cdel\u003Eи обломался\u003C\u002Fdel\u003E. Тут надо сделать отступление: в связи с однопоточным характером QEMU.js и тем, что оригинальный QEMU не предполагает отсутствия многопоточности (то есть для него критична возможность одновременной работы нескольких несвязанных code path, а не просто «заюзать все ядра»), главные функции потоков пришлось «вывернуть» для возможности вызова снаружи. Это создало некие естественные проблемы при слиянии. Однако тот факт, что часть изменений из ветки \u003Ccode\u003Emaster\u003C\u002Fcode\u003E, с которой я пытался слить свой код, также были cherry picked в point release (а значит, и в мою ветку) тоже, вероятно, удобства бы не добавил.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ общем, я решил, что всё равно прототип имеет смысл \u003Cdel\u003Eвыкинуть\u003C\u002Fdel\u003E разобрать на запчасти и построить новую версию с нуля на базе чего-нибудь посвежее и теперь уже из \u003Ccode\u003Emaster\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"oshibka-nomer-dva-tlp-metodologiya\"\u003EОшибка номер два: ТЛП-методология\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ сущности, это и не ошибка, в общем-то — просто особенность создания проекта в условиях полного непонимания как «куда и как двигаться?», так и вообще «а дойдём ли?». В этих условиях \u003Cem\u003Eтяп-ляп программирование\u003C\u002Fem\u003E было оправданным вариантом, но, естественно, совершенно не хотелось это повторять без необходимости. В этот раз хотелось сделать по уму: атомарные коммиты, осознанные изменения кода (а не «stringing random characters together until it compiles (with warnings)», как про кого-то однажды сказал Линус Торвальдс, если верить Викицитатнику) и т.д.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"oshibka-nomer-tri-ne-znaya-brodu-lezt-v-vodu\"\u003EОшибка номер три: не зная броду лезть в воду\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EОт этого я и сейчас до конца не избавился, но теперь решил идти не по пути совсем уж наименьшего сопротивления, и сделать «по взрослому», а именно, написать свой TCG backend с нуля, чтобы потом не говорить, мол «Да, это, конечно, медленно, но я же не могу всё контролировать — TCI так написан...». Кроме того, изначально это казалось очевидным решением, поскольку \u003Cem\u003Eя же бинарный код генерирую\u003C\u002Fem\u003E. Как говорится, «Собрал Гент\u003Cstrong\u003Eу\u003C\u002Fstrong\u003E, да не ту»: код-то, конечно, бинарный, но управление на него просто так не передать — его нужно явным образом запихнуть в браузер на компиляцию, получив в результате некий объект из мира JS, который ещё нужно куда-то сохранить. Впрочем, на \u003Cdel\u003Eнормальных\u003C\u002Fdel\u003ERISC-архитектурах, насколько я понимаю, типичной ситуацией является необходимость явно сбросить кеш инструкций для перегенерированного кода — если это и не то, что нам нужно, то, во всяком случае, близко. Кроме того, из прошлой своей попытки я усвоил, что управление на середину блока трансляции вроде как не передаётся, поэтому байткод, интерпретируемый с любого смещения, нам особо и не нужен, и можно просто генерировать по функции на TB.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"prishli-i-pnuli\"\u003EПришли и пнули\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EХотя переписывать код я начал ещё в июле, но волшебный пендель подкрался незаметно: обычно письма с GitHub приходят как уведомления об ответах на Issues и Pull requests, а тут, \u003Cem\u003Eвнезапно\u003C\u002Fem\u003E упоминание в треде \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FWebAssembly\u002Fbinaryen\u002Fissues\u002F1494\"\u003EBinaryen as a qemu backend\u003C\u002Fa\u003E в контексте, «Вот он что-то подобное делал, может скажет что-нибудь». Речь шла об использовании родственной Emscripten-у библиотеки \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FWebAssembly\u002Fbinaryen\"\u003EBinaryen\u003C\u002Fa\u003E для создания WASM JIT. Ну я и сказал, что у вас там лицензия Apache 2.0, а QEMU как единое целое распространяется под GPLv2, и они не очень совместимые. Внезапно оказалось, что лицензию можно \u003Cem\u003Eкак-то поправить\u003C\u002Fem\u003E (не знаю: может, поменять, может, двойное лицензирование, может, ещё что-то...). Это меня, конечно, обрадовало, потому что я уже несколько раз к тому времени присматривался к \u003Ca href=\"http:\u002F\u002Fwebassembly.github.io\u002Fspec\u002Fcore\u002Fbinary\u002Findex.html\"\u003Eбинарному формату\u003C\u002Fa\u003E WebAssembly, и мне было как-то грустно и непонятно. Здесь же была библиотека, которая и базовые блоки с графом переходов сожрёт, и байткод выдаст, и даже сама его запустит в интерпретаторе, если потребуется.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПотом ещё было \u003Ca href=\"https:\u002F\u002Fmarc.info\u002F?l=qemu-devel&amp;m=154688067607265&amp;w=2\"\u003Eписьмо\u003C\u002Fa\u003E в списке рассылки QEMU, но это уже скорее к вопросу, «А кому оно вообще надо?». А оно, \u003Cstrong\u003Eвнезапно\u003C\u002Fstrong\u003E, оказалось надо. Как минимум, можно наскрести такие возможности использования, если оно будет более-менее шустро работать:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003Eзапуск чего-нибудь обучающего вообще без установки\u003C\u002Fli\u003E\r\n\u003Cli\u003Eвиртуализация на iOS, где по слухам единственное приложение, имеющее право на кодогенерацию на лету — это JS-движок (а правда ли это?)\u003C\u002Fli\u003E\r\n\u003Cli\u003Eдемонстрация мини-ОС — однодискетные, встроенные, всякие прошивки и т.д...\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"osobennosti-brauzernoy-sredy-vypolneniya\"\u003EОсобенности браузерной среды выполнения\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКак я уже говорил, QEMU завязан на многопоточность, а в браузере её нет. Ну, то есть как нет… Сначала её не было вообще, потом появились WebWorkers — насколько я понимаю, это многопоточность, основанная на передаче сообщений \u003Cstrong\u003Eбез совместно изменяемых переменных\u003C\u002Fstrong\u003E. Естественно, это создаёт значительные проблемы при портировании существующего кода, основанного на shared memory модели. Потом под давлением общественности была реализована и она под названием \u003Ccode\u003ESharedArrayBuffers\u003C\u002Fcode\u003E. Её постепенно ввели, отпраздновали её запуск в разных браузерах, потом отпраздновали новый год, а потом Meltdown… После чего пришли к выводу, что загрубляй-не загрубляй измерение времени, а с помощью shared memory и потока, инкрементирующего счётчик, всё равно \u003Ca href=\"https:\u002F\u002Fsecurity.stackexchange.com\u002Fquestions\u002F177033\u002Fhow-can-sharedarraybuffer-be-used-for-timing-attacks\"\u003Eдовольно точно получится\u003C\u002Fa\u003E. Так и отключили многопоточность с общей памятью. Вроде бы, её потом включали обратно, но, как стало понятно из первого эксперимента, и без неё жизнь есть, а раз так, то попробуем сделать, не закладываясь на многопоточность.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВторая особенность заключается в невозможности низкоуровневых манипуляций со стеком: нельзя просто взять, сохранить текущий контекст и переключиться на новый с новым стеком. Стек вызовов управляется виртуальной машиной JS. Казалось бы, в чём проблема, раз уж мы всё равно решили управляться с бывшими потоками полностью вручную? Дело в том, что блочный ввод-вывод в QEMU реализован через корутины, и вот тут бы нам и пригодились низкоуровневые манипуляции стеком. К счастью, Emscipten уже содержит механизм для асинхронных операций, даже два: \u003Ca href=\"https:\u002F\u002Femscripten.org\u002Fdocs\u002Fporting\u002Fasyncify.html\"\u003EAsyncify\u003C\u002Fa\u003E и \u003Ca href=\"https:\u002F\u002Femscripten.org\u002Fdocs\u002Fporting\u002Femterpreter.html\"\u003EEmterpreter\u003C\u002Fa\u003E. Первый работает через значительное раздувание генерируемого JavaScript-кода и уже не поддерживается. Второй является текущим «правильным способом» и работает через генерацию байткода для собственного интерпретатора. Работает, конечно, медленно, но зато не раздувает код. Правда, поддержку корутин для этого механизма пришлось контрибутить самостоятельно (там уже были корутины, написанные под Asyncify и была реализация приблизительно того же API для Emterpreter, нужно было просто их соединить).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНа данный момент я ещё не успел разделить код на компилируемый в WASM и интерпретируемый с помощью Emterpreter, поэтому блочные устройства ещё не работают (смотрите в следующих сериях, как говорится...). То есть, в итоге должно получиться вот такое забавное слоистое нечто:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003Eинтерпретируемый блочный ввод-вывод. Ну а что, вы правда ожидали эмулируемый NVMe с нативной производительностью? :)\u003C\u002Fli\u003E\r\n\u003Cli\u003Eстатически скомпилированный основной код QEMU (транслятор, остальные эмулируемые устройства и т.д.)\u003C\u002Fli\u003E\r\n\u003Cli\u003Eдинамически компилируемый в WASM гостевой код\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"osobennosti-ishodnikov-qemu\"\u003EОсобенности исходников QEMU\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКак вы, наверное, уже догадались, код эмуляции гостевых архитектур и код генерации хостовых машинных инструкций у QEMU разделён. На самом деле, там даже ещё чуть хитрее:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003Eесть гостевые архитектуры\u003C\u002Fli\u003E\r\n\u003Cli\u003Eесть \u003Cem\u003Eакселераторы\u003C\u002Fem\u003E, а именно, KVM для аппаратной виртуализации на Linux (для совместимых между собой гостевых и хостовых систем), TCG для JIT-кодогенерации где попало. Начиная с QEMU 2.9 появилась поддержка стандарта аппаратной виртуализации HAXM на Windows (\u003Ca href=\"https:\u002F\u002Fwiki.qemu.org\u002FHosts\u002FW32\"\u003Eподробности\u003C\u002Fa\u003E)\u003C\u002Fli\u003E\r\n\u003Cli\u003Eесли используется TCG, а не аппаратная виртуализация, то у него есть отдельная поддержка кодогенерации под каждую хостовую архитектуру, а также под универсальный интерпретатор\u003C\u002Fli\u003E\r\n\u003Cli\u003E… а вокруг всего этого — эмулируемая периферия, пользовательский интерфейс, миграция, record-replay, и т.д.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cem\u003EКстати, знаете ли вы:\u003C\u002Fem\u003E QEMU может эмулировать не только компьютер целиком, но и процессор для отдельного пользовательского процесса в хостовом ядре, чем пользуется, например, фаззер AFL для инструментации бинарников. Возможно, кто-то захочет портировать этот режим работы QEMU на JS? ;)\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКак и большинство давно существующих свободных программ, QEMU собирается через вызов \u003Ccode\u003Econfigure\u003C\u002Fcode\u003E и \u003Ccode\u003Emake\u003C\u002Fcode\u003E. Предположим, вы решили что-то добавить: TCG-бекенд, реализацию потоков, что-то ещё. Не спешите радоваться\u002Fужасаться (нужное подчеркнуть) перспективе общения с Autoconf — на самом деле, \u003Ccode\u003Econfigure\u003C\u002Fcode\u003E у QEMU, по всей видимости, самописный и не из чего не генерируется.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"webassembly\"\u003EWebAssembly\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТак что же это за штука — WebAssembly (он же WASM)? Это замена Asm.js, теперь уже не прикидывающаяся валидным JavaScript кодом. Напротив, оно сугубо бинарное и оптимизированное, и даже просто записать в него целое число не очень-то и просто: оно для компактности хранится в формате \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FLEB128\"\u003ELEB128\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВозможно, вы слышали об алгоритме relooping для Asm.js — это восстановление «высокоуровневых» инструкций управления потоком выполнения (то есть if-then-else, циклы и т.д.), под которые заточены JS-движки, из низкоуровневого LLVM IR, более близкого к машинному коду, выполняемому процессором. Естественно, промежуточное представление QEMU ближе ко второму. Казалось бы, вот он, байткод, конец мучений… И тут блоки, if-then-else и циклы!..\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИ в этом заключается ещё одна причина, почему полезен Binaryen: он, естественно, может принимать высокоуровневые блоки, близкие к тому, что будет сохранено в WASM. Но также он может выдавать код из графа базовых блоков и переходов между ними. Ну а о том, что он скрывает за удобным C\u002FC++ API формат хранения WebAssembly, я уже сказал.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"tcg-tiny-code-generator\"\u003ETCG (Tiny Code Generator)\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003ETCG \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fqemu\u002Fqemu\u002Fblob\u002Fmaster\u002Ftcg\u002FREADME\"\u003Eизначально был\u003C\u002Fa\u003E бекендом для компилятора C. Потом он, видимо, не выдержал конкуренции с GCC, но в итоге нашёл своё место в составе QEMU в качестве механизма кодогенерации под хостовую платформу. Также есть и TCG-бекенд, генерирующий некий абстрактный байткод, который тут же и исполняет интерпретатор, но от его использования я решил уйти в этот раз. Впрочем, тот факт, что в QEMU уже есть возможность включить переход на сгенерированный TB через функцию \u003Ccode\u003Etcg_qemu_tb_exec\u003C\u002Fcode\u003E, мне оказался очень кстати.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЧтобы добавить новый TCG-бекенд в QEMU, нужно создать подкаталог \u003Ccode\u003Etcg\u002F&lt;имя архитектуры\u003E\u003C\u002Fcode\u003E (в данном случае, \u003Ccode\u003Etcg\u002Fbinaryen\u003C\u002Fcode\u003E), а в нём два файла: \u003Ccode\u003Etcg-target.h\u003C\u002Fcode\u003E и \u003Ccode\u003Etcg-target.inc.c\u003C\u002Fcode\u003E и \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fatrosinenko\u002Fqemujs\u002Fblob\u002Fabeace64b1e5b52a6ab17bdd4a0e08eb911e98d2\u002Fconfigure#L6827\"\u003Eпрописать\u003C\u002Fa\u003E всё это дело в \u003Ccode\u003Econfigure\u003C\u002Fcode\u003E. Можно положить туда и другие файлы, но, как можно догадаться из названий этих двух, они оба будут куда-то включаться: один как обычный заголовочный файл (он инклудится в \u003Ccode\u003Etcg\u002Ftcg.h\u003C\u002Fcode\u003E, а тот уже в другие файлы в каталогах \u003Ccode\u003Etcg\u003C\u002Fcode\u003E, \u003Ccode\u003Eaccel\u003C\u002Fcode\u003E и не только), другой — только как code snippet в \u003Ccode\u003Etcg\u002Ftcg.c\u003C\u002Fcode\u003E, зато он имеет доступ к его static-функциям.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EРешив, что я потрачу слишком много времени на детальные разбирательства, как оно устроено, я просто скопировал «скелеты» этих двух файлов из другой реализации бекенда, честно указав это в заголовке лицензии.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EФайл \u003Ccode\u003Etcg-target.h\u003C\u002Fcode\u003E содержит преимущественно настройки в виде \u003Ccode\u003E#define\u003C\u002Fcode\u003E-ов:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003Eсколько регистров и какой ширины есть на целевой архитектуре (у нас — сколько хотим, столько и есть — вопрос больше того, что будет генерироваться в более эффективный код браузером на «совсем целевой» архитектуре...)\u003C\u002Fli\u003E\r\n\u003Cli\u003Eвыравнивание хостовых инструкций: на x86, да и в TCI, инструкции вообще не выравниваются, я же собираюсь класть в буфер кода и не инструкции вовсе, а указатели на структуры библиотеки Binaryen, поэтому скажу: 4 байта\u003C\u002Fli\u003E\r\n\u003Cli\u003Eкакие опциональные инструкции может генерировать бекенд — включаем всё, что найдём в Binaryen, остальное пусть акселератор разбивает на более простые сам\u003C\u002Fli\u003E\r\n\u003Cli\u003Eкакой приблизительно размер TLB-кеша запрашивает бекенд. Дело в том, что в QEMU всё по-серьёзному: хотя и есть функции-помощники, осуществляющие load\u002Fstore с учётом гостевого MMU (а куда сейчас без него?), но свой кеш трансляции они сохраняют в виде структуры, обработку которой удобно встраивать прямо в блоки трансляции. Вопрос же в том, какое смещение в этой структуре наиболее эффективно обрабатывается маленькой и быстрой последовательностью команд\u003C\u002Fli\u003E\r\n\u003Cli\u003Eздесь же можно подкрутить назначение одного-двух зарезервированных регистров, включить вызов TB через функцию и опционально описать пару мелких \u003Ccode\u003Einline\u003C\u002Fcode\u003E-функций вроде \u003Ccode\u003Eflush_icache_range\u003C\u002Fcode\u003E (но это не наш случай)\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EФайл \u003Ccode\u003Etcg-target.inc.c\u003C\u002Fcode\u003E, естественно, обычно намного больше по размеру и содержит несколько обязательных функций:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003Eинициализация, указывающая в том числе ограничения на то, какая инструкция с какими операндами может работать. Нагло скопирована мною из другого бекенда\u003C\u002Fli\u003E\r\n\u003Cli\u003Eфункция, принимающая одну инструкцию внутреннего байткода\u003C\u002Fli\u003E\r\n\u003Cli\u003Eсюда же можно положить вспомогательные функции, а также здесь можно пользоваться статическими функциями из \u003Ccode\u003Etcg\u002Ftcg.c\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДля себя я избрал следующую стратегию: в первых словах очередного блока трансляции я записывал четыре указателя: метку начала (некое значение в окрестности \u003Ccode\u003E0xFFFFFFFF\u003C\u002Fcode\u003E, по которому определялось текущее состояние TB), контекст, сгенерированный модуль, и magic number для отладки. Сначала метка выставлялась в \u003Ccode\u003E0xFFFFFFFF - n\u003C\u002Fcode\u003E, где \u003Ccode\u003En\u003C\u002Fcode\u003E — небольшое положительное число, и при каждом выполнении через интерпретатор увеличивалась на 1. Когда она доходила до \u003Ccode\u003E0xFFFFFFFE\u003C\u002Fcode\u003E, происходила компиляция, модуль сохранялся в таблице функций, импортированной в небольшой «запускатор», в который и уходило выполнение из \u003Ccode\u003Etcg_qemu_tb_exec\u003C\u002Fcode\u003E, а модуль удалялся из памяти QEMU.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПерефразируя классику, «Костыль, как много в этом звуке для сердца прогера сплелось...». Тем не менее, память куда-то утекала. Причём это была память, управляемая QEMU! У меня был код, который при записи очередной инструкции (ну, то есть, указателя) удалял ту, ссылка на которую была на этом месте ранее, но это не помогало. Вообще-то, в простейшем случае QEMU выделяет при старте память и пишет туда генерируемый код. Когда буфер заканчивается, код выкидывается, и на его место начинает записываться следующий.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПоизучав код, я понял, что костыль с magic number позволял не упасть на разрушении кучи, освободив что-нибудь не то на неинициализированном буфере при первом проходе. Но кто переписывает буфер в обход моей функции потом? Как и советуют разработчики Emscripten, упёршись в проблему, я портировал получившийся код обратно в нативное приложение, натравил на него Mozilla Record-Replay… В общем, в итоге я понял простую вещь: для каждого блока выделяется \u003Ccode\u003Estruct TranslationBlock\u003C\u002Fcode\u003E с его описанием. Угадайте, где… Правильно, непосредственно перед блоком прямо в буфере. Осознав это, я решил завязывать с костылями (хотя бы некоторыми), и просто выкинул magic number, а оставшиеся слова перенёс в \u003Ccode\u003Estruct TranslationBlock\u003C\u002Fcode\u003E, заведя односвязный список, по которому можно быстро пройтись при сбросе кеша трансляции, и освободить память.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНекоторые костыли остались: например, помеченные указатели в буфере кода — часть из них просто являются \u003Ccode\u003EBinaryenExpressionRef\u003C\u002Fcode\u003E, то есть смотрят на выражения, которые нужно линейно положить в генерируемый базовый блок, часть — условие перехода между ББ, часть — куда переходить. Ну и есть уже подготовленные блоки для Relooper, которые нужно соединить по условиям. Чтобы их различать, используется предположение, что все они выровнены хотя бы на четыре байта, поэтому можно спокойно использовать младшие два бита под метку, нужно только не забывать её убирать при необходимости. Кстати, такие метки уже используются в QEMU для обозначения причины выхода из цикла TCG.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"ispolzovanie-binaryen\"\u003EИспользование Binaryen\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EМодули в WebAssembly содержат функции, каждая из которых содержит тело, представляющее из себя выражение. Выражения — это унарные и бинарные операции, блоки, состоящие из списков других выражений, control flow и т.д. Как я уже говорил, control flow здесь организуется именно как высокоуровневые ветвления, циклы, вызовы функций и т.д. Аргументы функциям передаются не на стеке, а явно, как и в JS. Есть и глобальные переменные, но я их не использовал, поэтому про них не расскажу.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТакже у функций есть нумерованные с нуля локальные переменные, имеющие тип: int32 \u002F int64 \u002F float \u002F double. При этом первые n локальных переменных — это переданные функции аргументы. Обратите внимание, что хоть здесь всё и не совсем низкоуровневое в плане потока управления, но целые числа всё же не несут в себе признак «знаковое\u002Fбеззнаковое»: как будет вести себя число, зависит от кода операции.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВообще говоря, Binaryen предоставляет \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FWebAssembly\u002Fbinaryen\u002Fwiki\u002FCompiling-to-WebAssembly-with-Binaryen#c-api\"\u003Eпростой C-API\u003C\u002Fa\u003E: вы создаёте модуль, \u003Cstrong\u003Eв нём\u003C\u002Fstrong\u003E создаёте выражения — унарные, бинарные, блоки из других выражений, control flow и т.д. Потом вы создаёте функцию, в качестве тела которой нужно указать выражение. Если у вас, как и у меня, есть низкоуровневый граф переходов — вам поможет компонент relooper. Насколько я понимаю, использовать высокоуровневое управление потоком выполнения в блоке можно, покуда оно не выходит за пределы блока — то есть сделать внутреннее ветвление fast path \u002F slow path внутри встроенного кода обработки TLB-кеша можно, но вмешиваться в «наружный» поток управления — нет. Когда вы освобождаете relooper, освобождаются его блоки, когда освобождаете модуль — исчезают выражения, функции и т.д., выделенные в его \u003Cem\u003Eарене\u003C\u002Fem\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВпрочем, если вы хотите интерпретировать код на ходу без лишних созданий и удалений экземпляра интерпретатора, может иметь смысл вынести эту логику в файл на C++, и оттуда непосредственно управлять всем C++ API библиотеки, минуя готовые обёртки.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТаким образом, чтобы сгенерировать код, нужно\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E\u002F\u002F настроить глобальные параметры (можно поменять потом)\nBinaryenSetAPITracing(0);\n\nBinaryenSetOptimizeLevel(3);\nBinaryenSetShrinkLevel(2);\n\n\u002F\u002F создать модуль\nBinaryenModuleRef MODULE = BinaryenModuleCreate();\n\n\u002F\u002F описать типы функций (как создаваемых, так и вызываемых)\nhelper_type  BinaryenAddFunctionType(MODULE, \"helper-func\", BinaryenTypeInt32(), int32_helper_args, ARRAY_SIZE(int32_helper_args));\n\u002F\u002F (int23_helper_args приоб^Wсоздаются отдельно)\n\n\u002F\u002F сконструировать супер-мега выражение\n\u002F\u002F ... ну тут уж вы как-нибудь сами :)\n\n\u002F\u002F потом создать функцию\nBinaryenAddFunction(MODULE, \"tb_fun\", tb_func_type, func_locals, FUNC_LOCALS_COUNT, expr);\nBinaryenAddFunctionExport(MODULE, \"tb_fun\", \"tb_fun\");\n...\nBinaryenSetMemory(MODULE, (1 &lt;&lt; 15) - 1, -1, NULL, NULL, NULL, NULL, NULL, 0, 0);\nBinaryenAddMemoryImport(MODULE, NULL, \"env\", \"memory\", 0);\nBinaryenAddTableImport(MODULE, NULL, \"env\", \"tb_funcs\");\n\n\u002F\u002F запросить валидацию и оптимизацию при желании\nassert (BinaryenModuleValidate(MODULE));\nBinaryenModuleOptimize(MODULE);\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E… если что забыл — извините, это просто чтобы представлять масштабы, а подробности — они в документации.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EА теперь начинается крекс-фекс-пекс, примерно такой:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003Estatic char buf[1 &lt;&lt; 20];\nBinaryenModuleOptimize(MODULE);\nBinaryenSetMemory(MODULE, 0, -1, NULL, NULL, NULL, NULL, NULL, 0, 0);\nint sz = BinaryenModuleWrite(MODULE, buf, sizeof(buf));\nBinaryenModuleDispose(MODULE);\nEM_ASM({\n  var module = new WebAssembly.Module(new Uint8Array(wasmMemory.buffer, $0, $1));\n  var fptr = $2;\n  var instance = new WebAssembly.Instance(module, {\n      'env': {\n          'memory': wasmMemory,\n          \u002F\u002F ...\n      }\n  );\n  \u002F\u002F и вот уже у вас есть instance!\n}, buf, sz);\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЧтобы как-то связать между собой мир QEMU и JS и при этом заходить в скомпилированные функции быстро, был создан массив (таблица функций для импорта в запускатор), и туда клались сгенерированные функции. Чтобы быстро вычислять индекс, в качестве него изначально использовался индекс нулевого слова translation block, но потом индекс, вычисленный по такой формуле стал просто вписываться в поле в \u003Ccode\u003Estruct TranslationBlock\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКстати, \u003Ca href=\"https:\u002F\u002Fatrosinenko.github.io\u002Fqemujs-demo\u002Fnew\u002Fshell.html\"\u003Eдемо\u003C\u002Fa\u003E \u003Cem\u003E(пока что с мутной лицензией)\u003C\u002Fem\u003E работает нормально только в Firefox. Разработчики Chrome были \u003Cem\u003Eкак-то не готовы\u003C\u002Fem\u003E к тому, что кто-то захочет создавать более тысячи инстансов модулей WebAssembly, поэтому просто выделяли по гигабайту виртуального адресного пространства на каждый...\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПока что на этом всё. Возможно, будет ещё одна статья, если она кому-то интересна. А именно, осталось как минимум \u003Cem\u003Eвсего лишь\u003C\u002Fem\u003E заставить работать блочные устройства. Возможно, имеет смысл также сделать компиляцию WebAssembly модулей асинхронной, как это и принято в мире JS, раз уж всё равно имеется интерпретатор, который может это всё выполнять, пока нативный модуль не готов.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cstrong\u003E\u003Cstrong\u003EНапоследок загадка:\u003C\u002Fstrong\u003E\u003C\u002Fstrong\u003E вы собрали бинарник на 32-битной архитектуре, но код через операции с памятью лезет из Binaryen, куда-то на стек или ещё куда-то в верхние 2 Гб 32-битного адресного пространства. Проблема в том, что с точки зрения Binaryen это обращение по слишком большому результирующему адресу. Как это обойти?\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\"\u003E\u003Cb class=\"spoiler_title\"\u003EПо-админски\u003C\u002Fb\u003E\u003Cdiv class=\"spoiler_text\"\u003E\u003Cp\u003EЯ это в итоге не тестировал, но первая мысль была «А что, если поставить 32-битный Linux?» Тогда верхняя часть адресного пространства будет занята ядром. Вопрос только в том, сколько будет занято: 1 или 2 Gb.\u003C\u002Fp\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\"\u003E\u003Cb class=\"spoiler_title\"\u003EПо-программистски (вариант для практиков)\u003C\u002Fb\u003E\u003Cdiv class=\"spoiler_text\"\u003E\u003Cp\u003EНадуем пузырь в верхней части адресного пространства. Я сам не понимаю, почему оно работает — там же \u003Cstrong\u003Eуже\u003C\u002Fstrong\u003E должен быть стек. Но «мы практики: у нас всё работает, но никто не знает почему...».\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cpp\"\u003E\u002F\u002F 2gbubble.c\n\u002F\u002F Usage: LD_PRELOAD=2gbubble.so &lt;program\u003E\n\n#include &lt;sys\u002Fmman.h\u003E\n#include &lt;assert.h\u003E\n\nvoid __attribute__((constructor)) constr(void)\n{\n  assert(MAP_FAILED != mmap(1u \u003E\u003E 31, (1u \u003E\u003E 31) - (1u \u003E\u003E 20), PROT_NONE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0));\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E… с Valgrind-ом, правда, не совместимо, но, к счастью, Valgrind сам очень эффективно оттуда всех вытесняет :)\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cem\u003EВозможно, кто-то даст лучшее объяснение, как работает этот мой код...\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"qemu"},{"titleHtml":"qemu.js"},{"titleHtml":"webassembly"},{"titleHtml":"wasm"},{"titleHtml":"jit"},{"titleHtml":"tcg"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F451306\u002Fbfa2736941912e0a8d4a4cf2d76b953d\u002F","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F451306\u002Fbfa2736941912e0a8d4a4cf2d76b953d\u002F?format=vk","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F451306\\\u002F\"},\"headline\":\"QEMU.js: теперь по-серьёзному и с WASM\",\"datePublished\":\"2019-05-12T18:31:29+03:00\",\"dateModified\":\"2019-05-14T12:29:17+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"Анатолий Тросиненко\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"Когда-то давно я смеха ради решил доказать обратимость процесса и научиться генерировать JavaScript (а точнее, Asm.js) из машинного кода. Для эксперимента был вы...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F451306\\\u002F#post-content-body\",\"about\":[\"h_crazydev\",\"h_javascript\",\"h_virtualization\",\"h_c\",\"h_webassembly\",\"f_develop\",\"f_admin\"],\"image\":[\"https:\\\u002F\\\u002Fhabr.com\\\u002Fshare\\\u002Fpublication\\\u002F451306\\\u002Fbfa2736941912e0a8d4a4cf2d76b953d\\\u002F\"]}","metaDescription":"Когда-то давно я смеха ради решил доказать обратимость процесса и научиться генерировать JavaScript (а точнее, Asm.js) из машинного кода. Для эксперимента был выбран QEMU, некоторое время спустя была...","mainImageUrl":null,"amp":false},"polls":[],"commentsEnabled":true,"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":false}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[],"hubs":"crazydev,javascript,virtualization,c,webassembly"},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{}},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"dfp":{"slotsDict":{}},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.c0af73e7.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
</body>
</html>
