<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <title>GOSTIM: P2P F2F E2EE IM за один вечер с ГОСТ-криптографией / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.c0af73e7.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.85eb77f0b17c8235e7b64b9f81ea5ec2.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" src="/js/ads.js" onload="window['zhY4i4nJ9K'] = true" data-vmid="checkad"></script><script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/post\/452200\/"},"headline":"GOSTIM: P2P F2F E2EE IM за один вечер с ГОСТ-криптографией","datePublished":"2019-05-16T18:30:59+03:00","dateModified":"2020-12-15T20:09:12+03:00","author":{"@type":"Person","name":"stargrave2"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"Будучи разработчиком PyGOST библиотеки (ГОСТовые криптографические примитивы на чистом Python), я нередко получаю вопросы о том, как на коленке реализовать прост...","url":"https:\/\/habr.com\/ru\/post\/452200\/#post-content-body","about":["h_p2p","h_infosecurity","h_crypto","h_python","h_programming","f_develop","f_admin"],"image":["https:\/\/habrastorage.org\/getpro\/habr\/post_images\/4e2\/2bb\/f04\/4e22bbf0480a8181bcbb2054c6f95815.jpg"]}</script>
  <script src="//www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.49.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_eng"><meta data-vue-meta="ssr" property="og:title" content="GOSTIM: P2P F2F E2EE IM за один вечер с ГОСТ-криптографией" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="GOSTIM: P2P F2F E2EE IM за один вечер с ГОСТ-криптографией" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="GOSTIM: P2P F2F E2EE IM за один вечер с ГОСТ-криптографией" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="Будучи разработчиком PyGOST библиотеки (ГОСТовые криптографические примитивы на чистом Python), я нередко получаю вопросы о том, как на коленке реализовать простейший безопасный обмен сообщениями...." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="Будучи разработчиком PyGOST библиотеки (ГОСТовые криптографические примитивы на чистом Python), я нередко получаю вопросы о том, как на коленке реализовать простейший безопасный обмен сообщениями...." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="Будучи разработчиком PyGOST библиотеки (ГОСТовые криптографические примитивы на чистом Python), я нередко получаю вопросы о том, как на коленке реализовать простейший безопасный обмен сообщениями...." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="Будучи разработчиком PyGOST библиотеки (ГОСТовые криптографические примитивы на чистом Python), я нередко получаю вопросы о том, как на коленке реализовать простейший безопасный обмен сообщениями...." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="Будучи разработчиком PyGOST библиотеки (ГОСТовые криптографические примитивы на чистом Python), я нередко получаю вопросы о том, как на коленке реализовать простейший безопасный обмен сообщениями...." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habr.com/share/publication/452200/3e8cee03bb82ac218966636d55c1a488/" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habr.com/share/publication/452200/3e8cee03bb82ac218966636d55c1a488/" data-vmid="og:image"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habr.com/share/publication/452200/3e8cee03bb82ac218966636d55c1a488/" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habr.com/share/publication/452200/3e8cee03bb82ac218966636d55c1a488/" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habr.com/share/publication/452200/3e8cee03bb82ac218966636d55c1a488/" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="452200" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2019-05-16T15:30:59.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/452200/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="https://habr.com/ru/post/452200/" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habr.com/share/publication/452200/3e8cee03bb82ac218966636d55c1a488/" data-vmid="image:href">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="/ru/sandbox/start/" class="tm-header__become-author-btn">
            Как стать автором
          </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="/ru/all/" class="tm-main-menu__item">
        Все потоки
      </a> <a href="/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" data-async-called="true" class="tm-page"><div class="tm-page-width"><!----> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="/ru/users/stargrave2/" title="stargrave2" class="tm-user-info__userpic"><div class="tm-entity-image"><svg height="24" width="24" class="tm-svg-img tm-image-placeholder tm-image-placeholder_pink"><!----> <use xlink:href="/img/megazord-v24.ce74655c.svg#placeholder-user"></use></svg></div></a> <span class="tm-user-info__user"><a href="/ru/users/stargrave2/" class="tm-user-info__username">
      stargrave2
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2019-05-16T15:30:59.000Z" title="2019-05-16, 18:30">16  мая  2019 в 18:30</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>GOSTIM: P2P F2F E2EE IM за один вечер с ГОСТ-криптографией</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/p2p/" class="tm-article-snippet__hubs-item-link"><span>Децентрализованные сети</span> <!----></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/infosecurity/" class="tm-article-snippet__hubs-item-link"><span>Информационная безопасность</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/crypto/" class="tm-article-snippet__hubs-item-link"><span>Криптография</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/python/" class="tm-article-snippet__hubs-item-link"><span>Python</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/programming/" class="tm-article-snippet__hubs-item-link"><span>Программирование</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span></div> <!----> <!----> <!----></div></div> <!----> <div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-1"><div xmlns="http://www.w3.org/1999/xhtml">Будучи разработчиком <a href="http://www.pygost.cypherpunks.ru/" rel="nofollow">PyGOST</a> библиотеки (ГОСТовые криптографические примитивы на чистом Python), я нередко получаю вопросы о том, как на коленке реализовать простейший безопасный обмен сообщениями. Многие считают прикладную криптографию достаточно простой штукой, и .encrypt() вызова у блочного шифра будет достаточно для безопасной отсылки по каналу связи. Другие же считают, что прикладная криптография — удел немногих, и приемлемо, что богатые компании типа Telegram с олимпиадниками-математиками <a href="https://eprint.iacr.org/2015/1177.pdf" rel="nofollow">не могут реализовать</a> безопасный протокол.<br/>
<br/>
Всё это побудило меня написать данную статью, чтобы показать, что реализация криптографических протоколов и безопасного IM-а не такая сложная задача. Однако изобретать собственные протоколы аутентификации и согласования ключей не стоит.<br/>
<br/>
<div style="text-align:center;"><img alt="Hearing" src="https://habrastorage.org/r/w780q1/getpro/habr/post_images/4e2/2bb/f04/4e22bbf0480a8181bcbb2054c6f95815.jpg" data-src="https://habrastorage.org/getpro/habr/post_images/4e2/2bb/f04/4e22bbf0480a8181bcbb2054c6f95815.jpg" data-blurred="true"/></div><br/>
В статье будет написан <a href="https://ru.wikipedia.org/wiki/Peer-to-peer" rel="nofollow">peer-to-peer</a>, <a href="https://ru.wikipedia.org/wiki/Friend-to-friend" rel="nofollow">friend-to-friend</a>, <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BA%D0%B2%D0%BE%D0%B7%D0%BD%D0%BE%D0%B5_%D1%88%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" rel="nofollow">end-to-end зашифрованный</a> instant messenger с <a href="http://webee.technion.ac.il/~hugo/sigma-pdf.pdf" rel="nofollow">SIGMA-I</a> протоколом аутентификации и согласования ключей (на базе которого реализован <a href="https://ru.wikipedia.org/wiki/IKE" rel="nofollow">IPsec IKE</a>), используя исключительно ГОСТовые криптографические алгоритмы PyGOST библиотеки и ASN.1 кодирование сообщений библиотекой <a href="http://www.pyderasn.cypherpunks.ru/" rel="nofollow">PyDERASN</a> (про которую я уже <a href="https://habr.com/ru/post/444272/">писал раньше</a>). Необходимое условие: он должен быть настолько прост, чтобы его можно было написать с нуля за один вечер (или рабочий день), иначе это уже не простая программа. В ней наверняка есть ошибки, излишние сложности, недочёты, плюс это моя первая программа с использованием asyncio библиотеки.<br/>
<a name="habracut"></a><br/>
<h2>Дизайн IM</h2><br/>
Для начала, надо понять, как будет выглядеть наш IM. Для простоты, пускай это будет peer-to-peer сеть, без какого-либо обнаружения участников. Собственноручно будем указывать, к какому адресу: порту подключаться для общения с собеседником.<br/>
<br/>
Я понимаю, что на данный момент, предположение о доступности прямой связи между двумя произвольными компьютерами — существенное ограничение применимости IM на практике. Но чем больше разработчиков будут реализовывать всякие NAT-traversal костыли, тем дольше мы так и будем оставаться в IPv4 Интернете, с удручающей вероятностью связи между произвольными компьютерами. Ну сколько можно терпеть отсутствие IPv6 дома и на работе?<br/>
<br/>
У нас будет friend-to-friend сеть: все возможные собеседники заранее должны быть известны. Во-первых, это сильно всё упрощает: представились, нашли или не нашли имя/ключ, отключились или продолжаем работу, зная собеседника. Во-вторых, в общем случае, это безопасно и исключает множество атак.<br/>
<br/>
Интерфейс IM-а будет близок к классическим решениям <a href="https://suckless.org/" rel="nofollow">suckless-проектов</a>, которые мне очень нравятся своим минимализмом и Unix-way философией. IM программа для каждого собеседника создаёт директорию с тремя Unix domain sockets:<br/>
<br/>
<ul>
<li>in — в него записываются отправляемые собеседнику сообщения;</li>
<li>out — из него читаются принимаемые от собеседника сообщения;</li>
<li>state — читая из него, мы узнаём, подключён ли сейчас собеседник, адрес/порт подключения.</li>
</ul><br/>
Кроме того, создаётся conn сокет, записав в который хост порт, мы инициируем подключение к удалённому собеседнику.<br/>
<br/>
<pre>
|-- alice
|   |-- in
|   |-- out
|   `-- state
|-- bob
|   |-- in
|   |-- out
|   `-- state
`- conn
</pre><br/>
Такой подход позволяет делать независимые реализации IM транспорта и пользовательского интерфейса, ведь на вкус и цвет товарища нет, каждому не угодишь. Используя <a href="https://github.com/tmux/tmux/wiki" rel="nofollow">tmux</a> и/или <a href="https://www.vanheusden.com/multitail/" rel="nofollow">multitail</a>, можно получить многооконный интерфейс с синтаксической подсветкой. А с помощью <a href="https://github.com/hanslub42/rlwrap" rel="nofollow">rlwrap</a> можно получить GNU Readline-совместимую строку для ввода сообщений.<br/>
<br/>
На самом деле suckless проекты используют FIFO-файлы. Лично я не смог понять, как в asyncio работать с файлами конкурентно без собственноручной подложки из выделенных тредов (для таких вещей давно использую язык <a href="https://golang.org/" rel="nofollow">Go</a>). Поэтому решил обойтись Unix domain сокетами. К сожалению, это лишает возможности сделать echo 2001:470:dead::babe 6666 > conn. Я решил эту проблему, используя <a href="http://www.dest-unreach.org/socat/" rel="nofollow">socat</a>: echo 2001:470:dead::babe 6666 | socat — UNIX-CONNECT:conn, socat READLINE UNIX-CONNECT:alice/in.<br/>
<br/>
<h2>Первоначальный небезопасный протокол</h2><br/>
В качестве транспорта используется TCP: он гарантирует доставку и её порядок. UDP не гарантирует ни того, ни другого (что было бы полезным, когда применится криптография), а поддержки <a href="https://ru.wikipedia.org/wiki/SCTP" rel="nofollow">SCTP</a> в Python из коробки нет.<br/>
<br/>
К сожалению, в TCP нет понятия сообщения, а только потока байт. Поэтому необходимо придумать формат для сообщений, чтобы их можно было разделять между собой в этом потоке. Можем условиться использовать символ перевода строки. Для начала подойдёт, однако, когда мы начнём шифровать наши сообщения, этот символ может появиться где угодно в шифротексте. В сетях поэтому популярны протоколы, отправляющие сначала длину сообщения в байтах. Например, в Python из коробки есть xdrlib, позволяющая работать с подобным форматом <a href="https://ru.wikipedia.org/wiki/External_Data_Representation" rel="nofollow">XDR</a>.<br/>
<br/>
Мы не будем правильно и эффективно работать с TCP чтением — упростим код. Читаем в бесконечном цикле данные из сокета, пока не декодируем полное сообщение. В качестве формата для такого подхода можно использовать и JSON с XML. Но когда добавится криптография, то данные придётся подписывать и аутентифицировать — а это потребует байт-в-байт идентичного представления объектов, чего не обеспечивают JSON/XML (dumps результат может отличаться).<br/>
<br/>
XDR подходит для такой задачи, однако я выбираю ASN.1 с DER-кодированием и <a href="http://www.pyderasn.cypherpunks.ru/" rel="nofollow">PyDERASN</a> библиотеку, так как на руках у нас будут высокоуровневые объекты, с которыми часто приятнее и удобнее работать. В отличии от schemaless <a href="https://ru.wikipedia.org/wiki/Bencode" rel="nofollow">bencode</a>, <a href="https://en.wikipedia.org/wiki/MessagePack" rel="nofollow">MessagePack</a> или <a href="https://en.wikipedia.org/wiki/CBOR" rel="nofollow">CBOR</a>, ASN.1 автоматически проверит данные напротив жёстко заданной схемы.<br/>
<br/>
<pre><code class="python"># Msg ::= CHOICE {
#       text      MsgText,
#       handshake [0] EXPLICIT MsgHandshake }
class Msg(Choice):
    schema = ((
        ("text", MsgText()),
        ("handshake", MsgHandshake(expl=tag_ctxc(0))),
    ))

# MsgText ::= SEQUENCE {
#       text UTF8String (SIZE(1..MaxTextLen))}
class MsgText(Sequence):
    schema = ((
        ("text", UTF8String(bounds=(1, MaxTextLen))),
    ))

# MsgHandshake ::= SEQUENCE {
#       peerName UTF8String (SIZE(1..256)) }
class MsgHandshake(Sequence):
    schema = ((
        ("peerName", UTF8String(bounds=(1, 256))),
    ))
</code></pre><br/>
Принимаемым сообщением будет Msg: либо текстовое MsgText (пока с одним текстовым полем), либо сообщение рукопожатия MsgHandshake (в котором передаётся имя собеседника). Сейчас выглядит переусложнённым, но это задел на будущее.<br/>
<br/>
<pre>
     ┌─────┐            ┌─────┐
     │PeerA│            │PeerB│
     └──┬──┘            └──┬──┘
        │MsgHandshake(IdA) │
        │─────────────────>│
        │                  │
        │MsgHandshake(IdB) │
        │&lt;─────────────────│
        │                  │
        │    MsgText()     │
        │─────────────────>│
        │                  │
        │    MsgText()     │
        │&lt;─────────────────│
        │                  │
</pre><br/>
<br/>
<h2>IM без криптографии</h2><br/>
Как я уже говорил, для всех операций с сокетами будет использоваться asyncio библиотека. Объявим, что мы ожидаем в момент запуска:<br/>
<br/>
<pre><code class="python">parser = argparse.ArgumentParser(description="GOSTIM")
parser.add_argument(
    "--our-name",
    required=True,
    help="Our peer name",
)
parser.add_argument(
    "--their-names",
    required=True,
    help="Their peer names, comma-separated",
)
parser.add_argument(
    "--bind",
    default="::1",
    help="Address to listen on",
)
parser.add_argument(
    "--port",
    type=int,
    default=6666,
    help="Port to listen on",
)
args = parser.parse_args()
OUR_NAME = UTF8String(args.our_name)
THEIR_NAMES = set(args.their_names.split(","))
</code></pre><br/>
Задаётся собственное имя (--our-name alice). Через запятую перечисляются все ожидаемые собеседники (--their-names bob,eve). Для каждого из собеседников создаётся директория с Unix сокетами, а также по корутине на каждый in, out, state:<br/>
<br/>
<pre><code class="python">for peer_name in THEIR_NAMES:
    makedirs(peer_name, mode=0o700, exist_ok=True)
    out_queue = asyncio.Queue()
    OUT_QUEUES[peer_name] = out_queue
    asyncio.ensure_future(asyncio.start_unix_server(
        partial(unixsock_out_processor, out_queue=out_queue),
        path.join(peer_name, "out"),
    ))
    in_queue = asyncio.Queue()
    IN_QUEUES[peer_name] = in_queue
    asyncio.ensure_future(asyncio.start_unix_server(
        partial(unixsock_in_processor, in_queue=in_queue),
        path.join(peer_name, "in"),
    ))
    asyncio.ensure_future(asyncio.start_unix_server(
        partial(unixsock_state_processor, peer_name=peer_name),
        path.join(peer_name, "state"),
    ))
asyncio.ensure_future(asyncio.start_unix_server(unixsock_conn_processor, "conn"))
</code></pre><br/>
Приходящие от пользователя сообщения из in сокета отправляются в IN_QUEUES очереди:<br/>
<br/>
<pre><code class="python">async def unixsock_in_processor(reader, writer, in_queue: asyncio.Queue) -> None:
    while True:
        text = await reader.read(MaxTextLen)
        if text == b"":
            break
        await in_queue.put(text.decode("utf-8"))
</code></pre><br/>
Приходящие от собеседников сообщения отправляются в OUT_QUEUES очереди, из которых данные записываются в out сокет:<br/>
<br/>
<pre><code class="python">async def unixsock_out_processor(reader, writer, out_queue: asyncio.Queue) -> None:
    while True:
        text = await out_queue.get()
        writer.write(("[%s] %s" % (datetime.now(), text)).encode("utf-8"))
        await writer.drain()
</code></pre><br/>
При чтении из state сокета программа ищет в PEER_ALIVE словаре адрес собеседника. Если подключения к собеседнику ещё нет, то записывается пустая строка.<br/>
<br/>
<pre><code class="python">async def unixsock_state_processor(reader, writer, peer_name: str) -> None:
    peer_writer = PEER_ALIVES.get(peer_name)
    writer.write(
        b"" if peer_writer is None else (" ".join([
            str(i) for i in peer_writer.get_extra_info("peername")[:2]
        ]).encode("utf-8") + b"\n")
    )
    await writer.drain()
    writer.close()
</code></pre><br/>
При записи адреса в conn сокет запускается функция «инициатора» соединения:<br/>
<br/>
<pre><code class="python">async def unixsock_conn_processor(reader, writer) -> None:
    data = await reader.read(256)
    writer.close()
    host, port = data.decode("utf-8").split(" ")
    await initiator(host=host, port=int(port))
</code></pre><br/>
Рассмотрим инициатора. Сначала он, очевидно, открывает соединение до указанного хоста/порта и отправляет handshake сообщение со своим именем:<br/>
<br/>
<pre><code class="python"> 130 async def initiator(host, port):
 131     _id = repr((host, port))
 132     logging.info("%s: dialing", _id)
 133     reader, writer = await asyncio.open_connection(host, port)
 134     # Handshake message {{{
 135     writer.write(Msg(("handshake", MsgHandshake((
 136         ("peerName", OUR_NAME),
 137     )))).encode())
 138     # }}}
 139     await writer.drain()
</code></pre><br/>
Затем ждёт ответа от удалённой стороны. Пытается декодировать пришедший ответ по Msg ASN.1 схеме. Предполагаем, что всё сообщение будет отправлено одним TCP-сегментом и мы атомарно его получим при вызове .read(). Проверяем, что мы получили именно handshake сообщение.<br/>
<br/>
<pre><code class="python"> 141     # Wait for Handshake message {{{
 142     data = await reader.read(256)
 143     if data == b"":
 144         logging.warning("%s: no answer, disconnecting", _id)
 145         writer.close()
 146         return
 147     try:
 148         msg, _ = Msg().decode(data)
 149     except ASN1Error:
 150         logging.warning("%s: undecodable answer, disconnecting", _id)
 151         writer.close()
 152         return
 153     logging.info("%s: got %s message", _id, msg.choice)
 154     if msg.choice != "handshake":
 155         logging.warning("%s: unexpected message, disconnecting", _id)
 156         writer.close()
 157         return
 158     # }}}
</code></pre><br/>
Проверяем, что пришедшее имя собеседника нам известно. Если нет, то рвём соединение. Проверяем, не было ли у нас уже установлено с ним соединение (собеседник вновь дал команду на подключение к нам) и закрываем его. В IN_QUEUES очередь помещаются Python-строки с текстом сообщения, но имеется особое значение None, сигнализирующее msg_sender корутину прекратить работу, чтобы она забыла о своём writer, связанным с устаревшим TCP-соединением.<br/>
<br/>
<pre><code class="python"> 159     msg_handshake = msg.value
 160     peer_name = str(msg_handshake["peerName"])
 161     if peer_name not in THEIR_NAMES:
 162         logging.warning("unknown peer name: %s", peer_name)
 163         writer.close()
 164         return
 165     logging.info("%s: session established: %s", _id, peer_name)
 166     # Run text message sender, initialize transport decoder {{{
 167     peer_alive = PEER_ALIVES.pop(peer_name, None)
 168     if peer_alive is not None:
 169         peer_alive.close()
 170         await IN_QUEUES[peer_name].put(None)
 171     PEER_ALIVES[peer_name] = writer
 172     asyncio.ensure_future(msg_sender(peer_name, writer))
 173     # }}}
</code></pre><br/>
msg_sender принимает исходящие сообщения (подкладываемые в очередь из in сокета), сериализует их в MsgText сообщение и отправляет по TCP-соединению. Оно может оборваться в любой момент — это мы явно перехватываем.<br/>
<br/>
<pre><code class="python">async def msg_sender(peer_name: str, writer) -> None:
    in_queue = IN_QUEUES[peer_name]
    while True:
        text = await in_queue.get()
        if text is None:
            break
        writer.write(Msg(("text", MsgText((
            ("text", UTF8String(text)),
        )))).encode())
        try:
            await writer.drain()
        except ConnectionResetError:
            del PEER_ALIVES[peer_name]
            return
        logging.info("%s: sent %d characters message", peer_name, len(text))
</code></pre><br/>
В конце инициатор входит в бесконечный цикл чтения сообщений из сокета. Проверяет, текстовые ли это сообщения, и помещает в OUT_QUEUES очередь, из которой они будут отправлены в out сокет соответствующего собеседника. Почему нельзя просто делать .read() и декодировать сообщение? Потому что не исключена ситуация, когда несколько сообщений от пользователя будут агрегированы в буфере операционной системы и отправлены одним TCP-сегментом. Декодировать-то мы сможем первое, а дальше в буфере может остаться часть от последующего. При любой нештатной ситуации мы закрываем TCP-соединение и останавливаем msg_sender корутину (посылкой None в OUT_QUEUES очередь).<br/>
<br/>
<pre><code class="python"> 174     buf = b""
 175     # Wait for test messages {{{
 176     while True:
 177         data = await reader.read(MaxMsgLen)
 178         if data == b"":
 179             break
 180         buf += data
 181         if len(buf) > MaxMsgLen:
 182             logging.warning("%s: max buffer size exceeded", _id)
 183             break
 184         try:
 185             msg, tail = Msg().decode(buf)
 186         except ASN1Error:
 187             continue
 188         buf = tail
 189         if msg.choice != "text":
 190             logging.warning("%s: unexpected %s message", _id, msg.choice)
 191             break
 192         try:
 193             await msg_receiver(msg.value, peer_name)
 194         except ValueError as err:
 195             logging.warning("%s: %s", err)
 196             break
 197     # }}}
 198     logging.info("%s: disconnecting: %s", _id, peer_name)
 199     IN_QUEUES[peer_name].put(None)
 200     writer.close()

  66 async def msg_receiver(msg_text: MsgText, peer_name: str) -> None:
  67     text = str(msg_text["text"])
  68     logging.info("%s: received %d characters message", peer_name, len(text))
  69     await OUT_QUEUES[peer_name].put(text)
</code></pre><br/>
Вернёмся к основному коду. После создания всех корутин в момент запуска программы мы стартуем TCP-сервер. На каждое установленное соединение он создаёт responder (ответчик) корутину.<br/>
<br/>
<pre><code class="python">logging.basicConfig(
    level=logging.INFO,
    format="%(levelname)s %(asctime)s: %(funcName)s: %(message)s",
)
loop = asyncio.get_event_loop()
server = loop.run_until_complete(asyncio.start_server(responder, args.bind, args.port))
logging.info("Listening on: %s", server.sockets[0].getsockname())
loop.run_forever()
</code></pre><br/>
responder схож с initiator и зеркально выполняет все те же самые действия, но бесконечный цикл чтения сообщений запускается сразу же, для простоты. Сейчас протокол рукопожатия отсылает по одному сообщению с каждой стороны, но в дальнейшем, будет по два от инициатора соединения, после которых сразу же возможна отправка текстовых.<br/>
<br/>
<pre><code class="python">  72 async def responder(reader, writer):
  73     _id = writer.get_extra_info("peername")
  74     logging.info("%s: connected", _id)
  75     buf = b""
  76     msg_expected = "handshake"
  77     peer_name = None
  78     while True:
  79         # Read until we get Msg message {{{
  80         data = await reader.read(MaxMsgLen)
  81         if data == b"":
  82             logging.info("%s: closed connection", _id)
  83             break
  84         buf += data
  85         if len(buf) > MaxMsgLen:
  86             logging.warning("%s: max buffer size exceeded", _id)
  87             break
  88         try:
  89             msg, tail = Msg().decode(buf)
  90         except ASN1Error:
  91             continue
  92         buf = tail
  93         # }}}
  94         if msg.choice != msg_expected:
  95             logging.warning("%s: unexpected %s message", _id, msg.choice)
  96             break
  97         if msg_expected == "text":
  98             try:
  99                 await msg_receiver(msg.value, peer_name)
 100             except ValueError as err:
 101                 logging.warning("%s: %s", err)
 102                 break
 103         # Process Handshake message {{{
 104         elif msg_expected == "handshake":
 105             logging.info("%s: got %s message", _id, msg_expected)
 106             msg_handshake = msg.value
 107             peer_name = str(msg_handshake["peerName"])
 108             if peer_name not in THEIR_NAMES:
 109                 logging.warning("unknown peer name: %s", peer_name)
 110                 break
 111             writer.write(Msg(("handshake", MsgHandshake((
 112                 ("peerName", OUR_NAME),
 113             )))).encode())
 114             await writer.drain()
 115             logging.info("%s: session established: %s", _id, peer_name)
 116             peer_alive = PEER_ALIVES.pop(peer_name, None)
 117             if peer_alive is not None:
 118                 peer_alive.close()
 119                 await IN_QUEUES[peer_name].put(None)
 120             PEER_ALIVES[peer_name] = writer
 121             asyncio.ensure_future(msg_sender(peer_name, writer))
 122             msg_expected = "text"
 123         # }}}
 124     logging.info("%s: disconnecting", _id)
 125     if msg_expected == "text":
 126         IN_QUEUES[peer_name].put(None)
 127     writer.close()
</code></pre><br/>
<h2>Безопасный протокол</h2><br/>
Пришло время обезопасить наше общение. Что же мы подразумеваем под безопасностью и что хотим:<br/>
<br/>
<ul>
<li>конфиденциальность передаваемых сообщений;</li>
<li>аутентичность и целостность передаваемых сообщений — их изменение должно быть обнаружено;</li>
<li>защита от атак перепроигрывания (replay attack) — факт пропажи или повтора сообщений должен быть обнаружен (и мы решаем обрывать соединение);</li>
<li>идентификация и аутентификация собеседников по заранее вбитым публичным ключам — мы уже решили ранее, что делаем friend-to-friend сеть. Только после аутентификации мы поймём, с кем общаемся;</li>
<li>наличие <a href="https://ru.wikipedia.org/wiki/Perfect_forward_secrecy" rel="nofollow">perfect forward secrecy</a> свойства (PFS) — компрометация нашего долгоживущего ключа подписи не должна приводить к возможности чтения всей предыдущей переписки. Запись перехваченного трафика становится бесполезной;</li>
<li>действительность/валидность сообщений (транспортных и рукопожатия) только в пределах одной TCP-сессии. Вставка корректно подписанных/аутентифицированных сообщений из другой сессии (даже с этим же собеседником) не должна быть возможной;</li>
<li>пассивный наблюдатель не должен видеть ни идентификаторов пользователей, ни передаваемых долгоживущих публичных ключей, ни хэшей от них. Некая анонимность от пассивного наблюдателя.</li>
</ul><br/>
Удивительно, но этот минимум практически все хотят иметь в любом протоколе рукопожатия, и крайне мало из перечисленного в итоге выполняется для «доморощенных» протоколов. Вот и сейчас не будем изобретать нового. Я бы однозначно рекомендовал использовать <a href="http://noiseprotocol.org/" rel="nofollow">Noise framework</a> для построения протоколов, но выберем что-то попроще.<br/>
<br/>
Наиболее популярны два протокола:<br/>
<br/>
<ul>
<li><a href="https://ru.wikipedia.org/wiki/TLS" rel="nofollow">TLS</a> — сложнейший протокол с длинной историей багов, косяков, уязвимостей, плохой продуманности, сложности и недочётов (впрочем, к TLS 1.3 это мало относится). Но не рассматриваем его из-за переусложнённости.</li>
<li> <a href="https://ru.wikipedia.org/wiki/IPsec" rel="nofollow">IPsec</a> с <a href="https://ru.wikipedia.org/wiki/IKE" rel="nofollow">IKE</a> — не имеют серьёзных криптографических проблем, хотя тоже не просты. Если почитать про IKEv1 и IKEv2, то их истоком являются <a href="https://ru.wikipedia.org/wiki/STS_(%D0%BF%D1%80%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BB)" rel="nofollow">STS</a>, ISO/IEC IS 9798-3 и SIGMA (SIGn-and-MAc) протоколы — достаточно простые для реализации за один вечер.</li>
</ul><br/>
Чем SIGMA, как последнее звено развития STS/ISO протоколов, хорош? Он удовлетворяет всем нашим требованиям (в том числе «скрытия» идентификаторов собеседников), не имеет известных криптографических проблем. Он минималистичен — удаление хотя бы одного элемента из сообщения протокола приведёт к его небезопасности.<br/>
<br/>
Давайте пройдёмся от простейшего доморощенного протокола до SIGMA. Самая базовая интересующая нас операция это <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%B8%D1%84%D1%84%D0%B8-%D0%A5%D0%B5%D0%BB%D0%BB%D0%BC%D0%B0%D0%BD" rel="nofollow">согласование ключей</a>: функция, на выходе которой оба участника получат одно и то же значение, которое можно будет использовать в качестве симметричного ключа. Не вдаваясь в подробности: каждая из сторон генерирует эфемерную (использующуюся только в пределах одной сессии) ключевую пару (публичный и приватный ключи), обмениваются публичными ключами, вызывают функцию согласования, на вход которой передают свой приватный ключ и публичный ключ собеседника.<br/>
<br/>
<pre>
┌─────┐          ┌─────┐
│PeerA│          │PeerB│
└──┬──┘          └──┬──┘
   │   IdA, PubA    │ ╔════════════════════╗
   │───────────────>│ ║PrvA, PubA = DHgen()║
   │                │ ╚════════════════════╝
   │   IdB, PubB    │ ╔════════════════════╗
   │&lt;───────────────│ ║PrvB, PubB = DHgen()║
   │                │ ╚════════════════════╝
   ────┐    ╔═══════╧════════════╗
       │    ║Key = DH(PrvA, PubB)║
   &lt;───┘    ╚═══════╤════════════╝
   │                │
   │                │
</pre><br/>
<br/>
Любой может встрять-посередине и заменить публичные ключи своими собственными — в данном протоколе нет аутентификации собеседников. Добавим подпись долгоживущими ключами.<br/>
<br/>
<pre>
┌─────┐                            ┌─────┐
│PeerA│                            │PeerB│
└──┬──┘                            └──┬──┘
   │IdA, PubA, sign(SignPrvA, (PubA)) │ ╔═══════════════════════════╗
   │─────────────────────────────────>│ ║SignPrvA, SignPubA = load()║
   │                                  │ ║PrvA, PubA = DHgen()       ║
   │                                  │ ╚═══════════════════════════╝
   │IdB, PubB, sign(SignPrvB, (PubB)) │ ╔═══════════════════════════╗
   │&lt;─────────────────────────────────│ ║SignPrvB, SignPubB = load()║
   │                                  │ ║PrvB, PubB = DHgen()       ║
   │                                  │ ╚═══════════════════════════╝
   ────┐    ╔═════════════════════╗   │
       │    ║verify(SignPubB, ...)║   │
   &lt;───┘    ║Key = DH(PrvA, PubB) ║   │
   │        ╚═════════════════════╝   │
   │                                  │
</pre><br/>
<br/>
Такая подпись не подойдёт, так как она не привязана к конкретной сессии. Такие сообщения «подойдут» и для сессий с другими участниками. Подписываться должен весь контекст. Это вынуждает также добавить посылку ещё одного сообщения от A.<br/>
<br/>
Кроме того, критично добавить под подпись и собственный идентификатор, так как, в противном случае мы можем подменить IdXXX и переподписать сообщение ключом другого известного собеседника. Для предотвращения <a href="https://en.wikipedia.org/wiki/Reflection_attack" rel="nofollow">reflection атак</a>, необходимо, чтобы элементы под подписью находились в чётко заданных местах по своему смыслу: если A подписывает (PubA, PubB), то B должен подписывать (PubB, PubA). Это ещё и говорит о важности выбора структуры и формата сериализованных данных. Например, множества в ASN.1 DER кодировании сортируются: SET OF(PubA, PubB) будет идентичен SET OF(PubB, PubA).<br/>
<br/>
<pre>
┌─────┐                                       ┌─────┐
│PeerA│                                       │PeerB│
└──┬──┘                                       └──┬──┘
   │                 IdA, PubA                   │ ╔═══════════════════════════╗
   │────────────────────────────────────────────>│ ║SignPrvA, SignPubA = load()║
   │                                             │ ║PrvA, PubA = DHgen()       ║
   │                                             │ ╚═══════════════════════════╝
   │IdB, PubB, sign(SignPrvB, (IdB, PubA, PubB)) │ ╔═══════════════════════════╗
   │&lt;────────────────────────────────────────────│ ║SignPrvB, SignPubB = load()║
   │                                             │ ║PrvB, PubB = DHgen()       ║
   │                                             │ ╚═══════════════════════════╝
   │     sign(SignPrvA, (IdA, PubB, PubA))       │ ╔═════════════════════╗
   │────────────────────────────────────────────>│ ║verify(SignPubB, ...)║
   │                                             │ ║Key = DH(PrvA, PubB) ║
   │                                             │ ╚═════════════════════╝
   │                                             │
</pre><br/>
<br/>
Однако мы всё ещё не «доказали» что выработали одинаковый общий ключ для этой сессии. В принципе, можно обойтись и без этого шага — первое же транспортное сообщение будет невалидным, но мы хотим чтобы, когда рукопожатие завершилось, то были бы уверены, что всё действительно согласовано. На данный момент у нас на руках ISO/IEC IS 9798-3 протокол.<br/>
<br/>
Мы могли бы подписывать и сам выработанный ключ. Это опасно, так как не исключено, что в используемом алгоритме подписи могут быть утечки (пускай биты-на-подпись, но всё же утечки). Можно подписывать хэш от выработанного ключа, но утечка даже хэша от выработанного ключа может иметь ценность при brute-force атаке на функцию выработки. SIGMA использует MAC функцию, аутентифицирующую идентификатор отправителя.<br/>
<br/>
<pre>
┌─────┐                                            ┌─────┐
│PeerA│                                            │PeerB│
└──┬──┘                                            └──┬──┘
   │                    IdA, PubA                     │ ╔═══════════════════════════╗
   │─────────────────────────────────────────────────>│ ║SignPrvA, SignPubA = load()║
   │                                                  │ ║PrvA, PubA = DHgen()       ║
   │                                                  │ ╚═══════════════════════════╝
   │IdB, PubB, sign(SignPrvB, (PubA, PubB)), MAC(IdB) │ ╔═══════════════════════════╗
   │&lt;─────────────────────────────────────────────────│ ║SignPrvB, SignPubB = load()║
   │                                                  │ ║PrvB, PubB = DHgen()       ║
   │                                                  │ ╚═══════════════════════════╝
   │                                                  │ ╔═════════════════════╗
   │     sign(SignPrvA, (PubB, PubA)), MAC(IdA)       │ ║Key = DH(PrvA, PubB) ║
   │─────────────────────────────────────────────────>│ ║verify(Key, IdB)     ║
   │                                                  │ ║verify(SignPubB, ...)║
   │                                                  │ ╚═════════════════════╝
   │                                                  │
</pre><br/>
<br/>
В качестве оптимизации некоторые могут захотеть переиспользовать свои эфемерные ключи (что, конечно, плачевно для PFS). Например, мы сгенерировали ключевую пару, попытались подключиться, но TCP не был доступен или оборвался где-то на середине протокола. Жалко тратить потраченную энтропию и ресурсы процессора на новую пару. Поэтому введём так называемый cookie — псевдослучайное значение, которое защитит от возможных случайных replay атак при повторном использовании эфемерных публичных ключей. Из-за binding-а между cookie и эфемерным публичным ключом, публичный ключ противоположного участника можно убрать из подписи за ненадобностью.<br/>
<br/>
<pre>
┌─────┐                                                                 ┌─────┐
│PeerA│                                                                 │PeerB│
└──┬──┘                                                                 └──┬──┘
   │                          IdA, PubA, CookieA                           │ ╔═══════════════════════════╗
   │──────────────────────────────────────────────────────────────────────>│ ║SignPrvA, SignPubA = load()║
   │                                                                       │ ║PrvA, PubA = DHgen()       ║
   │                                                                       │ ╚═══════════════════════════╝
   │IdB, PubB, CookieB, sign(SignPrvB, (CookieA, CookieB, PubB)), MAC(IdB) │ ╔═══════════════════════════╗
   │&lt;──────────────────────────────────────────────────────────────────────│ ║SignPrvB, SignPubB = load()║
   │                                                                       │ ║PrvB, PubB = DHgen()       ║
   │                                                                       │ ╚═══════════════════════════╝
   │                                                                       │ ╔═════════════════════╗
   │          sign(SignPrvA, (CookieB, CookieA, PubA)), MAC(IdA)           │ ║Key = DH(PrvA, PubB) ║
   │──────────────────────────────────────────────────────────────────────>│ ║verify(Key, IdB)     ║
   │                                                                       │ ║verify(SignPubB, ...)║
   │                                                                       │ ╚═════════════════════╝
   │                                                                       │
</pre><br/>
<br/>
Наконец, мы хотим получить приватность наших идентификаторов собеседников от пассивного наблюдателя. Для этого SIGMA предлагает сначала обменяться эфемерными ключами, выработать общий ключ, на котором зашифровать аутентифицирующие и идентифицирующие сообщения. SIGMA описывает два варианта:<br/>
<br/>
<ul>
<li>SIGMA-I — защищает инициатора от активных атак, ответчика от пассивных: инициатор аутентифицирует ответчика и если что-то не сошлось, то свою идентификацию он не выдаёт. Ответчик же выдаёт свою идентификацию если с ним начать активный протокол. Пассивный наблюдатель ничего не узнает;<br/>
SIGMA-R — защищает ответчика от активных атак, инициатора от пассивных. Всё с точностью до наоборот, но в этом протоколе уже четыре сообщения рукопожатия передаётся.<br/>
<br/>
<br/>
Выбираем SIGMA-I как более похожий на то, что мы ожидаем от клиент-серверных привычных вещей: клиента узнает только аутентифицированный сервер, а сервер и так знают все. Плюс он проще в реализации из-за меньшего количества сообщений рукопожатия. Всё что мы вносим в протокол, так это шифрование части сообщения и перенос идентификатора A в шифрованную часть последнего сообщения:<br/>
<br/>
<pre>
┌─────┐                                                                        ┌─────┐
│PeerA│                                                                        │PeerB│
└──┬──┘                                                                        └──┬──┘
   │                                PubA, CookieA                                 │ ╔═══════════════════════════╗
   │─────────────────────────────────────────────────────────────────────────────>│ ║SignPrvA, SignPubA = load()║
   │                                                                              │ ║PrvA, PubA = DHgen()       ║
   │                                                                              │ ╚═══════════════════════════╝
   │PubB, CookieB, Enc((IdB, sign(SignPrvB, (CookieA, CookieB, PubB)), MAC(IdB))) │ ╔═══════════════════════════╗
   │&lt;─────────────────────────────────────────────────────────────────────────────│ ║SignPrvB, SignPubB = load()║
   │                                                                              │ ║PrvB, PubB = DHgen()       ║
   │                                                                              │ ╚═══════════════════════════╝
   │                                                                              │ ╔═════════════════════╗
   │       Enc((IdA, sign(SignPrvA, (CookieB, CookieA, PubA)), MAC(IdA)))         │ ║Key = DH(PrvA, PubB) ║
   │─────────────────────────────────────────────────────────────────────────────>│ ║verify(Key, IdB)     ║
   │                                                                              │ ║verify(SignPubB, ...)║
   │                                                                              │ ╚═════════════════════╝
   │                                                                              │
</pre><br/>
<br/>
<ul>
<li>Для подписи используется ГОСТ Р <a href="https://ru.wikipedia.org/wiki/%D0%93%D0%9E%D0%A1%D0%A2_%D0%A0_34.10-2012" rel="nofollow">34.10-2012</a> алгоритм с 256-бит ключами.</li>
<li>Для выработки общего ключа используется 34.10-2012 VKO.</li>
<li>В качестве MAC используется CMAC. Технически это особый режим работы блочного шифра, описанный в ГОСТ Р 34.13-2015. В качестве функции шифрования для этого режима — <a href="https://ru.wikipedia.org/wiki/Kuznechik" rel="nofollow">Кузнечик</a> (34.12-2015).</li>
<li>В качестве идентификатора собеседника используется хэш от его публичного ключа. В качестве хэша применяется <a href="https://ru.wikipedia.org/wiki/%D0%93%D0%9E%D0%A1%D0%A2_%D0%A0_34.11-2012" rel="nofollow">Стрибог-256</a> (34.11-2012 256 бит).</li>
</ul><br/>
<br/>
После рукопожатия у нас будет согласован общий ключ. Его мы можем использовать для аутентифицированного шифрования транспортных сообщений. Эта часть совсем простая и в ней сложно ошибиться: инкрементируем счётчик сообщений, шифруем сообщение, аутентифицируем (MAC) счётчик и шифротекст, отправляем. При приёме сообщения проверяем что счётчик имеет ожидаемое значение, аутентифицируем шифротекст с счётчиком, дешифруем. Каким ключом шифровать сообщения рукопожатия, транспортные, каким аутентифицировать? Использовать один ключ для всех этих задач опасно и неразумно. Необходимо вырабатывать ключи, используя специализированные функции <a href="https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F_%D1%84%D0%BE%D1%80%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F_%D0%BA%D0%BB%D1%8E%D1%87%D0%B0" rel="nofollow">KDF</a> (key derivation function). Опять же, не будем мудрить и что-то изобретать: <a href="https://en.wikipedia.org/wiki/HKDF" rel="nofollow">HKDF</a> давно известна, хорошо исследована и не имеет известных проблем. К сожалению, в родной библиотеке Python нет этой функции, поэтому используем <a href="https://pypi.org/project/hkdf/" rel="nofollow">hkdf</a> пакет. HKDF внутри использует <a href="https://ru.wikipedia.org/wiki/HMAC" rel="nofollow">HMAC</a>, который, в свою очередь, использует хэш-функцию. Пример реализации на Python на странице Wikipedia занимает считанные строки кода. Как и в случае с 34.10-2012, в качестве хэш-функции будем использовать Стрибог-256. Выход нашей функции согласования ключей будет называться сессионным ключом, из которого будут вырабатываться недостающие симметричные:<br/>
<br/>
<pre><code class="python">kdf = Hkdf(None, key_session, hash=GOST34112012256)
kdf.expand(b"handshake1-mac-identity")
kdf.expand(b"handshake1-enc")
kdf.expand(b"handshake1-mac")
kdf.expand(b"handshake2-mac-identity")
kdf.expand(b"handshake2-enc")
kdf.expand(b"handshake2-mac")
kdf.expand(b"transport-initiator-enc")
kdf.expand(b"transport-initiator-mac")
kdf.expand(b"transport-responder-enc")
kdf.expand(b"transport-responder-mac")
</code></pre><br/>
<h2>Структуры/схемы</h2><br/>
Рассмотрим какие же теперь ASN.1 структуры у нас получились для передачи всех этих данных:<br/>
<br/>
<pre><code class="python">class Msg(Choice):
    schema = ((
        ("text", MsgText()),
        ("handshake0", MsgHandshake0(expl=tag_ctxc(0))),
        ("handshake1", MsgHandshake1(expl=tag_ctxc(1))),
        ("handshake2", MsgHandshake2(expl=tag_ctxc(2))),
    ))

class MsgText(Sequence):
    schema = ((
        ("payload", MsgTextPayload()),
        ("payloadMac", MAC()),
    ))

class MsgTextPayload(Sequence):
    schema = ((
        ("nonce", Integer(bounds=(0, float("+inf")))),
        ("ciphertext", OctetString(bounds=(1, MaxTextLen))),
    ))

class MsgHandshake0(Sequence):
    schema = ((
        ("cookieInitiator", Cookie()),
        ("pubKeyInitiator", PubKey()),
    ))

class MsgHandshake1(Sequence):
    schema = ((
        ("cookieResponder", Cookie()),
        ("pubKeyResponder", PubKey()),
        ("ukm", OctetString(bounds=(8, 8))),
        ("ciphertext", OctetString()),
        ("ciphertextMac", MAC()),
    ))

class MsgHandshake2(Sequence):
    schema = ((
        ("ciphertext", OctetString()),
        ("ciphertextMac", MAC()),
    ))

class HandshakeTBE(Sequence):
    schema = ((
        ("identity", OctetString(bounds=(32, 32))),
        ("signature", OctetString(bounds=(64, 64))),
        ("identityMac", MAC()),
    ))

class HandshakeTBS(Sequence):
    schema = ((
        ("cookieTheir", Cookie()),
        ("cookieOur", Cookie()),
        ("pubKeyOur", PubKey()),
    ))

class Cookie(OctetString): bounds = (16, 16)
class PubKey(OctetString): bounds = (64, 64)
class MAC(OctetString): bounds = (16, 16)
</code></pre><br/>
HandshakeTBS — то, что будет подписываться (to be signed). HandshakeTBE — то, что будет зашифровано (to be encrypted). Обращаю внимание на поле ukm в MsgHandshake1. 34.10 VKO, для ещё большей рандомизации вырабатываемых ключей, включает параметр UKM (user keying material) — просто дополнительная энтропия.<br/>
<br/>
<h2>Добавление криптографии в код</h2><br/>
Рассмотрим лишь только внесённые к оригинальному коду изменения, так как каркас остался прежним (на самом деле, сначала была написана окончательная реализация, а потом из неё выпиливалась вся криптография).<br/>
<br/>
Так как аутентификация и идентификация собеседников будет проводится по публичным ключам, то теперь их надо где-то долговременно хранить. Для простоты используем JSON такого вида:<br/>
<br/>
<pre><code class="python">{
    "our": {
        "prv": "21254cf66c15e0226ef2669ceee46c87b575f37f9000272f408d0c9283355f98",
        "pub": "938c87da5c55b27b7f332d91b202dbef2540979d6ceaa4c35f1b5bfca6df47df0bdae0d3d82beac83cec3e353939489d9981b7eb7a3c58b71df2212d556312a1"
    },
    "their": {
        "alice": "d361a59c25d2ca5a05d21f31168609deeec100570ac98f540416778c93b2c7402fd92640731a707ec67b5410a0feae5b78aeec93c4a455a17570a84f2bc21fce",
        "bob": "aade1207dd85ecd283272e7b69c078d5fae75b6e141f7649ad21962042d643512c28a2dbdc12c7ba40eb704af920919511180c18f4d17e07d7f5acd49787224a"
    }
}
</code></pre><br/>
our — наша ключевая пара, шестнадцатеричные приватный и публичные ключи. their — имена собеседников и их публичные ключи. Изменим аргументы командной строки и добавим постобработку JSON данных:<br/>
<br/>
<pre><code class="python">from pygost import gost3410
from pygost.gost34112012256 import GOST34112012256

CURVE = gost3410.GOST3410Curve(
    *gost3410.CURVE_PARAMS["GostR3410_2001_CryptoPro_A_ParamSet"]
)

parser = argparse.ArgumentParser(description="GOSTIM")
parser.add_argument(
    "--keys-gen",
    action="store_true",
    help="Generate JSON with our new keypair",
)
parser.add_argument(
    "--keys",
    default="keys.json",
    required=False,
    help="JSON with our and their keys",
)
parser.add_argument(
    "--bind",
    default="::1",
    help="Address to listen on",
)
parser.add_argument(
    "--port",
    type=int,
    default=6666,
    help="Port to listen on",
)
args = parser.parse_args()

if args.keys_gen:
    prv_raw = urandom(32)
    pub = gost3410.public_key(CURVE, gost3410.prv_unmarshal(prv_raw))
    pub_raw = gost3410.pub_marshal(pub)
    print(json.dumps({
        "our": {"prv": hexenc(prv_raw), "pub": hexenc(pub_raw)},
        "their": {},
    }))
    exit(0)

# Parse and unmarshal our and their keys {{{
with open(args.keys, "rb") as fd:
    _keys = json.loads(fd.read().decode("utf-8"))
KEY_OUR_SIGN_PRV = gost3410.prv_unmarshal(hexdec(_keys["our"]["prv"]))
_pub = hexdec(_keys["our"]["pub"])
KEY_OUR_SIGN_PUB = gost3410.pub_unmarshal(_pub)
KEY_OUR_SIGN_PUB_HASH = OctetString(GOST34112012256(_pub).digest())
for peer_name, pub_raw in _keys["their"].items():
    _pub = hexdec(pub_raw)
    KEYS[GOST34112012256(_pub).digest()] = {
        "name": peer_name,
        "pub": gost3410.pub_unmarshal(_pub),
    }
# }}}
</code></pre><br/>
Приватный ключ 34.10 алгоритма — случайное число. Размером 256-бит для 256-бит эллиптических кривых. PyGOST работает не с набором байт, а с <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%BB%D0%B8%D0%BD%D0%BD%D0%B0%D1%8F_%D0%B0%D1%80%D0%B8%D1%84%D0%BC%D0%B5%D1%82%D0%B8%D0%BA%D0%B0" rel="nofollow">большими числами</a>, поэтому наш приватный ключ (urandom(32)) необходимо преобразовать в число, используя gost3410.prv_unmarshal(). Публичный ключ детерминировано вычисляется из приватного, используя gost3410.public_key(). Публичный ключ 34.10 — два больших числа, которые тоже нужно преобразовать в байтовую последовательность для удобства хранения и передачи, используя gost3410.pub_marshal().<br/>
<br/>
После чтения JSON файла, публичные ключи, соответственно, нужно преобразовать назад, используя gost3410.pub_unmarshal(). Так как нам будут приходить идентификаторы собеседников в виде хэша от публичного ключа, то их можно сразу же заранее вычислить и поместить в словарь для быстрого поиска. Стрибог-256 хэш это gost34112012256.GOST34112012256(), полностью удовлетворяющий hashlib интерфейсу хэш-функций.<br/>
<br/>
Как изменилась корутина инициатора? Всё, как по схеме рукопожатия: генерируем cookie (128-бит вполне предостаточно), эфемерную ключевую пару 34.10, которая будет использоваться для VKO функции согласования ключей.<br/>
<br/>
<pre><code class="python"> 395 async def initiator(host, port):
 396     _id = repr((host, port))
 397     logging.info("%s: dialing", _id)
 398     reader, writer = await asyncio.open_connection(host, port)
 399     # Generate our ephemeral public key and cookie, send Handshake 0 message {{{
 400     cookie_our = Cookie(urandom(16))
 401     prv = gost3410.prv_unmarshal(urandom(32))
 402     pub_our = gost3410.public_key(CURVE, prv)
 403     pub_our_raw = PubKey(gost3410.pub_marshal(pub_our))
 404     writer.write(Msg(("handshake0", MsgHandshake0((
 405         ("cookieInitiator", cookie_our),
 406         ("pubKeyInitiator", pub_our_raw),
 407     )))).encode())
 408     # }}}
 409     await writer.drain()
</code></pre><br/>
<ul>
<li>ждём ответа и декодируем пришедшее Msg сообщение;</li>
<li>убеждаемся что получили handshake1;</li>
<li>декодируем эфемерный публичный ключ противоположной стороны и вычисляем сессионный ключ;</li>
<li>вырабатываем симметричные ключи необходимые для обработки TBE части сообщения.</li>
</ul><br/>
<pre><code class="python"> 423     logging.info("%s: got %s message", _id, msg.choice)
 424     if msg.choice != "handshake1":
 425         logging.warning("%s: unexpected message, disconnecting", _id)
 426         writer.close()
 427         return
 428     # }}}
 429     msg_handshake1 = msg.value
 430     # Validate Handshake message {{{
 431     cookie_their = msg_handshake1["cookieResponder"]
 432     pub_their_raw = msg_handshake1["pubKeyResponder"]
 433     pub_their = gost3410.pub_unmarshal(bytes(pub_their_raw))
 434     ukm_raw = bytes(msg_handshake1["ukm"])
 435     ukm = ukm_unmarshal(ukm_raw)
 436     key_session = kek_34102012256(CURVE, prv, pub_their, ukm, mode=2001)
 437     kdf = Hkdf(None, key_session, hash=GOST34112012256)
 438     key_handshake1_mac_identity = kdf.expand(b"handshake1-mac-identity")
 439     key_handshake1_enc = kdf.expand(b"handshake1-enc")
 440     key_handshake1_mac = kdf.expand(b"handshake1-mac")
</code></pre><br/>
UKM это 64-бит число (urandom(8)), которое тоже требует десериализации из байтового представления, используя gost3410_vko.ukm_unmarshal(). VKO функция для 34.10-2012 256-бит это gost3410_vko.kek_34102012256() (KEK — key encryption key).<br/>
<br/>
Выработанный сессионный ключ уже является 256-бит байтовой псевдослучайной последовательностью. Поэтому его сразу же можно использовать в HKDF функции. Так как GOST34112012256 удовлетворяет hashlib интерфейсу, то его можно сразу же использовать в Hkdf классе. Соль (первый аргумент Hkdf) мы не указываем, так как выработанный ключ из-за эфемерности участвующих ключевых пар будет разным для каждой сессии и в нём уже достаточно энтропии. kdf.expand() по умолчанию уже выдаёт ключи длиной 256-бит, требуемые для Кузнечика в дальнейшем.<br/>
<br/>
Далее проверяются TBE и TBS части пришедшего сообщения:<br/>
<br/>
<ul>
<li>вычисляется и проверяется MAC над пришедшим шифротекстом;</li>
<li>дешифруется шифротекст;</li>
<li>декодируется TBE структура;</li>
<li>из неё берётся идентификатор собеседника и проверяется известен ли он нам вообще;</li>
<li>вычисляется и проверятся MAC над этим идентификатором;</li>
<li>проверяется подпись над TBS структурой, в которую входят cookie обеих сторон и публичный эфемерный ключ противоположной стороны. Подпись проверяется долгоживущим ключом подписи собеседника.</li>
</ul><br/>
<pre><code class="python"> 441     try:
 442         peer_name = validate_tbe(
 443             msg_handshake1,
 444             key_handshake1_mac_identity,
 445             key_handshake1_enc,
 446             key_handshake1_mac,
 447             cookie_our,
 448             cookie_their,
 449             pub_their_raw,
 450         )
 451     except ValueError as err:
 452         logging.warning("%s: %s, disconnecting", _id, err)
 453         writer.close()
 454         return
 455     # }}}

 128 def validate_tbe(
 129         msg_handshake: Union[MsgHandshake1, MsgHandshake2],
 130         key_mac_identity: bytes,
 131         key_enc: bytes,
 132         key_mac: bytes,
 133         cookie_their: Cookie,
 134         cookie_our: Cookie,
 135         pub_key_our: PubKey,
 136 ) -> str:
 137     ciphertext = bytes(msg_handshake["ciphertext"])
 138     mac_tag = mac(GOST3412Kuznechik(key_mac).encrypt, KUZNECHIK_BLOCKSIZE, ciphertext)
 139     if not compare_digest(mac_tag, bytes(msg_handshake["ciphertextMac"])):
 140         raise ValueError("invalid MAC")
 141     plaintext = ctr(
 142         GOST3412Kuznechik(key_enc).encrypt,
 143         KUZNECHIK_BLOCKSIZE,
 144         ciphertext,
 145         8 * b"\x00",
 146     )
 147     try:
 148         tbe, _ = HandshakeTBE().decode(plaintext)
 149     except ASN1Error:
 150         raise ValueError("can not decode TBE")
 151     key_sign_pub_hash = bytes(tbe["identity"])
 152     peer = KEYS.get(key_sign_pub_hash)
 153     if peer is None:
 154         raise ValueError("unknown identity")
 155     mac_tag = mac(
 156         GOST3412Kuznechik(key_mac_identity).encrypt,
 157         KUZNECHIK_BLOCKSIZE,
 158         key_sign_pub_hash,
 159     )
 160     if not compare_digest(mac_tag, bytes(tbe["identityMac"])):
 161         raise ValueError("invalid identity MAC")
 162     tbs = HandshakeTBS((
 163         ("cookieTheir", cookie_their),
 164         ("cookieOur", cookie_our),
 165         ("pubKeyOur", pub_key_our),
 166     ))
 167     if not gost3410.verify(
 168         CURVE,
 169         peer["pub"],
 170         GOST34112012256(tbs.encode()).digest(),
 171         bytes(tbe["signature"]),
 172     ):
 173         raise ValueError("invalid signature")
 174     return peer["name"]
</code></pre><br/>
Как уже писал выше, 34.13-2015 описывает различные <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B6%D0%B8%D0%BC_%D1%88%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F" rel="nofollow">режимы работы блочных шифров</a> из 34.12-2015. Среди них есть режим выработки имитовставки, вычисления MAC-а. В PyGOST это gost3413.mac(). Этот режим требует передачи функции шифрования (принимающая и возвращающая один блок данных), размера шифроблока и, собственно, самих данных. Почему нельзя hardcode-ить размер шифроблока? 34.12-2015 описывает не только 128-битный шифр Кузнечик, но ещё и 64-битную <a href="https://ru.wikipedia.org/wiki/%D0%93%D0%9E%D0%A1%D0%A2_28147-89_%C2%AB%D0%9C%D0%B0%D0%B3%D0%BC%D0%B0%C2%BB" rel="nofollow">Магму</a> — немного изменённый ГОСТ 28147-89, созданный ещё в КГБ и до сих пор имеющий один из самых высоких порогов безопасности.<br/>
<br/>
Кузнечик инициализируется gost.3412.GOST3412Kuznechik(key) вызовом и возвращает объект с .encrypt()/.decrypt() методами, пригодными для передачи в 34.13 функции. MAC вычисляется следующим образом: gost3413.mac(GOST3412Kuznechik(key).encrypt, KUZNECHIK_BLOCKSIZE, ciphertext). Для сравнения вычисленного и пришедшего MAC-а нельзя использовать обычное сравнение (==) байтовых строк, так как это операция даёт утечки времени сравнения, что, в общем случае, может приводить к фатальным уязвимостям типа <a href="https://en.wikipedia.org/wiki/BEAST_(computer_security)#Attacks_against_TLS/SSL" rel="nofollow">BEAST</a> атаки на TLS. В Python имеется специальная hmac.compare_digest функция для этого.<br/>
<br/>
Функция блочного шифра может зашифровать только один блок данных. Для большего количества, да ещё и не кратной длины, необходимо использовать режим шифрования. В 34.13-2015 описаны следующие: ECB, CTR, OFB, CBC, CFB. У каждого свои допустимые сферы применения и характеристики. К огромному сожалению, у нас до сих пор нет стандартизованных <a href="https://ru.wikipedia.org/wiki/AEAD-%D1%80%D0%B5%D0%B6%D0%B8%D0%BC_%D0%B1%D0%BB%D0%BE%D1%87%D0%BD%D0%BE%D0%B3%D0%BE_%D1%88%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F" rel="nofollow">аутентифицированных режимов шифрования</a> (типа CCM, OCB, GCM и подобных) — мы вынуждены самостоятельно хотя бы добавлять MAC. Я выбираю <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B6%D0%B8%D0%BC_%D1%88%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F#Counter_mode_(CTR)" rel="nofollow">режим счётчика</a> (CTR): он не требует дополнения до размера блока, может распараллеливаться, использует только функцию шифрования, может быть безопасно использован для шифрования большого количества сообщений (в отличии от CBC, у которого относительно быстро начинаются коллизии).<br/>
<br/>
Как и .mac(), .ctr() принимает похожие данные на входе: ciphertext = gost3413.ctr(GOST3412Kuznechik(key).encrypt, KUZNECHIK_BLOCKSIZE, plaintext, iv). Требуется задание вектора инициализации, длиной ровно в половину шифроблока. Если наш ключ шифрования используется только для шифрования одного сообщения (пускай и из нескольких блоков), то безопасно задать нулевой вектор инициализации. Для шифрования handshake сообщений у нас используется каждый раз отдельный ключ.<br/>
<br/>
Проверка подписи gost3410.verify() тривиальна: передаём эллиптическую кривую в пределах которой работаем (её мы просто фиксируем в нашем GOSTIM протоколе), публичный ключ подписанта (не забываем, что это должен быть кортеж из двух больших чисел, а не байтовая строка), 34.11-2012 хэш и сама пришедшая подпись.<br/>
<br/>
Далее, в инициаторе мы подготавливаем и отсылаем handshake2 сообщение рукопожатия, производя те же самые действия что мы и делали при проверке, только симметрично: подпись на своих ключах вместо проверки, и т.п…<br/>
<br/>
<pre><code class="python"> 456     # Prepare and send Handshake 2 message {{{
 457     tbs = HandshakeTBS((
 458         ("cookieTheir", cookie_their),
 459         ("cookieOur", cookie_our),
 460         ("pubKeyOur", pub_our_raw),
 461     ))
 462     signature = gost3410.sign(
 463         CURVE,
 464         KEY_OUR_SIGN_PRV,
 465         GOST34112012256(tbs.encode()).digest(),
 466     )
 467     key_handshake2_mac_identity = kdf.expand(b"handshake2-mac-identity")
 468     mac_tag = mac(
 469         GOST3412Kuznechik(key_handshake2_mac_identity).encrypt,
 470         KUZNECHIK_BLOCKSIZE,
 471         bytes(KEY_OUR_SIGN_PUB_HASH),
 472     )
 473     tbe = HandshakeTBE((
 474         ("identity", KEY_OUR_SIGN_PUB_HASH),
 475         ("signature", OctetString(signature)),
 476         ("identityMac", MAC(mac_tag)),
 477     ))
 478     tbe_raw = tbe.encode()
 479     key_handshake2_enc = kdf.expand(b"handshake2-enc")
 480     key_handshake2_mac = kdf.expand(b"handshake2-mac")
 481     ciphertext = ctr(
 482         GOST3412Kuznechik(key_handshake2_enc).encrypt,
 483         KUZNECHIK_BLOCKSIZE,
 484         tbe_raw,
 485         8 * b"\x00",
 486     )
 487     mac_tag = mac(
 488         GOST3412Kuznechik(key_handshake2_mac).encrypt,
 489         KUZNECHIK_BLOCKSIZE,
 490         ciphertext,
 491     )
 492     writer.write(Msg(("handshake2", MsgHandshake2((
 493         ("ciphertext", OctetString(ciphertext)),
 494         ("ciphertextMac", MAC(mac_tag)),
 495     )))).encode())
 496     # }}}
 497     await writer.drain()
 498     logging.info("%s: session established: %s", _id, peer_name)
 </code></pre><br/>
Когда сессия установлена, то вырабатываются транспортные ключи (отдельный ключ для шифрования, для аутентификации, для каждой из сторон), инициализируется Кузнечик для дешифрования и проверки MAC-а:<br/>
<br/>
<pre><code class="python"> 499     # Run text message sender, initialize transport decoder {{{
 500     key_initiator_enc = kdf.expand(b"transport-initiator-enc")
 501     key_initiator_mac = kdf.expand(b"transport-initiator-mac")
 502     key_responder_enc = kdf.expand(b"transport-responder-enc")
 503     key_responder_mac = kdf.expand(b"transport-responder-mac")
 ...
 509     asyncio.ensure_future(msg_sender(
 510         peer_name,
 511         key_initiator_enc,
 512         key_initiator_mac,
 513         writer,
 514     ))
 515     encrypter = GOST3412Kuznechik(key_responder_enc).encrypt
 516     macer = GOST3412Kuznechik(key_responder_mac).encrypt
 517     # }}}
 519     nonce_expected = 0

 520     # Wait for test messages {{{
 521     while True:
 522         data = await reader.read(MaxMsgLen)
 ...
 530             msg, tail = Msg().decode(buf)
 ...
 537         try:
 538             await msg_receiver(
 539                 msg.value,
 540                 nonce_expected,
 541                 macer,
 542                 encrypter,
 543                 peer_name,
 544             )
 545         except ValueError as err:
 546             logging.warning("%s: %s", err)
 547             break
 548         nonce_expected += 1
 549     # }}}
</code></pre><br/>
msg_sender корутина теперь шифрует сообщения, перед отправкой в TCP-соединение. У каждого сообщения монотонно возрастающий nonce, также являющийся и вектором инициализации при шифровании в режиме счётчика. У каждого сообщения и блока сообщения гарантированно будут отличающиеся значения счётчика.<br/>
<br/>
<pre><code class="python">async def msg_sender(peer_name: str, key_enc: bytes, key_mac: bytes, writer) -> None:
    nonce = 0
    encrypter = GOST3412Kuznechik(key_enc).encrypt
    macer = GOST3412Kuznechik(key_mac).encrypt
    in_queue = IN_QUEUES[peer_name]
    while True:
        text = await in_queue.get()
        if text is None:
            break
        ciphertext = ctr(
            encrypter,
            KUZNECHIK_BLOCKSIZE,
            text.encode("utf-8"),
            long2bytes(nonce, 8),
        )
        payload = MsgTextPayload((
            ("nonce", Integer(nonce)),
            ("ciphertext", OctetString(ciphertext)),
        ))
        mac_tag = mac(macer, KUZNECHIK_BLOCKSIZE, payload.encode())
        writer.write(Msg(("text", MsgText((
            ("payload", payload),
            ("payloadMac", MAC(mac_tag)),
        )))).encode())
        nonce += 1
</code></pre><br/>
Приходящие сообщения обрабатываются корутиной msg_receiver, занимающейся аутентификацией и дешифрацией:<br/>
<br/>
<pre><code class="python">async def msg_receiver(
        msg_text: MsgText,
        nonce_expected: int,
        macer,
        encrypter,
        peer_name: str,
) -> None:
    payload = msg_text["payload"]
    if int(payload["nonce"]) != nonce_expected:
        raise ValueError("unexpected nonce value")
    mac_tag = mac(macer, KUZNECHIK_BLOCKSIZE, payload.encode())
    if not compare_digest(mac_tag, bytes(msg_text["payloadMac"])):
        raise ValueError("invalid MAC")
    plaintext = ctr(
        encrypter,
        KUZNECHIK_BLOCKSIZE,
        bytes(payload["ciphertext"]),
        long2bytes(nonce_expected, 8),
    )
    text = plaintext.decode("utf-8")
    await OUT_QUEUES[peer_name].put(text)
</code></pre><br/>
<h2>Заключение</h2><br/>
GOSTIM предполагается использовать исключительно в учебных целях (так как не покрыт тестами, как минимум)! Исходный код программы можно скачать <a href="http://www.pygost.cypherpunks.ru/gostim.txz" rel="nofollow">тут</a> (Стрибог-256 хэш: 995bbd368c04e50a481d138c5fa2e43ec7c89bc77743ba8dbabee1fde45de120). Как и все мои проекты, типа <a href="http://www.gogost.cypherpunks.ru/" rel="nofollow">GoGOST</a>, <a href="http://www.pyderasn.cypherpunks.ru/" rel="nofollow">PyDERASN</a>, <a href="http://www.nncpgo.org/" rel="nofollow">NNCP</a>, <a href="http://www.govpn.info/" rel="nofollow">GoVPN</a>, GOSTIM является полностью <a href="https://www.gnu.org/philosophy/free-sw.ru.html" rel="nofollow">свободным ПО</a>, распространяемым на условиях <a href="https://www.gnu.org/licenses/gpl-3.0.ru.html" rel="nofollow">GPLv3+</a>.<br/>
<br/>
<a href="http://www.stargrave.org/" rel="nofollow">Сергей Матвеев</a>, <a href="http://www.cypherpunks.ru/" rel="nofollow">шифропанк</a>, член <a href="https://www.fsf.org/" rel="nofollow">Фонда СПО</a>, Python/Go-разработчик, главный специалист ФГУП «НТЦ „Атлас“.</li>
</ul></div></div> <!----> <!----></div> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bpython%5D" class="tm-tags-list__link">python</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bpygost%5D" class="tm-tags-list__link">pygost</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bpyderasn%5D" class="tm-tags-list__link">pyderasn</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Basyncio%5D" class="tm-tags-list__link">asyncio</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bsuckless%5D" class="tm-tags-list__link">suckless</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Basn.1%5D" class="tm-tags-list__link">asn.1</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bim%5D" class="tm-tags-list__link">im</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/hub/p2p/" class="tm-hubs-list__link">
    Децентрализованные сети
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/infosecurity/" class="tm-hubs-list__link">
    Информационная безопасность
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/crypto/" class="tm-hubs-list__link">
    Криптография
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/python/" class="tm-hubs-list__link">
    Python
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/programming/" class="tm-hubs-list__link">
    Программирование
  </a></li></ul></div></div></article></div> <!----></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_medium"><title>Всего голосов 23: ↑21 и ↓2</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-rating"></use></svg> <span title="Всего голосов 23: ↑21 и ↓2" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_medium">+19</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">5.8K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    64
  </span></button> <!----> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> </div></div> <!----> <!----> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="/ru/users/stargrave2/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><svg class="tm-svg-img tm-image-placeholder tm-image-placeholder_pink"><!----> <use xlink:href="/img/megazord-v24.ce74655c.svg#placeholder-user"></use></svg></div></a> <div class="tm-user-card__meta"><div title=" 98 голосов " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    64.7
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">0</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title_variant-article"><!----> <a href="/ru/users/stargrave2/" class="tm-user-card__nickname tm-user-card__nickname_variant-article">
          @stargrave2
        </a> <!----></div> <p class="tm-user-card__short-info tm-user-card__short-info_variant-article">Пользователь</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-article"><!----> <!----> <!----> <!----> <!----></div></div> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----></section> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="/ru/post/452200/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментарии 7 
    </span></a> <!----></div></div></div> <div class="tm-ad-banner__container tm-page-article__banner"><!----> <div id="articleBottomBanner" class="tm-ad-banner"></div></div> <!----> <!----> <!----> <!----> </div></div></div></div></div> <div class="tm-page__sidebar"><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__ads tm-layout-sidebar__ads_initial"><div class="tm-ad-banner__container tm-layout-sidebar__banner"><!----> <div id="sidebarBanner" class="tm-ad-banner"></div></div></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----> <!----></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/post/452200/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/post/452200/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2021 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"452200":{"id":"452200","timePublished":"2019-05-16T15:30:59+00:00","isCorporative":false,"lang":"ru","titleHtml":"GOSTIM: P2P F2F E2EE IM за один вечер с ГОСТ-криптографией","leadData":{"textHtml":"Будучи разработчиком \u003Ca href=\"http:\u002F\u002Fwww.pygost.cypherpunks.ru\u002F\" rel=\"nofollow\"\u003EPyGOST\u003C\u002Fa\u003E библиотеки (ГОСТовые криптографические примитивы на чистом Python), я нередко получаю вопросы о том, как на коленке реализовать простейший безопасный обмен сообщениями. Многие считают прикладную криптографию достаточно простой штукой, и .encrypt() вызова у блочного шифра будет достаточно для безопасной отсылки по каналу связи. Другие же считают, что прикладная криптография &mdash; удел немногих, и приемлемо, что богатые компании типа Telegram с олимпиадниками-математиками \u003Ca href=\"https:\u002F\u002Feprint.iacr.org\u002F2015\u002F1177.pdf\" rel=\"nofollow\"\u003Eне могут реализовать\u003C\u002Fa\u003E безопасный протокол.\u003Cbr\u003E\r\n\u003Cbr\u003E\r\nВсё это побудило меня написать данную статью, чтобы показать, что реализация криптографических протоколов и безопасного IM-а не такая сложная задача. Однако изобретать собственные протоколы аутентификации и согласования ключей не стоит.\u003Cbr\u003E\r\n\u003Cbr\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg alt=\"Hearing\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F4e2\u002F2bb\u002Ff04\u002F4e22bbf0480a8181bcbb2054c6f95815.jpg\"\u003E\u003C\u002Fdiv\u003E\u003Cbr\u003E\r\nВ статье будет написан \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002FPeer-to-peer\" rel=\"nofollow\"\u003Epeer-to-peer\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002FFriend-to-friend\" rel=\"nofollow\"\u003Efriend-to-friend\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002F%D0%A1%D0%BA%D0%B2%D0%BE%D0%B7%D0%BD%D0%BE%D0%B5_%D1%88%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5\" rel=\"nofollow\"\u003Eend-to-end зашифрованный\u003C\u002Fa\u003E instant messenger с \u003Ca href=\"http:\u002F\u002Fwebee.technion.ac.il\u002F~hugo\u002Fsigma-pdf.pdf\" rel=\"nofollow\"\u003ESIGMA-I\u003C\u002Fa\u003E протоколом аутентификации и согласования ключей (на базе которого реализован \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002FIKE\" rel=\"nofollow\"\u003EIPsec IKE\u003C\u002Fa\u003E), используя исключительно ГОСТовые криптографические алгоритмы PyGOST библиотеки и ASN.1 кодирование сообщений библиотекой \u003Ca href=\"http:\u002F\u002Fwww.pyderasn.cypherpunks.ru\u002F\" rel=\"nofollow\"\u003EPyDERASN\u003C\u002Fa\u003E (про которую я уже \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F444272\u002F\"\u003Eписал раньше\u003C\u002Fa\u003E). Необходимое условие: он должен быть настолько прост, чтобы его можно было написать с нуля за один вечер (или рабочий день), иначе это уже не простая программа. В ней наверняка есть ошибки, излишние сложности, недочёты, плюс это моя первая программа с использованием asyncio библиотеки.\u003Cbr\u003E","imageUrl":null,"buttonTextHtml":"Читать дальше &rarr;","image":null},"editorVersion":"1.0","postType":"article","postLabels":[],"author":{"scoreStats":{"score":64.7,"votesCount":98},"rating":0,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"898223","alias":"stargrave2","fullname":null,"avatarUrl":null,"speciality":"Пользователь"},"statistics":{"commentsCount":7,"favoritesCount":64,"readingCount":5773,"score":19,"votesCount":23},"hubs":[{"relatedData":null,"id":"33","alias":"p2p","type":"collective","title":"Децентрализованные сети","titleHtml":"Децентрализованные сети","isProfiled":false},{"relatedData":null,"id":"50","alias":"infosecurity","type":"collective","title":"Информационная безопасность","titleHtml":"Информационная безопасность","isProfiled":true},{"relatedData":null,"id":"118","alias":"crypto","type":"collective","title":"Криптография","titleHtml":"Криптография","isProfiled":true},{"relatedData":null,"id":"340","alias":"python","type":"collective","title":"Python","titleHtml":"Python","isProfiled":true},{"relatedData":null,"id":"359","alias":"programming","type":"collective","title":"Программирование","titleHtml":"Программирование","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"},{"id":"6","alias":"admin","title":"Администрирование"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003EБудучи разработчиком \u003Ca href=\"http:\u002F\u002Fwww.pygost.cypherpunks.ru\u002F\" rel=\"nofollow\"\u003EPyGOST\u003C\u002Fa\u003E библиотеки (ГОСТовые криптографические примитивы на чистом Python), я нередко получаю вопросы о том, как на коленке реализовать простейший безопасный обмен сообщениями. Многие считают прикладную криптографию достаточно простой штукой, и .encrypt() вызова у блочного шифра будет достаточно для безопасной отсылки по каналу связи. Другие же считают, что прикладная криптография — удел немногих, и приемлемо, что богатые компании типа Telegram с олимпиадниками-математиками \u003Ca href=\"https:\u002F\u002Feprint.iacr.org\u002F2015\u002F1177.pdf\" rel=\"nofollow\"\u003Eне могут реализовать\u003C\u002Fa\u003E безопасный протокол.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВсё это побудило меня написать данную статью, чтобы показать, что реализация криптографических протоколов и безопасного IM-а не такая сложная задача. Однако изобретать собственные протоколы аутентификации и согласования ключей не стоит.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg alt=\"Hearing\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780q1\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F4e2\u002F2bb\u002Ff04\u002F4e22bbf0480a8181bcbb2054c6f95815.jpg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F4e2\u002F2bb\u002Ff04\u002F4e22bbf0480a8181bcbb2054c6f95815.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nВ статье будет написан \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002FPeer-to-peer\" rel=\"nofollow\"\u003Epeer-to-peer\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002FFriend-to-friend\" rel=\"nofollow\"\u003Efriend-to-friend\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002F%D0%A1%D0%BA%D0%B2%D0%BE%D0%B7%D0%BD%D0%BE%D0%B5_%D1%88%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5\" rel=\"nofollow\"\u003Eend-to-end зашифрованный\u003C\u002Fa\u003E instant messenger с \u003Ca href=\"http:\u002F\u002Fwebee.technion.ac.il\u002F~hugo\u002Fsigma-pdf.pdf\" rel=\"nofollow\"\u003ESIGMA-I\u003C\u002Fa\u003E протоколом аутентификации и согласования ключей (на базе которого реализован \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002FIKE\" rel=\"nofollow\"\u003EIPsec IKE\u003C\u002Fa\u003E), используя исключительно ГОСТовые криптографические алгоритмы PyGOST библиотеки и ASN.1 кодирование сообщений библиотекой \u003Ca href=\"http:\u002F\u002Fwww.pyderasn.cypherpunks.ru\u002F\" rel=\"nofollow\"\u003EPyDERASN\u003C\u002Fa\u003E (про которую я уже \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F444272\u002F\"\u003Eписал раньше\u003C\u002Fa\u003E). Необходимое условие: он должен быть настолько прост, чтобы его можно было написать с нуля за один вечер (или рабочий день), иначе это уже не простая программа. В ней наверняка есть ошибки, излишние сложности, недочёты, плюс это моя первая программа с использованием asyncio библиотеки.\u003Cbr\u002F\u003E\r\n\u003Ca name=\"habracut\"\u003E\u003C\u002Fa\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EДизайн IM\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nДля начала, надо понять, как будет выглядеть наш IM. Для простоты, пускай это будет peer-to-peer сеть, без какого-либо обнаружения участников. Собственноручно будем указывать, к какому адресу: порту подключаться для общения с собеседником.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЯ понимаю, что на данный момент, предположение о доступности прямой связи между двумя произвольными компьютерами — существенное ограничение применимости IM на практике. Но чем больше разработчиков будут реализовывать всякие NAT-traversal костыли, тем дольше мы так и будем оставаться в IPv4 Интернете, с удручающей вероятностью связи между произвольными компьютерами. Ну сколько можно терпеть отсутствие IPv6 дома и на работе?\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nУ нас будет friend-to-friend сеть: все возможные собеседники заранее должны быть известны. Во-первых, это сильно всё упрощает: представились, нашли или не нашли имя\u002Fключ, отключились или продолжаем работу, зная собеседника. Во-вторых, в общем случае, это безопасно и исключает множество атак.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИнтерфейс IM-а будет близок к классическим решениям \u003Ca href=\"https:\u002F\u002Fsuckless.org\u002F\" rel=\"nofollow\"\u003Esuckless-проектов\u003C\u002Fa\u003E, которые мне очень нравятся своим минимализмом и Unix-way философией. IM программа для каждого собеседника создаёт директорию с тремя Unix domain sockets:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003Ein — в него записываются отправляемые собеседнику сообщения;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eout — из него читаются принимаемые от собеседника сообщения;\u003C\u002Fli\u003E\r\n\u003Cli\u003Estate — читая из него, мы узнаём, подключён ли сейчас собеседник, адрес\u002Fпорт подключения.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nКроме того, создаётся conn сокет, записав в который хост порт, мы инициируем подключение к удалённому собеседнику.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\n|-- alice\n|   |-- in\n|   |-- out\n|   `-- state\n|-- bob\n|   |-- in\n|   |-- out\n|   `-- state\n`- conn\n\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТакой подход позволяет делать независимые реализации IM транспорта и пользовательского интерфейса, ведь на вкус и цвет товарища нет, каждому не угодишь. Используя \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Ftmux\u002Ftmux\u002Fwiki\" rel=\"nofollow\"\u003Etmux\u003C\u002Fa\u003E и\u002Fили \u003Ca href=\"https:\u002F\u002Fwww.vanheusden.com\u002Fmultitail\u002F\" rel=\"nofollow\"\u003Emultitail\u003C\u002Fa\u003E, можно получить многооконный интерфейс с синтаксической подсветкой. А с помощью \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fhanslub42\u002Frlwrap\" rel=\"nofollow\"\u003Erlwrap\u003C\u002Fa\u003E можно получить GNU Readline-совместимую строку для ввода сообщений.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНа самом деле suckless проекты используют FIFO-файлы. Лично я не смог понять, как в asyncio работать с файлами конкурентно без собственноручной подложки из выделенных тредов (для таких вещей давно использую язык \u003Ca href=\"https:\u002F\u002Fgolang.org\u002F\" rel=\"nofollow\"\u003EGo\u003C\u002Fa\u003E). Поэтому решил обойтись Unix domain сокетами. К сожалению, это лишает возможности сделать echo 2001:470:dead::babe 6666 \u003E conn. Я решил эту проблему, используя \u003Ca href=\"http:\u002F\u002Fwww.dest-unreach.org\u002Fsocat\u002F\" rel=\"nofollow\"\u003Esocat\u003C\u002Fa\u003E: echo 2001:470:dead::babe 6666 | socat — UNIX-CONNECT:conn, socat READLINE UNIX-CONNECT:alice\u002Fin.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EПервоначальный небезопасный протокол\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nВ качестве транспорта используется TCP: он гарантирует доставку и её порядок. UDP не гарантирует ни того, ни другого (что было бы полезным, когда применится криптография), а поддержки \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002FSCTP\" rel=\"nofollow\"\u003ESCTP\u003C\u002Fa\u003E в Python из коробки нет.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nК сожалению, в TCP нет понятия сообщения, а только потока байт. Поэтому необходимо придумать формат для сообщений, чтобы их можно было разделять между собой в этом потоке. Можем условиться использовать символ перевода строки. Для начала подойдёт, однако, когда мы начнём шифровать наши сообщения, этот символ может появиться где угодно в шифротексте. В сетях поэтому популярны протоколы, отправляющие сначала длину сообщения в байтах. Например, в Python из коробки есть xdrlib, позволяющая работать с подобным форматом \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002FExternal_Data_Representation\" rel=\"nofollow\"\u003EXDR\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nМы не будем правильно и эффективно работать с TCP чтением — упростим код. Читаем в бесконечном цикле данные из сокета, пока не декодируем полное сообщение. В качестве формата для такого подхода можно использовать и JSON с XML. Но когда добавится криптография, то данные придётся подписывать и аутентифицировать — а это потребует байт-в-байт идентичного представления объектов, чего не обеспечивают JSON\u002FXML (dumps результат может отличаться).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nXDR подходит для такой задачи, однако я выбираю ASN.1 с DER-кодированием и \u003Ca href=\"http:\u002F\u002Fwww.pyderasn.cypherpunks.ru\u002F\" rel=\"nofollow\"\u003EPyDERASN\u003C\u002Fa\u003E библиотеку, так как на руках у нас будут высокоуровневые объекты, с которыми часто приятнее и удобнее работать. В отличии от schemaless \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002FBencode\" rel=\"nofollow\"\u003Ebencode\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FMessagePack\" rel=\"nofollow\"\u003EMessagePack\u003C\u002Fa\u003E или \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FCBOR\" rel=\"nofollow\"\u003ECBOR\u003C\u002Fa\u003E, ASN.1 автоматически проверит данные напротив жёстко заданной схемы.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003E# Msg ::= CHOICE {\n#       text      MsgText,\n#       handshake [0] EXPLICIT MsgHandshake }\nclass Msg(Choice):\n    schema = ((\n        (\"text\", MsgText()),\n        (\"handshake\", MsgHandshake(expl=tag_ctxc(0))),\n    ))\n\n# MsgText ::= SEQUENCE {\n#       text UTF8String (SIZE(1..MaxTextLen))}\nclass MsgText(Sequence):\n    schema = ((\n        (\"text\", UTF8String(bounds=(1, MaxTextLen))),\n    ))\n\n# MsgHandshake ::= SEQUENCE {\n#       peerName UTF8String (SIZE(1..256)) }\nclass MsgHandshake(Sequence):\n    schema = ((\n        (\"peerName\", UTF8String(bounds=(1, 256))),\n    ))\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПринимаемым сообщением будет Msg: либо текстовое MsgText (пока с одним текстовым полем), либо сообщение рукопожатия MsgHandshake (в котором передаётся имя собеседника). Сейчас выглядит переусложнённым, но это задел на будущее.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\n     ┌─────┐            ┌─────┐\n     │PeerA│            │PeerB│\n     └──┬──┘            └──┬──┘\n        │MsgHandshake(IdA) │\n        │─────────────────\u003E│\n        │                  │\n        │MsgHandshake(IdB) │\n        │&lt;─────────────────│\n        │                  │\n        │    MsgText()     │\n        │─────────────────\u003E│\n        │                  │\n        │    MsgText()     │\n        │&lt;─────────────────│\n        │                  │\n\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EIM без криптографии\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nКак я уже говорил, для всех операций с сокетами будет использоваться asyncio библиотека. Объявим, что мы ожидаем в момент запуска:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eparser = argparse.ArgumentParser(description=\"GOSTIM\")\nparser.add_argument(\n    \"--our-name\",\n    required=True,\n    help=\"Our peer name\",\n)\nparser.add_argument(\n    \"--their-names\",\n    required=True,\n    help=\"Their peer names, comma-separated\",\n)\nparser.add_argument(\n    \"--bind\",\n    default=\"::1\",\n    help=\"Address to listen on\",\n)\nparser.add_argument(\n    \"--port\",\n    type=int,\n    default=6666,\n    help=\"Port to listen on\",\n)\nargs = parser.parse_args()\nOUR_NAME = UTF8String(args.our_name)\nTHEIR_NAMES = set(args.their_names.split(\",\"))\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЗадаётся собственное имя (--our-name alice). Через запятую перечисляются все ожидаемые собеседники (--their-names bob,eve). Для каждого из собеседников создаётся директория с Unix сокетами, а также по корутине на каждый in, out, state:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Efor peer_name in THEIR_NAMES:\n    makedirs(peer_name, mode=0o700, exist_ok=True)\n    out_queue = asyncio.Queue()\n    OUT_QUEUES[peer_name] = out_queue\n    asyncio.ensure_future(asyncio.start_unix_server(\n        partial(unixsock_out_processor, out_queue=out_queue),\n        path.join(peer_name, \"out\"),\n    ))\n    in_queue = asyncio.Queue()\n    IN_QUEUES[peer_name] = in_queue\n    asyncio.ensure_future(asyncio.start_unix_server(\n        partial(unixsock_in_processor, in_queue=in_queue),\n        path.join(peer_name, \"in\"),\n    ))\n    asyncio.ensure_future(asyncio.start_unix_server(\n        partial(unixsock_state_processor, peer_name=peer_name),\n        path.join(peer_name, \"state\"),\n    ))\nasyncio.ensure_future(asyncio.start_unix_server(unixsock_conn_processor, \"conn\"))\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПриходящие от пользователя сообщения из in сокета отправляются в IN_QUEUES очереди:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Easync def unixsock_in_processor(reader, writer, in_queue: asyncio.Queue) -\u003E None:\n    while True:\n        text = await reader.read(MaxTextLen)\n        if text == b\"\":\n            break\n        await in_queue.put(text.decode(\"utf-8\"))\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПриходящие от собеседников сообщения отправляются в OUT_QUEUES очереди, из которых данные записываются в out сокет:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Easync def unixsock_out_processor(reader, writer, out_queue: asyncio.Queue) -\u003E None:\n    while True:\n        text = await out_queue.get()\n        writer.write((\"[%s] %s\" % (datetime.now(), text)).encode(\"utf-8\"))\n        await writer.drain()\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПри чтении из state сокета программа ищет в PEER_ALIVE словаре адрес собеседника. Если подключения к собеседнику ещё нет, то записывается пустая строка.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Easync def unixsock_state_processor(reader, writer, peer_name: str) -\u003E None:\n    peer_writer = PEER_ALIVES.get(peer_name)\n    writer.write(\n        b\"\" if peer_writer is None else (\" \".join([\n            str(i) for i in peer_writer.get_extra_info(\"peername\")[:2]\n        ]).encode(\"utf-8\") + b\"\\n\")\n    )\n    await writer.drain()\n    writer.close()\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПри записи адреса в conn сокет запускается функция «инициатора» соединения:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Easync def unixsock_conn_processor(reader, writer) -\u003E None:\n    data = await reader.read(256)\n    writer.close()\n    host, port = data.decode(\"utf-8\").split(\" \")\n    await initiator(host=host, port=int(port))\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nРассмотрим инициатора. Сначала он, очевидно, открывает соединение до указанного хоста\u002Fпорта и отправляет handshake сообщение со своим именем:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003E 130 async def initiator(host, port):\n 131     _id = repr((host, port))\n 132     logging.info(\"%s: dialing\", _id)\n 133     reader, writer = await asyncio.open_connection(host, port)\n 134     # Handshake message {{{\n 135     writer.write(Msg((\"handshake\", MsgHandshake((\n 136         (\"peerName\", OUR_NAME),\n 137     )))).encode())\n 138     # }}}\n 139     await writer.drain()\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЗатем ждёт ответа от удалённой стороны. Пытается декодировать пришедший ответ по Msg ASN.1 схеме. Предполагаем, что всё сообщение будет отправлено одним TCP-сегментом и мы атомарно его получим при вызове .read(). Проверяем, что мы получили именно handshake сообщение.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003E 141     # Wait for Handshake message {{{\n 142     data = await reader.read(256)\n 143     if data == b\"\":\n 144         logging.warning(\"%s: no answer, disconnecting\", _id)\n 145         writer.close()\n 146         return\n 147     try:\n 148         msg, _ = Msg().decode(data)\n 149     except ASN1Error:\n 150         logging.warning(\"%s: undecodable answer, disconnecting\", _id)\n 151         writer.close()\n 152         return\n 153     logging.info(\"%s: got %s message\", _id, msg.choice)\n 154     if msg.choice != \"handshake\":\n 155         logging.warning(\"%s: unexpected message, disconnecting\", _id)\n 156         writer.close()\n 157         return\n 158     # }}}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПроверяем, что пришедшее имя собеседника нам известно. Если нет, то рвём соединение. Проверяем, не было ли у нас уже установлено с ним соединение (собеседник вновь дал команду на подключение к нам) и закрываем его. В IN_QUEUES очередь помещаются Python-строки с текстом сообщения, но имеется особое значение None, сигнализирующее msg_sender корутину прекратить работу, чтобы она забыла о своём writer, связанным с устаревшим TCP-соединением.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003E 159     msg_handshake = msg.value\n 160     peer_name = str(msg_handshake[\"peerName\"])\n 161     if peer_name not in THEIR_NAMES:\n 162         logging.warning(\"unknown peer name: %s\", peer_name)\n 163         writer.close()\n 164         return\n 165     logging.info(\"%s: session established: %s\", _id, peer_name)\n 166     # Run text message sender, initialize transport decoder {{{\n 167     peer_alive = PEER_ALIVES.pop(peer_name, None)\n 168     if peer_alive is not None:\n 169         peer_alive.close()\n 170         await IN_QUEUES[peer_name].put(None)\n 171     PEER_ALIVES[peer_name] = writer\n 172     asyncio.ensure_future(msg_sender(peer_name, writer))\n 173     # }}}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nmsg_sender принимает исходящие сообщения (подкладываемые в очередь из in сокета), сериализует их в MsgText сообщение и отправляет по TCP-соединению. Оно может оборваться в любой момент — это мы явно перехватываем.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Easync def msg_sender(peer_name: str, writer) -\u003E None:\n    in_queue = IN_QUEUES[peer_name]\n    while True:\n        text = await in_queue.get()\n        if text is None:\n            break\n        writer.write(Msg((\"text\", MsgText((\n            (\"text\", UTF8String(text)),\n        )))).encode())\n        try:\n            await writer.drain()\n        except ConnectionResetError:\n            del PEER_ALIVES[peer_name]\n            return\n        logging.info(\"%s: sent %d characters message\", peer_name, len(text))\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nВ конце инициатор входит в бесконечный цикл чтения сообщений из сокета. Проверяет, текстовые ли это сообщения, и помещает в OUT_QUEUES очередь, из которой они будут отправлены в out сокет соответствующего собеседника. Почему нельзя просто делать .read() и декодировать сообщение? Потому что не исключена ситуация, когда несколько сообщений от пользователя будут агрегированы в буфере операционной системы и отправлены одним TCP-сегментом. Декодировать-то мы сможем первое, а дальше в буфере может остаться часть от последующего. При любой нештатной ситуации мы закрываем TCP-соединение и останавливаем msg_sender корутину (посылкой None в OUT_QUEUES очередь).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003E 174     buf = b\"\"\n 175     # Wait for test messages {{{\n 176     while True:\n 177         data = await reader.read(MaxMsgLen)\n 178         if data == b\"\":\n 179             break\n 180         buf += data\n 181         if len(buf) \u003E MaxMsgLen:\n 182             logging.warning(\"%s: max buffer size exceeded\", _id)\n 183             break\n 184         try:\n 185             msg, tail = Msg().decode(buf)\n 186         except ASN1Error:\n 187             continue\n 188         buf = tail\n 189         if msg.choice != \"text\":\n 190             logging.warning(\"%s: unexpected %s message\", _id, msg.choice)\n 191             break\n 192         try:\n 193             await msg_receiver(msg.value, peer_name)\n 194         except ValueError as err:\n 195             logging.warning(\"%s: %s\", err)\n 196             break\n 197     # }}}\n 198     logging.info(\"%s: disconnecting: %s\", _id, peer_name)\n 199     IN_QUEUES[peer_name].put(None)\n 200     writer.close()\n\n  66 async def msg_receiver(msg_text: MsgText, peer_name: str) -\u003E None:\n  67     text = str(msg_text[\"text\"])\n  68     logging.info(\"%s: received %d characters message\", peer_name, len(text))\n  69     await OUT_QUEUES[peer_name].put(text)\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nВернёмся к основному коду. После создания всех корутин в момент запуска программы мы стартуем TCP-сервер. На каждое установленное соединение он создаёт responder (ответчик) корутину.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Elogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(levelname)s %(asctime)s: %(funcName)s: %(message)s\",\n)\nloop = asyncio.get_event_loop()\nserver = loop.run_until_complete(asyncio.start_server(responder, args.bind, args.port))\nlogging.info(\"Listening on: %s\", server.sockets[0].getsockname())\nloop.run_forever()\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nresponder схож с initiator и зеркально выполняет все те же самые действия, но бесконечный цикл чтения сообщений запускается сразу же, для простоты. Сейчас протокол рукопожатия отсылает по одному сообщению с каждой стороны, но в дальнейшем, будет по два от инициатора соединения, после которых сразу же возможна отправка текстовых.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003E  72 async def responder(reader, writer):\n  73     _id = writer.get_extra_info(\"peername\")\n  74     logging.info(\"%s: connected\", _id)\n  75     buf = b\"\"\n  76     msg_expected = \"handshake\"\n  77     peer_name = None\n  78     while True:\n  79         # Read until we get Msg message {{{\n  80         data = await reader.read(MaxMsgLen)\n  81         if data == b\"\":\n  82             logging.info(\"%s: closed connection\", _id)\n  83             break\n  84         buf += data\n  85         if len(buf) \u003E MaxMsgLen:\n  86             logging.warning(\"%s: max buffer size exceeded\", _id)\n  87             break\n  88         try:\n  89             msg, tail = Msg().decode(buf)\n  90         except ASN1Error:\n  91             continue\n  92         buf = tail\n  93         # }}}\n  94         if msg.choice != msg_expected:\n  95             logging.warning(\"%s: unexpected %s message\", _id, msg.choice)\n  96             break\n  97         if msg_expected == \"text\":\n  98             try:\n  99                 await msg_receiver(msg.value, peer_name)\n 100             except ValueError as err:\n 101                 logging.warning(\"%s: %s\", err)\n 102                 break\n 103         # Process Handshake message {{{\n 104         elif msg_expected == \"handshake\":\n 105             logging.info(\"%s: got %s message\", _id, msg_expected)\n 106             msg_handshake = msg.value\n 107             peer_name = str(msg_handshake[\"peerName\"])\n 108             if peer_name not in THEIR_NAMES:\n 109                 logging.warning(\"unknown peer name: %s\", peer_name)\n 110                 break\n 111             writer.write(Msg((\"handshake\", MsgHandshake((\n 112                 (\"peerName\", OUR_NAME),\n 113             )))).encode())\n 114             await writer.drain()\n 115             logging.info(\"%s: session established: %s\", _id, peer_name)\n 116             peer_alive = PEER_ALIVES.pop(peer_name, None)\n 117             if peer_alive is not None:\n 118                 peer_alive.close()\n 119                 await IN_QUEUES[peer_name].put(None)\n 120             PEER_ALIVES[peer_name] = writer\n 121             asyncio.ensure_future(msg_sender(peer_name, writer))\n 122             msg_expected = \"text\"\n 123         # }}}\n 124     logging.info(\"%s: disconnecting\", _id)\n 125     if msg_expected == \"text\":\n 126         IN_QUEUES[peer_name].put(None)\n 127     writer.close()\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EБезопасный протокол\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nПришло время обезопасить наше общение. Что же мы подразумеваем под безопасностью и что хотим:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003Eконфиденциальность передаваемых сообщений;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eаутентичность и целостность передаваемых сообщений — их изменение должно быть обнаружено;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eзащита от атак перепроигрывания (replay attack) — факт пропажи или повтора сообщений должен быть обнаружен (и мы решаем обрывать соединение);\u003C\u002Fli\u003E\r\n\u003Cli\u003Eидентификация и аутентификация собеседников по заранее вбитым публичным ключам — мы уже решили ранее, что делаем friend-to-friend сеть. Только после аутентификации мы поймём, с кем общаемся;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eналичие \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002FPerfect_forward_secrecy\" rel=\"nofollow\"\u003Eperfect forward secrecy\u003C\u002Fa\u003E свойства (PFS) — компрометация нашего долгоживущего ключа подписи не должна приводить к возможности чтения всей предыдущей переписки. Запись перехваченного трафика становится бесполезной;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eдействительность\u002Fвалидность сообщений (транспортных и рукопожатия) только в пределах одной TCP-сессии. Вставка корректно подписанных\u002Fаутентифицированных сообщений из другой сессии (даже с этим же собеседником) не должна быть возможной;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eпассивный наблюдатель не должен видеть ни идентификаторов пользователей, ни передаваемых долгоживущих публичных ключей, ни хэшей от них. Некая анонимность от пассивного наблюдателя.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nУдивительно, но этот минимум практически все хотят иметь в любом протоколе рукопожатия, и крайне мало из перечисленного в итоге выполняется для «доморощенных» протоколов. Вот и сейчас не будем изобретать нового. Я бы однозначно рекомендовал использовать \u003Ca href=\"http:\u002F\u002Fnoiseprotocol.org\u002F\" rel=\"nofollow\"\u003ENoise framework\u003C\u002Fa\u003E для построения протоколов, но выберем что-то попроще.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНаиболее популярны два протокола:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002FTLS\" rel=\"nofollow\"\u003ETLS\u003C\u002Fa\u003E — сложнейший протокол с длинной историей багов, косяков, уязвимостей, плохой продуманности, сложности и недочётов (впрочем, к TLS 1.3 это мало относится). Но не рассматриваем его из-за переусложнённости.\u003C\u002Fli\u003E\r\n\u003Cli\u003E \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002FIPsec\" rel=\"nofollow\"\u003EIPsec\u003C\u002Fa\u003E с \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002FIKE\" rel=\"nofollow\"\u003EIKE\u003C\u002Fa\u003E — не имеют серьёзных криптографических проблем, хотя тоже не просты. Если почитать про IKEv1 и IKEv2, то их истоком являются \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002FSTS_(%D0%BF%D1%80%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BB)\" rel=\"nofollow\"\u003ESTS\u003C\u002Fa\u003E, ISO\u002FIEC IS 9798-3 и SIGMA (SIGn-and-MAc) протоколы — достаточно простые для реализации за один вечер.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nЧем SIGMA, как последнее звено развития STS\u002FISO протоколов, хорош? Он удовлетворяет всем нашим требованиям (в том числе «скрытия» идентификаторов собеседников), не имеет известных криптографических проблем. Он минималистичен — удаление хотя бы одного элемента из сообщения протокола приведёт к его небезопасности.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДавайте пройдёмся от простейшего доморощенного протокола до SIGMA. Самая базовая интересующая нас операция это \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002F%D0%94%D0%B8%D1%84%D1%84%D0%B8-%D0%A5%D0%B5%D0%BB%D0%BB%D0%BC%D0%B0%D0%BD\" rel=\"nofollow\"\u003Eсогласование ключей\u003C\u002Fa\u003E: функция, на выходе которой оба участника получат одно и то же значение, которое можно будет использовать в качестве симметричного ключа. Не вдаваясь в подробности: каждая из сторон генерирует эфемерную (использующуюся только в пределах одной сессии) ключевую пару (публичный и приватный ключи), обмениваются публичными ключами, вызывают функцию согласования, на вход которой передают свой приватный ключ и публичный ключ собеседника.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\n┌─────┐          ┌─────┐\n│PeerA│          │PeerB│\n└──┬──┘          └──┬──┘\n   │   IdA, PubA    │ ╔════════════════════╗\n   │───────────────\u003E│ ║PrvA, PubA = DHgen()║\n   │                │ ╚════════════════════╝\n   │   IdB, PubB    │ ╔════════════════════╗\n   │&lt;───────────────│ ║PrvB, PubB = DHgen()║\n   │                │ ╚════════════════════╝\n   ────┐    ╔═══════╧════════════╗\n       │    ║Key = DH(PrvA, PubB)║\n   &lt;───┘    ╚═══════╤════════════╝\n   │                │\n   │                │\n\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЛюбой может встрять-посередине и заменить публичные ключи своими собственными — в данном протоколе нет аутентификации собеседников. Добавим подпись долгоживущими ключами.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\n┌─────┐                            ┌─────┐\n│PeerA│                            │PeerB│\n└──┬──┘                            └──┬──┘\n   │IdA, PubA, sign(SignPrvA, (PubA)) │ ╔═══════════════════════════╗\n   │─────────────────────────────────\u003E│ ║SignPrvA, SignPubA = load()║\n   │                                  │ ║PrvA, PubA = DHgen()       ║\n   │                                  │ ╚═══════════════════════════╝\n   │IdB, PubB, sign(SignPrvB, (PubB)) │ ╔═══════════════════════════╗\n   │&lt;─────────────────────────────────│ ║SignPrvB, SignPubB = load()║\n   │                                  │ ║PrvB, PubB = DHgen()       ║\n   │                                  │ ╚═══════════════════════════╝\n   ────┐    ╔═════════════════════╗   │\n       │    ║verify(SignPubB, ...)║   │\n   &lt;───┘    ║Key = DH(PrvA, PubB) ║   │\n   │        ╚═════════════════════╝   │\n   │                                  │\n\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТакая подпись не подойдёт, так как она не привязана к конкретной сессии. Такие сообщения «подойдут» и для сессий с другими участниками. Подписываться должен весь контекст. Это вынуждает также добавить посылку ещё одного сообщения от A.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКроме того, критично добавить под подпись и собственный идентификатор, так как, в противном случае мы можем подменить IdXXX и переподписать сообщение ключом другого известного собеседника. Для предотвращения \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FReflection_attack\" rel=\"nofollow\"\u003Ereflection атак\u003C\u002Fa\u003E, необходимо, чтобы элементы под подписью находились в чётко заданных местах по своему смыслу: если A подписывает (PubA, PubB), то B должен подписывать (PubB, PubA). Это ещё и говорит о важности выбора структуры и формата сериализованных данных. Например, множества в ASN.1 DER кодировании сортируются: SET OF(PubA, PubB) будет идентичен SET OF(PubB, PubA).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\n┌─────┐                                       ┌─────┐\n│PeerA│                                       │PeerB│\n└──┬──┘                                       └──┬──┘\n   │                 IdA, PubA                   │ ╔═══════════════════════════╗\n   │────────────────────────────────────────────\u003E│ ║SignPrvA, SignPubA = load()║\n   │                                             │ ║PrvA, PubA = DHgen()       ║\n   │                                             │ ╚═══════════════════════════╝\n   │IdB, PubB, sign(SignPrvB, (IdB, PubA, PubB)) │ ╔═══════════════════════════╗\n   │&lt;────────────────────────────────────────────│ ║SignPrvB, SignPubB = load()║\n   │                                             │ ║PrvB, PubB = DHgen()       ║\n   │                                             │ ╚═══════════════════════════╝\n   │     sign(SignPrvA, (IdA, PubB, PubA))       │ ╔═════════════════════╗\n   │────────────────────────────────────────────\u003E│ ║verify(SignPubB, ...)║\n   │                                             │ ║Key = DH(PrvA, PubB) ║\n   │                                             │ ╚═════════════════════╝\n   │                                             │\n\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nОднако мы всё ещё не «доказали» что выработали одинаковый общий ключ для этой сессии. В принципе, можно обойтись и без этого шага — первое же транспортное сообщение будет невалидным, но мы хотим чтобы, когда рукопожатие завершилось, то были бы уверены, что всё действительно согласовано. На данный момент у нас на руках ISO\u002FIEC IS 9798-3 протокол.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nМы могли бы подписывать и сам выработанный ключ. Это опасно, так как не исключено, что в используемом алгоритме подписи могут быть утечки (пускай биты-на-подпись, но всё же утечки). Можно подписывать хэш от выработанного ключа, но утечка даже хэша от выработанного ключа может иметь ценность при brute-force атаке на функцию выработки. SIGMA использует MAC функцию, аутентифицирующую идентификатор отправителя.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\n┌─────┐                                            ┌─────┐\n│PeerA│                                            │PeerB│\n└──┬──┘                                            └──┬──┘\n   │                    IdA, PubA                     │ ╔═══════════════════════════╗\n   │─────────────────────────────────────────────────\u003E│ ║SignPrvA, SignPubA = load()║\n   │                                                  │ ║PrvA, PubA = DHgen()       ║\n   │                                                  │ ╚═══════════════════════════╝\n   │IdB, PubB, sign(SignPrvB, (PubA, PubB)), MAC(IdB) │ ╔═══════════════════════════╗\n   │&lt;─────────────────────────────────────────────────│ ║SignPrvB, SignPubB = load()║\n   │                                                  │ ║PrvB, PubB = DHgen()       ║\n   │                                                  │ ╚═══════════════════════════╝\n   │                                                  │ ╔═════════════════════╗\n   │     sign(SignPrvA, (PubB, PubA)), MAC(IdA)       │ ║Key = DH(PrvA, PubB) ║\n   │─────────────────────────────────────────────────\u003E│ ║verify(Key, IdB)     ║\n   │                                                  │ ║verify(SignPubB, ...)║\n   │                                                  │ ╚═════════════════════╝\n   │                                                  │\n\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ качестве оптимизации некоторые могут захотеть переиспользовать свои эфемерные ключи (что, конечно, плачевно для PFS). Например, мы сгенерировали ключевую пару, попытались подключиться, но TCP не был доступен или оборвался где-то на середине протокола. Жалко тратить потраченную энтропию и ресурсы процессора на новую пару. Поэтому введём так называемый cookie — псевдослучайное значение, которое защитит от возможных случайных replay атак при повторном использовании эфемерных публичных ключей. Из-за binding-а между cookie и эфемерным публичным ключом, публичный ключ противоположного участника можно убрать из подписи за ненадобностью.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\n┌─────┐                                                                 ┌─────┐\n│PeerA│                                                                 │PeerB│\n└──┬──┘                                                                 └──┬──┘\n   │                          IdA, PubA, CookieA                           │ ╔═══════════════════════════╗\n   │──────────────────────────────────────────────────────────────────────\u003E│ ║SignPrvA, SignPubA = load()║\n   │                                                                       │ ║PrvA, PubA = DHgen()       ║\n   │                                                                       │ ╚═══════════════════════════╝\n   │IdB, PubB, CookieB, sign(SignPrvB, (CookieA, CookieB, PubB)), MAC(IdB) │ ╔═══════════════════════════╗\n   │&lt;──────────────────────────────────────────────────────────────────────│ ║SignPrvB, SignPubB = load()║\n   │                                                                       │ ║PrvB, PubB = DHgen()       ║\n   │                                                                       │ ╚═══════════════════════════╝\n   │                                                                       │ ╔═════════════════════╗\n   │          sign(SignPrvA, (CookieB, CookieA, PubA)), MAC(IdA)           │ ║Key = DH(PrvA, PubB) ║\n   │──────────────────────────────────────────────────────────────────────\u003E│ ║verify(Key, IdB)     ║\n   │                                                                       │ ║verify(SignPubB, ...)║\n   │                                                                       │ ╚═════════════════════╝\n   │                                                                       │\n\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНаконец, мы хотим получить приватность наших идентификаторов собеседников от пассивного наблюдателя. Для этого SIGMA предлагает сначала обменяться эфемерными ключами, выработать общий ключ, на котором зашифровать аутентифицирующие и идентифицирующие сообщения. SIGMA описывает два варианта:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003ESIGMA-I — защищает инициатора от активных атак, ответчика от пассивных: инициатор аутентифицирует ответчика и если что-то не сошлось, то свою идентификацию он не выдаёт. Ответчик же выдаёт свою идентификацию если с ним начать активный протокол. Пассивный наблюдатель ничего не узнает;\u003Cbr\u002F\u003E\r\nSIGMA-R — защищает ответчика от активных атак, инициатора от пассивных. Всё с точностью до наоборот, но в этом протоколе уже четыре сообщения рукопожатия передаётся.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВыбираем SIGMA-I как более похожий на то, что мы ожидаем от клиент-серверных привычных вещей: клиента узнает только аутентифицированный сервер, а сервер и так знают все. Плюс он проще в реализации из-за меньшего количества сообщений рукопожатия. Всё что мы вносим в протокол, так это шифрование части сообщения и перенос идентификатора A в шифрованную часть последнего сообщения:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\n┌─────┐                                                                        ┌─────┐\n│PeerA│                                                                        │PeerB│\n└──┬──┘                                                                        └──┬──┘\n   │                                PubA, CookieA                                 │ ╔═══════════════════════════╗\n   │─────────────────────────────────────────────────────────────────────────────\u003E│ ║SignPrvA, SignPubA = load()║\n   │                                                                              │ ║PrvA, PubA = DHgen()       ║\n   │                                                                              │ ╚═══════════════════════════╝\n   │PubB, CookieB, Enc((IdB, sign(SignPrvB, (CookieA, CookieB, PubB)), MAC(IdB))) │ ╔═══════════════════════════╗\n   │&lt;─────────────────────────────────────────────────────────────────────────────│ ║SignPrvB, SignPubB = load()║\n   │                                                                              │ ║PrvB, PubB = DHgen()       ║\n   │                                                                              │ ╚═══════════════════════════╝\n   │                                                                              │ ╔═════════════════════╗\n   │       Enc((IdA, sign(SignPrvA, (CookieB, CookieA, PubA)), MAC(IdA)))         │ ║Key = DH(PrvA, PubB) ║\n   │─────────────────────────────────────────────────────────────────────────────\u003E│ ║verify(Key, IdB)     ║\n   │                                                                              │ ║verify(SignPubB, ...)║\n   │                                                                              │ ╚═════════════════════╝\n   │                                                                              │\n\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EДля подписи используется ГОСТ Р \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002F%D0%93%D0%9E%D0%A1%D0%A2_%D0%A0_34.10-2012\" rel=\"nofollow\"\u003E34.10-2012\u003C\u002Fa\u003E алгоритм с 256-бит ключами.\u003C\u002Fli\u003E\r\n\u003Cli\u003EДля выработки общего ключа используется 34.10-2012 VKO.\u003C\u002Fli\u003E\r\n\u003Cli\u003EВ качестве MAC используется CMAC. Технически это особый режим работы блочного шифра, описанный в ГОСТ Р 34.13-2015. В качестве функции шифрования для этого режима — \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002FKuznechik\" rel=\"nofollow\"\u003EКузнечик\u003C\u002Fa\u003E (34.12-2015).\u003C\u002Fli\u003E\r\n\u003Cli\u003EВ качестве идентификатора собеседника используется хэш от его публичного ключа. В качестве хэша применяется \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002F%D0%93%D0%9E%D0%A1%D0%A2_%D0%A0_34.11-2012\" rel=\"nofollow\"\u003EСтрибог-256\u003C\u002Fa\u003E (34.11-2012 256 бит).\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПосле рукопожатия у нас будет согласован общий ключ. Его мы можем использовать для аутентифицированного шифрования транспортных сообщений. Эта часть совсем простая и в ней сложно ошибиться: инкрементируем счётчик сообщений, шифруем сообщение, аутентифицируем (MAC) счётчик и шифротекст, отправляем. При приёме сообщения проверяем что счётчик имеет ожидаемое значение, аутентифицируем шифротекст с счётчиком, дешифруем. Каким ключом шифровать сообщения рукопожатия, транспортные, каким аутентифицировать? Использовать один ключ для всех этих задач опасно и неразумно. Необходимо вырабатывать ключи, используя специализированные функции \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002F%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F_%D1%84%D0%BE%D1%80%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F_%D0%BA%D0%BB%D1%8E%D1%87%D0%B0\" rel=\"nofollow\"\u003EKDF\u003C\u002Fa\u003E (key derivation function). Опять же, не будем мудрить и что-то изобретать: \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FHKDF\" rel=\"nofollow\"\u003EHKDF\u003C\u002Fa\u003E давно известна, хорошо исследована и не имеет известных проблем. К сожалению, в родной библиотеке Python нет этой функции, поэтому используем \u003Ca href=\"https:\u002F\u002Fpypi.org\u002Fproject\u002Fhkdf\u002F\" rel=\"nofollow\"\u003Ehkdf\u003C\u002Fa\u003E пакет. HKDF внутри использует \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002FHMAC\" rel=\"nofollow\"\u003EHMAC\u003C\u002Fa\u003E, который, в свою очередь, использует хэш-функцию. Пример реализации на Python на странице Wikipedia занимает считанные строки кода. Как и в случае с 34.10-2012, в качестве хэш-функции будем использовать Стрибог-256. Выход нашей функции согласования ключей будет называться сессионным ключом, из которого будут вырабатываться недостающие симметричные:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Ekdf = Hkdf(None, key_session, hash=GOST34112012256)\nkdf.expand(b\"handshake1-mac-identity\")\nkdf.expand(b\"handshake1-enc\")\nkdf.expand(b\"handshake1-mac\")\nkdf.expand(b\"handshake2-mac-identity\")\nkdf.expand(b\"handshake2-enc\")\nkdf.expand(b\"handshake2-mac\")\nkdf.expand(b\"transport-initiator-enc\")\nkdf.expand(b\"transport-initiator-mac\")\nkdf.expand(b\"transport-responder-enc\")\nkdf.expand(b\"transport-responder-mac\")\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EСтруктуры\u002Fсхемы\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nРассмотрим какие же теперь ASN.1 структуры у нас получились для передачи всех этих данных:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eclass Msg(Choice):\n    schema = ((\n        (\"text\", MsgText()),\n        (\"handshake0\", MsgHandshake0(expl=tag_ctxc(0))),\n        (\"handshake1\", MsgHandshake1(expl=tag_ctxc(1))),\n        (\"handshake2\", MsgHandshake2(expl=tag_ctxc(2))),\n    ))\n\nclass MsgText(Sequence):\n    schema = ((\n        (\"payload\", MsgTextPayload()),\n        (\"payloadMac\", MAC()),\n    ))\n\nclass MsgTextPayload(Sequence):\n    schema = ((\n        (\"nonce\", Integer(bounds=(0, float(\"+inf\")))),\n        (\"ciphertext\", OctetString(bounds=(1, MaxTextLen))),\n    ))\n\nclass MsgHandshake0(Sequence):\n    schema = ((\n        (\"cookieInitiator\", Cookie()),\n        (\"pubKeyInitiator\", PubKey()),\n    ))\n\nclass MsgHandshake1(Sequence):\n    schema = ((\n        (\"cookieResponder\", Cookie()),\n        (\"pubKeyResponder\", PubKey()),\n        (\"ukm\", OctetString(bounds=(8, 8))),\n        (\"ciphertext\", OctetString()),\n        (\"ciphertextMac\", MAC()),\n    ))\n\nclass MsgHandshake2(Sequence):\n    schema = ((\n        (\"ciphertext\", OctetString()),\n        (\"ciphertextMac\", MAC()),\n    ))\n\nclass HandshakeTBE(Sequence):\n    schema = ((\n        (\"identity\", OctetString(bounds=(32, 32))),\n        (\"signature\", OctetString(bounds=(64, 64))),\n        (\"identityMac\", MAC()),\n    ))\n\nclass HandshakeTBS(Sequence):\n    schema = ((\n        (\"cookieTheir\", Cookie()),\n        (\"cookieOur\", Cookie()),\n        (\"pubKeyOur\", PubKey()),\n    ))\n\nclass Cookie(OctetString): bounds = (16, 16)\nclass PubKey(OctetString): bounds = (64, 64)\nclass MAC(OctetString): bounds = (16, 16)\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nHandshakeTBS — то, что будет подписываться (to be signed). HandshakeTBE — то, что будет зашифровано (to be encrypted). Обращаю внимание на поле ukm в MsgHandshake1. 34.10 VKO, для ещё большей рандомизации вырабатываемых ключей, включает параметр UKM (user keying material) — просто дополнительная энтропия.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EДобавление криптографии в код\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nРассмотрим лишь только внесённые к оригинальному коду изменения, так как каркас остался прежним (на самом деле, сначала была написана окончательная реализация, а потом из неё выпиливалась вся криптография).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТак как аутентификация и идентификация собеседников будет проводится по публичным ключам, то теперь их надо где-то долговременно хранить. Для простоты используем JSON такого вида:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003E{\n    \"our\": {\n        \"prv\": \"21254cf66c15e0226ef2669ceee46c87b575f37f9000272f408d0c9283355f98\",\n        \"pub\": \"938c87da5c55b27b7f332d91b202dbef2540979d6ceaa4c35f1b5bfca6df47df0bdae0d3d82beac83cec3e353939489d9981b7eb7a3c58b71df2212d556312a1\"\n    },\n    \"their\": {\n        \"alice\": \"d361a59c25d2ca5a05d21f31168609deeec100570ac98f540416778c93b2c7402fd92640731a707ec67b5410a0feae5b78aeec93c4a455a17570a84f2bc21fce\",\n        \"bob\": \"aade1207dd85ecd283272e7b69c078d5fae75b6e141f7649ad21962042d643512c28a2dbdc12c7ba40eb704af920919511180c18f4d17e07d7f5acd49787224a\"\n    }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nour — наша ключевая пара, шестнадцатеричные приватный и публичные ключи. their — имена собеседников и их публичные ключи. Изменим аргументы командной строки и добавим постобработку JSON данных:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Efrom pygost import gost3410\nfrom pygost.gost34112012256 import GOST34112012256\n\nCURVE = gost3410.GOST3410Curve(\n    *gost3410.CURVE_PARAMS[\"GostR3410_2001_CryptoPro_A_ParamSet\"]\n)\n\nparser = argparse.ArgumentParser(description=\"GOSTIM\")\nparser.add_argument(\n    \"--keys-gen\",\n    action=\"store_true\",\n    help=\"Generate JSON with our new keypair\",\n)\nparser.add_argument(\n    \"--keys\",\n    default=\"keys.json\",\n    required=False,\n    help=\"JSON with our and their keys\",\n)\nparser.add_argument(\n    \"--bind\",\n    default=\"::1\",\n    help=\"Address to listen on\",\n)\nparser.add_argument(\n    \"--port\",\n    type=int,\n    default=6666,\n    help=\"Port to listen on\",\n)\nargs = parser.parse_args()\n\nif args.keys_gen:\n    prv_raw = urandom(32)\n    pub = gost3410.public_key(CURVE, gost3410.prv_unmarshal(prv_raw))\n    pub_raw = gost3410.pub_marshal(pub)\n    print(json.dumps({\n        \"our\": {\"prv\": hexenc(prv_raw), \"pub\": hexenc(pub_raw)},\n        \"their\": {},\n    }))\n    exit(0)\n\n# Parse and unmarshal our and their keys {{{\nwith open(args.keys, \"rb\") as fd:\n    _keys = json.loads(fd.read().decode(\"utf-8\"))\nKEY_OUR_SIGN_PRV = gost3410.prv_unmarshal(hexdec(_keys[\"our\"][\"prv\"]))\n_pub = hexdec(_keys[\"our\"][\"pub\"])\nKEY_OUR_SIGN_PUB = gost3410.pub_unmarshal(_pub)\nKEY_OUR_SIGN_PUB_HASH = OctetString(GOST34112012256(_pub).digest())\nfor peer_name, pub_raw in _keys[\"their\"].items():\n    _pub = hexdec(pub_raw)\n    KEYS[GOST34112012256(_pub).digest()] = {\n        \"name\": peer_name,\n        \"pub\": gost3410.pub_unmarshal(_pub),\n    }\n# }}}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПриватный ключ 34.10 алгоритма — случайное число. Размером 256-бит для 256-бит эллиптических кривых. PyGOST работает не с набором байт, а с \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002F%D0%94%D0%BB%D0%B8%D0%BD%D0%BD%D0%B0%D1%8F_%D0%B0%D1%80%D0%B8%D1%84%D0%BC%D0%B5%D1%82%D0%B8%D0%BA%D0%B0\" rel=\"nofollow\"\u003Eбольшими числами\u003C\u002Fa\u003E, поэтому наш приватный ключ (urandom(32)) необходимо преобразовать в число, используя gost3410.prv_unmarshal(). Публичный ключ детерминировано вычисляется из приватного, используя gost3410.public_key(). Публичный ключ 34.10 — два больших числа, которые тоже нужно преобразовать в байтовую последовательность для удобства хранения и передачи, используя gost3410.pub_marshal().\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПосле чтения JSON файла, публичные ключи, соответственно, нужно преобразовать назад, используя gost3410.pub_unmarshal(). Так как нам будут приходить идентификаторы собеседников в виде хэша от публичного ключа, то их можно сразу же заранее вычислить и поместить в словарь для быстрого поиска. Стрибог-256 хэш это gost34112012256.GOST34112012256(), полностью удовлетворяющий hashlib интерфейсу хэш-функций.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКак изменилась корутина инициатора? Всё, как по схеме рукопожатия: генерируем cookie (128-бит вполне предостаточно), эфемерную ключевую пару 34.10, которая будет использоваться для VKO функции согласования ключей.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003E 395 async def initiator(host, port):\n 396     _id = repr((host, port))\n 397     logging.info(\"%s: dialing\", _id)\n 398     reader, writer = await asyncio.open_connection(host, port)\n 399     # Generate our ephemeral public key and cookie, send Handshake 0 message {{{\n 400     cookie_our = Cookie(urandom(16))\n 401     prv = gost3410.prv_unmarshal(urandom(32))\n 402     pub_our = gost3410.public_key(CURVE, prv)\n 403     pub_our_raw = PubKey(gost3410.pub_marshal(pub_our))\n 404     writer.write(Msg((\"handshake0\", MsgHandshake0((\n 405         (\"cookieInitiator\", cookie_our),\n 406         (\"pubKeyInitiator\", pub_our_raw),\n 407     )))).encode())\n 408     # }}}\n 409     await writer.drain()\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003Eждём ответа и декодируем пришедшее Msg сообщение;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eубеждаемся что получили handshake1;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eдекодируем эфемерный публичный ключ противоположной стороны и вычисляем сессионный ключ;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eвырабатываем симметричные ключи необходимые для обработки TBE части сообщения.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003E 423     logging.info(\"%s: got %s message\", _id, msg.choice)\n 424     if msg.choice != \"handshake1\":\n 425         logging.warning(\"%s: unexpected message, disconnecting\", _id)\n 426         writer.close()\n 427         return\n 428     # }}}\n 429     msg_handshake1 = msg.value\n 430     # Validate Handshake message {{{\n 431     cookie_their = msg_handshake1[\"cookieResponder\"]\n 432     pub_their_raw = msg_handshake1[\"pubKeyResponder\"]\n 433     pub_their = gost3410.pub_unmarshal(bytes(pub_their_raw))\n 434     ukm_raw = bytes(msg_handshake1[\"ukm\"])\n 435     ukm = ukm_unmarshal(ukm_raw)\n 436     key_session = kek_34102012256(CURVE, prv, pub_their, ukm, mode=2001)\n 437     kdf = Hkdf(None, key_session, hash=GOST34112012256)\n 438     key_handshake1_mac_identity = kdf.expand(b\"handshake1-mac-identity\")\n 439     key_handshake1_enc = kdf.expand(b\"handshake1-enc\")\n 440     key_handshake1_mac = kdf.expand(b\"handshake1-mac\")\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nUKM это 64-бит число (urandom(8)), которое тоже требует десериализации из байтового представления, используя gost3410_vko.ukm_unmarshal(). VKO функция для 34.10-2012 256-бит это gost3410_vko.kek_34102012256() (KEK — key encryption key).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВыработанный сессионный ключ уже является 256-бит байтовой псевдослучайной последовательностью. Поэтому его сразу же можно использовать в HKDF функции. Так как GOST34112012256 удовлетворяет hashlib интерфейсу, то его можно сразу же использовать в Hkdf классе. Соль (первый аргумент Hkdf) мы не указываем, так как выработанный ключ из-за эфемерности участвующих ключевых пар будет разным для каждой сессии и в нём уже достаточно энтропии. kdf.expand() по умолчанию уже выдаёт ключи длиной 256-бит, требуемые для Кузнечика в дальнейшем.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДалее проверяются TBE и TBS части пришедшего сообщения:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003Eвычисляется и проверяется MAC над пришедшим шифротекстом;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eдешифруется шифротекст;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eдекодируется TBE структура;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eиз неё берётся идентификатор собеседника и проверяется известен ли он нам вообще;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eвычисляется и проверятся MAC над этим идентификатором;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eпроверяется подпись над TBS структурой, в которую входят cookie обеих сторон и публичный эфемерный ключ противоположной стороны. Подпись проверяется долгоживущим ключом подписи собеседника.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003E 441     try:\n 442         peer_name = validate_tbe(\n 443             msg_handshake1,\n 444             key_handshake1_mac_identity,\n 445             key_handshake1_enc,\n 446             key_handshake1_mac,\n 447             cookie_our,\n 448             cookie_their,\n 449             pub_their_raw,\n 450         )\n 451     except ValueError as err:\n 452         logging.warning(\"%s: %s, disconnecting\", _id, err)\n 453         writer.close()\n 454         return\n 455     # }}}\n\n 128 def validate_tbe(\n 129         msg_handshake: Union[MsgHandshake1, MsgHandshake2],\n 130         key_mac_identity: bytes,\n 131         key_enc: bytes,\n 132         key_mac: bytes,\n 133         cookie_their: Cookie,\n 134         cookie_our: Cookie,\n 135         pub_key_our: PubKey,\n 136 ) -\u003E str:\n 137     ciphertext = bytes(msg_handshake[\"ciphertext\"])\n 138     mac_tag = mac(GOST3412Kuznechik(key_mac).encrypt, KUZNECHIK_BLOCKSIZE, ciphertext)\n 139     if not compare_digest(mac_tag, bytes(msg_handshake[\"ciphertextMac\"])):\n 140         raise ValueError(\"invalid MAC\")\n 141     plaintext = ctr(\n 142         GOST3412Kuznechik(key_enc).encrypt,\n 143         KUZNECHIK_BLOCKSIZE,\n 144         ciphertext,\n 145         8 * b\"\\x00\",\n 146     )\n 147     try:\n 148         tbe, _ = HandshakeTBE().decode(plaintext)\n 149     except ASN1Error:\n 150         raise ValueError(\"can not decode TBE\")\n 151     key_sign_pub_hash = bytes(tbe[\"identity\"])\n 152     peer = KEYS.get(key_sign_pub_hash)\n 153     if peer is None:\n 154         raise ValueError(\"unknown identity\")\n 155     mac_tag = mac(\n 156         GOST3412Kuznechik(key_mac_identity).encrypt,\n 157         KUZNECHIK_BLOCKSIZE,\n 158         key_sign_pub_hash,\n 159     )\n 160     if not compare_digest(mac_tag, bytes(tbe[\"identityMac\"])):\n 161         raise ValueError(\"invalid identity MAC\")\n 162     tbs = HandshakeTBS((\n 163         (\"cookieTheir\", cookie_their),\n 164         (\"cookieOur\", cookie_our),\n 165         (\"pubKeyOur\", pub_key_our),\n 166     ))\n 167     if not gost3410.verify(\n 168         CURVE,\n 169         peer[\"pub\"],\n 170         GOST34112012256(tbs.encode()).digest(),\n 171         bytes(tbe[\"signature\"]),\n 172     ):\n 173         raise ValueError(\"invalid signature\")\n 174     return peer[\"name\"]\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nКак уже писал выше, 34.13-2015 описывает различные \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002F%D0%A0%D0%B5%D0%B6%D0%B8%D0%BC_%D1%88%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F\" rel=\"nofollow\"\u003Eрежимы работы блочных шифров\u003C\u002Fa\u003E из 34.12-2015. Среди них есть режим выработки имитовставки, вычисления MAC-а. В PyGOST это gost3413.mac(). Этот режим требует передачи функции шифрования (принимающая и возвращающая один блок данных), размера шифроблока и, собственно, самих данных. Почему нельзя hardcode-ить размер шифроблока? 34.12-2015 описывает не только 128-битный шифр Кузнечик, но ещё и 64-битную \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002F%D0%93%D0%9E%D0%A1%D0%A2_28147-89_%C2%AB%D0%9C%D0%B0%D0%B3%D0%BC%D0%B0%C2%BB\" rel=\"nofollow\"\u003EМагму\u003C\u002Fa\u003E — немного изменённый ГОСТ 28147-89, созданный ещё в КГБ и до сих пор имеющий один из самых высоких порогов безопасности.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКузнечик инициализируется gost.3412.GOST3412Kuznechik(key) вызовом и возвращает объект с .encrypt()\u002F.decrypt() методами, пригодными для передачи в 34.13 функции. MAC вычисляется следующим образом: gost3413.mac(GOST3412Kuznechik(key).encrypt, KUZNECHIK_BLOCKSIZE, ciphertext). Для сравнения вычисленного и пришедшего MAC-а нельзя использовать обычное сравнение (==) байтовых строк, так как это операция даёт утечки времени сравнения, что, в общем случае, может приводить к фатальным уязвимостям типа \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FBEAST_(computer_security)#Attacks_against_TLS\u002FSSL\" rel=\"nofollow\"\u003EBEAST\u003C\u002Fa\u003E атаки на TLS. В Python имеется специальная hmac.compare_digest функция для этого.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nФункция блочного шифра может зашифровать только один блок данных. Для большего количества, да ещё и не кратной длины, необходимо использовать режим шифрования. В 34.13-2015 описаны следующие: ECB, CTR, OFB, CBC, CFB. У каждого свои допустимые сферы применения и характеристики. К огромному сожалению, у нас до сих пор нет стандартизованных \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002FAEAD-%D1%80%D0%B5%D0%B6%D0%B8%D0%BC_%D0%B1%D0%BB%D0%BE%D1%87%D0%BD%D0%BE%D0%B3%D0%BE_%D1%88%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F\" rel=\"nofollow\"\u003Eаутентифицированных режимов шифрования\u003C\u002Fa\u003E (типа CCM, OCB, GCM и подобных) — мы вынуждены самостоятельно хотя бы добавлять MAC. Я выбираю \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002F%D0%A0%D0%B5%D0%B6%D0%B8%D0%BC_%D1%88%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F#Counter_mode_(CTR)\" rel=\"nofollow\"\u003Eрежим счётчика\u003C\u002Fa\u003E (CTR): он не требует дополнения до размера блока, может распараллеливаться, использует только функцию шифрования, может быть безопасно использован для шифрования большого количества сообщений (в отличии от CBC, у которого относительно быстро начинаются коллизии).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКак и .mac(), .ctr() принимает похожие данные на входе: ciphertext = gost3413.ctr(GOST3412Kuznechik(key).encrypt, KUZNECHIK_BLOCKSIZE, plaintext, iv). Требуется задание вектора инициализации, длиной ровно в половину шифроблока. Если наш ключ шифрования используется только для шифрования одного сообщения (пускай и из нескольких блоков), то безопасно задать нулевой вектор инициализации. Для шифрования handshake сообщений у нас используется каждый раз отдельный ключ.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПроверка подписи gost3410.verify() тривиальна: передаём эллиптическую кривую в пределах которой работаем (её мы просто фиксируем в нашем GOSTIM протоколе), публичный ключ подписанта (не забываем, что это должен быть кортеж из двух больших чисел, а не байтовая строка), 34.11-2012 хэш и сама пришедшая подпись.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДалее, в инициаторе мы подготавливаем и отсылаем handshake2 сообщение рукопожатия, производя те же самые действия что мы и делали при проверке, только симметрично: подпись на своих ключах вместо проверки, и т.п…\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003E 456     # Prepare and send Handshake 2 message {{{\n 457     tbs = HandshakeTBS((\n 458         (\"cookieTheir\", cookie_their),\n 459         (\"cookieOur\", cookie_our),\n 460         (\"pubKeyOur\", pub_our_raw),\n 461     ))\n 462     signature = gost3410.sign(\n 463         CURVE,\n 464         KEY_OUR_SIGN_PRV,\n 465         GOST34112012256(tbs.encode()).digest(),\n 466     )\n 467     key_handshake2_mac_identity = kdf.expand(b\"handshake2-mac-identity\")\n 468     mac_tag = mac(\n 469         GOST3412Kuznechik(key_handshake2_mac_identity).encrypt,\n 470         KUZNECHIK_BLOCKSIZE,\n 471         bytes(KEY_OUR_SIGN_PUB_HASH),\n 472     )\n 473     tbe = HandshakeTBE((\n 474         (\"identity\", KEY_OUR_SIGN_PUB_HASH),\n 475         (\"signature\", OctetString(signature)),\n 476         (\"identityMac\", MAC(mac_tag)),\n 477     ))\n 478     tbe_raw = tbe.encode()\n 479     key_handshake2_enc = kdf.expand(b\"handshake2-enc\")\n 480     key_handshake2_mac = kdf.expand(b\"handshake2-mac\")\n 481     ciphertext = ctr(\n 482         GOST3412Kuznechik(key_handshake2_enc).encrypt,\n 483         KUZNECHIK_BLOCKSIZE,\n 484         tbe_raw,\n 485         8 * b\"\\x00\",\n 486     )\n 487     mac_tag = mac(\n 488         GOST3412Kuznechik(key_handshake2_mac).encrypt,\n 489         KUZNECHIK_BLOCKSIZE,\n 490         ciphertext,\n 491     )\n 492     writer.write(Msg((\"handshake2\", MsgHandshake2((\n 493         (\"ciphertext\", OctetString(ciphertext)),\n 494         (\"ciphertextMac\", MAC(mac_tag)),\n 495     )))).encode())\n 496     # }}}\n 497     await writer.drain()\n 498     logging.info(\"%s: session established: %s\", _id, peer_name)\n \u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nКогда сессия установлена, то вырабатываются транспортные ключи (отдельный ключ для шифрования, для аутентификации, для каждой из сторон), инициализируется Кузнечик для дешифрования и проверки MAC-а:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003E 499     # Run text message sender, initialize transport decoder {{{\n 500     key_initiator_enc = kdf.expand(b\"transport-initiator-enc\")\n 501     key_initiator_mac = kdf.expand(b\"transport-initiator-mac\")\n 502     key_responder_enc = kdf.expand(b\"transport-responder-enc\")\n 503     key_responder_mac = kdf.expand(b\"transport-responder-mac\")\n ...\n 509     asyncio.ensure_future(msg_sender(\n 510         peer_name,\n 511         key_initiator_enc,\n 512         key_initiator_mac,\n 513         writer,\n 514     ))\n 515     encrypter = GOST3412Kuznechik(key_responder_enc).encrypt\n 516     macer = GOST3412Kuznechik(key_responder_mac).encrypt\n 517     # }}}\n 519     nonce_expected = 0\n\n 520     # Wait for test messages {{{\n 521     while True:\n 522         data = await reader.read(MaxMsgLen)\n ...\n 530             msg, tail = Msg().decode(buf)\n ...\n 537         try:\n 538             await msg_receiver(\n 539                 msg.value,\n 540                 nonce_expected,\n 541                 macer,\n 542                 encrypter,\n 543                 peer_name,\n 544             )\n 545         except ValueError as err:\n 546             logging.warning(\"%s: %s\", err)\n 547             break\n 548         nonce_expected += 1\n 549     # }}}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nmsg_sender корутина теперь шифрует сообщения, перед отправкой в TCP-соединение. У каждого сообщения монотонно возрастающий nonce, также являющийся и вектором инициализации при шифровании в режиме счётчика. У каждого сообщения и блока сообщения гарантированно будут отличающиеся значения счётчика.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Easync def msg_sender(peer_name: str, key_enc: bytes, key_mac: bytes, writer) -\u003E None:\n    nonce = 0\n    encrypter = GOST3412Kuznechik(key_enc).encrypt\n    macer = GOST3412Kuznechik(key_mac).encrypt\n    in_queue = IN_QUEUES[peer_name]\n    while True:\n        text = await in_queue.get()\n        if text is None:\n            break\n        ciphertext = ctr(\n            encrypter,\n            KUZNECHIK_BLOCKSIZE,\n            text.encode(\"utf-8\"),\n            long2bytes(nonce, 8),\n        )\n        payload = MsgTextPayload((\n            (\"nonce\", Integer(nonce)),\n            (\"ciphertext\", OctetString(ciphertext)),\n        ))\n        mac_tag = mac(macer, KUZNECHIK_BLOCKSIZE, payload.encode())\n        writer.write(Msg((\"text\", MsgText((\n            (\"payload\", payload),\n            (\"payloadMac\", MAC(mac_tag)),\n        )))).encode())\n        nonce += 1\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПриходящие сообщения обрабатываются корутиной msg_receiver, занимающейся аутентификацией и дешифрацией:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Easync def msg_receiver(\n        msg_text: MsgText,\n        nonce_expected: int,\n        macer,\n        encrypter,\n        peer_name: str,\n) -\u003E None:\n    payload = msg_text[\"payload\"]\n    if int(payload[\"nonce\"]) != nonce_expected:\n        raise ValueError(\"unexpected nonce value\")\n    mac_tag = mac(macer, KUZNECHIK_BLOCKSIZE, payload.encode())\n    if not compare_digest(mac_tag, bytes(msg_text[\"payloadMac\"])):\n        raise ValueError(\"invalid MAC\")\n    plaintext = ctr(\n        encrypter,\n        KUZNECHIK_BLOCKSIZE,\n        bytes(payload[\"ciphertext\"]),\n        long2bytes(nonce_expected, 8),\n    )\n    text = plaintext.decode(\"utf-8\")\n    await OUT_QUEUES[peer_name].put(text)\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EЗаключение\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nGOSTIM предполагается использовать исключительно в учебных целях (так как не покрыт тестами, как минимум)! Исходный код программы можно скачать \u003Ca href=\"http:\u002F\u002Fwww.pygost.cypherpunks.ru\u002Fgostim.txz\" rel=\"nofollow\"\u003Eтут\u003C\u002Fa\u003E (Стрибог-256 хэш: 995bbd368c04e50a481d138c5fa2e43ec7c89bc77743ba8dbabee1fde45de120). Как и все мои проекты, типа \u003Ca href=\"http:\u002F\u002Fwww.gogost.cypherpunks.ru\u002F\" rel=\"nofollow\"\u003EGoGOST\u003C\u002Fa\u003E, \u003Ca href=\"http:\u002F\u002Fwww.pyderasn.cypherpunks.ru\u002F\" rel=\"nofollow\"\u003EPyDERASN\u003C\u002Fa\u003E, \u003Ca href=\"http:\u002F\u002Fwww.nncpgo.org\u002F\" rel=\"nofollow\"\u003ENNCP\u003C\u002Fa\u003E, \u003Ca href=\"http:\u002F\u002Fwww.govpn.info\u002F\" rel=\"nofollow\"\u003EGoVPN\u003C\u002Fa\u003E, GOSTIM является полностью \u003Ca href=\"https:\u002F\u002Fwww.gnu.org\u002Fphilosophy\u002Ffree-sw.ru.html\" rel=\"nofollow\"\u003Eсвободным ПО\u003C\u002Fa\u003E, распространяемым на условиях \u003Ca href=\"https:\u002F\u002Fwww.gnu.org\u002Flicenses\u002Fgpl-3.0.ru.html\" rel=\"nofollow\"\u003EGPLv3+\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca href=\"http:\u002F\u002Fwww.stargrave.org\u002F\" rel=\"nofollow\"\u003EСергей Матвеев\u003C\u002Fa\u003E, \u003Ca href=\"http:\u002F\u002Fwww.cypherpunks.ru\u002F\" rel=\"nofollow\"\u003Eшифропанк\u003C\u002Fa\u003E, член \u003Ca href=\"https:\u002F\u002Fwww.fsf.org\u002F\" rel=\"nofollow\"\u003EФонда СПО\u003C\u002Fa\u003E, Python\u002FGo-разработчик, главный специалист ФГУП «НТЦ „Атлас“.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"python"},{"titleHtml":"pygost"},{"titleHtml":"pyderasn"},{"titleHtml":"asyncio"},{"titleHtml":"suckless"},{"titleHtml":"asn.1"},{"titleHtml":"im"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F452200\u002F3e8cee03bb82ac218966636d55c1a488\u002F","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F452200\u002F3e8cee03bb82ac218966636d55c1a488\u002F?format=vk","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F452200\\\u002F\"},\"headline\":\"GOSTIM: P2P F2F E2EE IM за один вечер с ГОСТ-криптографией\",\"datePublished\":\"2019-05-16T18:30:59+03:00\",\"dateModified\":\"2020-12-15T20:09:12+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"stargrave2\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"Будучи разработчиком PyGOST библиотеки (ГОСТовые криптографические примитивы на чистом Python), я нередко получаю вопросы о том, как на коленке реализовать прост...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F452200\\\u002F#post-content-body\",\"about\":[\"h_p2p\",\"h_infosecurity\",\"h_crypto\",\"h_python\",\"h_programming\",\"f_develop\",\"f_admin\"],\"image\":[\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F4e2\\\u002F2bb\\\u002Ff04\\\u002F4e22bbf0480a8181bcbb2054c6f95815.jpg\"]}","metaDescription":"Будучи разработчиком PyGOST библиотеки (ГОСТовые криптографические примитивы на чистом Python), я нередко получаю вопросы о том, как на коленке реализовать простейший безопасный обмен сообщениями....","mainImageUrl":null,"amp":false},"polls":[],"commentsEnabled":true,"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":false}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[],"hubs":"p2p,infosecurity,crypto,python,programming"},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{}},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"dfp":{"slotsDict":{}},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.c0af73e7.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
</body>
</html>
