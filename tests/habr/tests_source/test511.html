<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <title>Ищем свободное парковочное место с Python / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.c0af73e7.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.85eb77f0b17c8235e7b64b9f81ea5ec2.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" src="/js/ads.js" onload="window['zhY4i4nJ9K'] = true" data-vmid="checkad"></script><script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/post\/451164\/"},"headline":"Ищем свободное парковочное место с Python","datePublished":"2019-05-10T14:29:37+03:00","dateModified":"2019-05-22T14:41:06+03:00","author":{"@type":"Person","name":"Rushan"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"Я живу в хорошем городе. Но, как и во многих других, поиск парковочного места всегда превращается в испытание. Свободные места быстро занимают, и даже если у в...","url":"https:\/\/habr.com\/ru\/post\/451164\/#post-content-body","about":["h_python","h_data_mining","h_artificial_intelligence","h_futurenow","f_develop","f_popsci"],"image":["https:\/\/habrastorage.org\/webt\/vz\/x5\/od\/vzx5odyqel0ow-z2qolfdo1htd4.gif","https:\/\/habrastorage.org\/webt\/lx\/md\/gy\/lxmdgyxkvnwtwc5nsqccy83mp34.gif","https:\/\/habrastorage.org\/webt\/q7\/gi\/hi\/q7gihifth7-k9mad7fhgbj4itcc.jpeg","https:\/\/habrastorage.org\/webt\/aa\/wk\/ig\/aawkigsexhbk5s4slqmvksvofcm.gif","https:\/\/habrastorage.org\/webt\/2u\/zl\/xt\/2uzlxtgxbn6jvfkhfy0e523ow88.png","https:\/\/habrastorage.org\/webt\/m-\/bq\/xb\/m-bqxb9ybcjc44blvsuzhnw6xyk.png","https:\/\/habrastorage.org\/webt\/qi\/g8\/cj\/qig8cjwmp7dmduejcddjk6tnoiw.png","https:\/\/habrastorage.org\/webt\/bo\/vv\/nu\/bovvnu6rsl-zimlr1gtpp1a_egm.png","https:\/\/habrastorage.org\/webt\/b8\/tb\/ua\/b8tbuafyf4uci3jy61jnjlwanqa.png","https:\/\/habrastorage.org\/webt\/n2\/b0\/hp\/n2b0hpwgwpkn6ahfhqetvbhq1rg.png","https:\/\/habrastorage.org\/webt\/dv\/lz\/7l\/dvlz7ltgwmudog9-b2f6i7tlmhe.jpeg","https:\/\/habrastorage.org\/webt\/vy\/kq\/50\/vykq50pcxhyt_vkmfzmxk_fgl5g.png","https:\/\/habrastorage.org\/webt\/_p\/il\/0r\/_pil0reoz3gj7dtqboav_rgerl8.jpeg","https:\/\/habrastorage.org\/webt\/7t\/vi\/4q\/7tvi4q1rgvkfkaljrsp8sjathr0.jpeg","https:\/\/habrastorage.org\/webt\/zs\/c0\/sz\/zsc0szsct8xjwkx5eo-6ieynfuc.png"]}</script>
  <script src="//www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.49.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_eng"><meta data-vue-meta="ssr" property="og:title" content="Ищем свободное парковочное место с Python" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="Ищем свободное парковочное место с Python" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="Ищем свободное парковочное место с Python" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="Я живу в хорошем городе. Но, как и во многих других, поиск парковочного места всегда превращается в испытание. Свободные места быстро занимают, и даже если у вас есть своё собственное, друзьям..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="Я живу в хорошем городе. Но, как и во многих других, поиск парковочного места всегда превращается в испытание. Свободные места быстро занимают, и даже если у вас есть своё собственное, друзьям..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="Я живу в хорошем городе. Но, как и во многих других, поиск парковочного места всегда превращается в испытание. Свободные места быстро занимают, и даже если у вас есть своё собственное, друзьям..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="Я живу в хорошем городе. Но, как и во многих других, поиск парковочного места всегда превращается в испытание. Свободные места быстро занимают, и даже если у вас есть своё собственное, друзьям..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="Я живу в хорошем городе. Но, как и во многих других, поиск парковочного места всегда превращается в испытание. Свободные места быстро занимают, и даже если у вас есть своё собственное, друзьям..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habr.com/share/publication/451164/8b6c4428e38fba9df4fdce9941680c81/" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habr.com/share/publication/451164/8b6c4428e38fba9df4fdce9941680c81/" data-vmid="og:image"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habr.com/share/publication/451164/8b6c4428e38fba9df4fdce9941680c81/" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habr.com/share/publication/451164/8b6c4428e38fba9df4fdce9941680c81/" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habr.com/share/publication/451164/8b6c4428e38fba9df4fdce9941680c81/" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="451164" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2019-05-10T11:29:37.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/451164/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="https://habr.com/ru/post/451164/" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habr.com/share/publication/451164/8b6c4428e38fba9df4fdce9941680c81/" data-vmid="image:href">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="/ru/sandbox/start/" class="tm-header__become-author-btn">
            Как стать автором
          </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="/ru/all/" class="tm-main-menu__item">
        Все потоки
      </a> <a href="/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" data-async-called="true" class="tm-page"><div class="tm-page-width"><!----> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="/ru/users/Syurmakov/" title="Syurmakov" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="" height="24" loading="lazy" src="//habrastorage.org/r/w32/getpro/habr/avatars/82c/a16/317/82ca1631721b8d3bbc7b4a0d98d4c2aa.jpg" width="24" class="tm-entity-image__pic"></div></a> <span class="tm-user-info__user"><a href="/ru/users/Syurmakov/" class="tm-user-info__username">
      Syurmakov
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2019-05-10T11:29:37.000Z" title="2019-05-10, 14:29">10  мая  2019 в 14:29</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>Ищем свободное парковочное место с Python</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/python/" class="tm-article-snippet__hubs-item-link"><span>Python</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/data_mining/" class="tm-article-snippet__hubs-item-link"><span>Data Mining</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/artificial_intelligence/" class="tm-article-snippet__hubs-item-link"><span>Искусственный интеллект</span> <!----></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/futurenow/" class="tm-article-snippet__hubs-item-link"><span>Будущее здесь</span> <!----></a></span></div> <div class="tm-article-snippet__labels"><div class="tm-article-snippet__label"><span>
        Перевод
      </span></div></div> <!----> <!----></div></div> <div class="tm-article-presenter__origin"><a href="https://medium.com/@ageitgey/snagging-parking-spaces-with-mask-r-cnn-and-python-955f2231c400" target="_blank" class="tm-article-presenter__origin-link">
                Автор оригинала:
                <span>
                  Adam Geitgey
                </span></a></div> <div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-1"><div xmlns="http://www.w3.org/1999/xhtml"><img src="/img/image-loader.svg" alt="image" data-src="https://habrastorage.org/webt/vz/x5/od/vzx5odyqel0ow-z2qolfdo1htd4.gif"/><br/>
<br/>
Я живу в хорошем городе. Но, как и во многих других, поиск парковочного места всегда превращается в испытание. Свободные места быстро занимают, и даже если у вас есть своё собственное, друзьям будет сложно к вам заехать, ведь им будет негде припарковаться.<br/>
<br/>
Поэтому я решил направить камеру в окно и использовать глубокое обучение, чтобы мой компьютер сообщал мне, когда освободится место:<br/>
<br/>
<img src="/img/image-loader.svg" alt="image" data-src="https://habrastorage.org/webt/lx/md/gy/lxmdgyxkvnwtwc5nsqccy83mp34.gif"/><br/>
<br/>
Это может звучать сложно, но на самом деле написать рабочий прототип с глубоким обучением — быстро и легко. Все нужные составляющие уже есть — нужно всего лишь знать, где их найти и как собрать воедино.<br/>
<br/>
Поэтому давайте немного развлечёмся и напишем точную систему уведомлений о свободной парковке с помощью Python и глубокого обучения<a name="habracut"></a><br/>
<br/>
<h3>Декомпозируем задачу</h3><br/>
Когда у нас есть сложная задача, которую мы хотим решить с помощью машинного обучения, первым шагом нужно разбить её на последовательность простых задач. Затем мы можем использовать различные инструменты для решения каждой из них. Объединив несколько простых решений воедино, мы получим систему, которая способна на нечто сложное.<br/>
<br/>
Вот, как я разбил свою задачу:<br/>
<br/>
<img src="https://habrastorage.org/r/w780q1/webt/q7/gi/hi/q7gihifth7-k9mad7fhgbj4itcc.jpeg" alt="image" data-src="https://habrastorage.org/webt/q7/gi/hi/q7gihifth7-k9mad7fhgbj4itcc.jpeg" data-blurred="true"/><br/>
<br/>
На вход конвейера поступает видеопоток с веб-камеры, направленной в окно:<br/>
<br/>
<img src="/img/image-loader.svg" alt="image" data-src="https://habrastorage.org/webt/aa/wk/ig/aawkigsexhbk5s4slqmvksvofcm.gif"/><br/>
<br/>
Через конвейер мы будем передавать каждый кадр видео, по одному за раз.<br/>
<br/>
Первым шагом нужно распознать все возможные парковочные места на кадре. Очевидно, что прежде чем мы сможем искать незанятые места, нам нужно понять, в каких частях изображения находится парковка.<br/>
<br/>
Затем на каждом кадре нужно найти все машины. Это позволит нам отслеживать движение каждой машины от кадра к кадру.<br/>
<br/>
Третьим шагом нужно определить, какие места заняты машинами, а какие — нет. Для этого нужно совместить результаты первых двух шагов.<br/>
<br/>
Наконец, программа должна прислать оповещение, когда освободится парковочное место. Это будет определяться за счёт изменений в расположении машин между кадрами видео.<br/>
<br/>
Каждый из этих этапов можно пройти разными способами с помощью разных технологий. Нет единственного правильного или неправильного способа составить этот конвейер, у разных подходов будут свои преимущества и недостатки. Давайте разберёмся с каждым шагом подробнее.<br/>
<br/>
<h3>Распознаём парковочные места</h3><br/>
Вот, что видит наша камера:<br/>
<br/>
<img src="/img/image-loader.svg" alt="image" data-src="https://habrastorage.org/webt/2u/zl/xt/2uzlxtgxbn6jvfkhfy0e523ow88.png"/><br/>
<br/>
Нам нужно как-то просканировать это изображение и получить список мест, где можно припарковаться:<br/>
<br/>
<img src="/img/image-loader.svg" alt="image" data-src="https://habrastorage.org/webt/m-/bq/xb/m-bqxb9ybcjc44blvsuzhnw6xyk.png"/><br/>
<br/>
Решением «в лоб» было бы просто захардкодить местоположения всех парковочных мест вручную вместо автоматического распознавания. Но в таком случае, если мы переместим камеру или захотим искать парковочные места на другой улице, нам придётся проделывать всю процедуру заново. Звучит так себе, поэтому поищем автоматический способ распознавания парковочных мест.<br/>
<br/>
Как вариант, можно искать на изображении паркометры и предположить, что рядом с каждым из них есть парковочное место:<br/>
<br/>
<img src="/img/image-loader.svg" alt="image" data-src="https://habrastorage.org/webt/qi/g8/cj/qig8cjwmp7dmduejcddjk6tnoiw.png"/><br/>
<br/>
Однако с этим подходом не всё так гладко. Во-первых, не у каждого парковочного места есть паркометр, да и вообще, нам больше интересен поиск парковочных мест, за которые не надо платить. Во-вторых, местоположение паркометра ничего не говорит нам о том, где находится парковочное место, а всего лишь позволяет сделать предположение.<br/>
<br/>
Другая идея заключается в создании модели распознавания объектов, которая ищет метки парковочного места, нарисованные на дороге:<br/>
<br/>
<img src="/img/image-loader.svg" alt="image" data-src="https://habrastorage.org/webt/bo/vv/nu/bovvnu6rsl-zimlr1gtpp1a_egm.png"/><br/>
<br/>
Но и этот подход — так себе. Во-первых, в моём городе все такие метки очень маленькие и трудноразличимые на расстоянии, поэтому их будет сложно обнаружить с помощью компьютера. Во-вторых, на улице полно всяких других линий и меток. Будет сложно отделить парковочные метки от разделителей полос и пешеходных переходов.<br/>
<br/>
Когда вы сталкиваетесь с проблемой, которая на первый взгляд кажется сложной, потратьте несколько минут на поиск другого подхода к решению задачи, который поможет обойти некоторые технические проблемы. Что вообще есть парковочное место? Это всего лишь место, на которое на долгое время паркуют машину. Возможно, нам вовсе и не нужно распознавать парковочные места. Почему бы нам просто не распознавать машины, которые долгое время стоят на месте, и не делать предположение, что они стоят на парковочном месте?<br/>
<br/>
Другими словами, парковочные места расположены там, где подолгу стоят машины:<br/>
<br/>
<img src="/img/image-loader.svg" alt="image" data-src="https://habrastorage.org/webt/b8/tb/ua/b8tbuafyf4uci3jy61jnjlwanqa.png"/><br/>
<br/>
Таким образом, если мы сможем распознать машины и выяснить, которые из них не двигаются между кадрами, мы сможем предположить, где находятся парковочные места. Проще простого — переходим к распознаванию машин!<br/>
<br/>
<h3>Распознаём машины</h3><br/>
Распознавание машин на кадре видео является классической задачей распознавания объектов. Существует множество подходов на основе машинного обучения, которые мы могли бы использовать для распознавания. Вот некоторые из них в порядке от «старой школы» к «новой школе»:<br/>
<br/>
<ul>
<li>Можно обучить детектор на основе HOG (Histogram of Oriented Gradients, гистограммы направленных градиентов) и пройтись им по всему изображению, чтобы найти все машины. Этот старый подход, не использующий глубокое обучение, работает относительно быстро, но не очень хорошо справляется с машинами, расположенными по-разному.</li>
<li>Можно обучить детектор на основе CNN (Convolutional Neural Network, свёрточная нейронная сеть) и пройтись им по всему изображению, пока не найдём все машины. Этот подход работает точно, но не так эффективно, так как нам нужно просканировать изображение несколько раз с помощью CNN, чтобы найти все машины. И хотя так мы сможем найти машины, расположенные по-разному, нам потребуется гораздо больше обучающих данных, чем для HOG-детектора.</li>
<li>Можно использовать новый подход с глубоким обучением вроде Mask R-CNN, Faster R-CNN или YOLO, который совмещает в себе точность CNN и набор технических хитростей, сильно повышающих скорость распознавания. Такие модели будут работать относительно быстро (на GPU), если у нас есть много данных для обучения модели.</li>
</ul><br/>
В общем случае нам нужно самое простое решение, которое будет работать как надо и потребует наименьшее количество обучающих данных. Не обязательно, чтобы это был самый новый и быстрый алгоритм. Однако конкретно в нашем случае Mask R-CNN — разумный выбор, несмотря на то, что он довольно новый и быстрый.<br/>
<br/>
Архитектура Mask R-CNN разработана таким образом, что она распознаёт объекты на всём изображении, эффективно тратя ресурсы, и при этом не использует подход скользящего окна. Другими словами, она работает довольно быстро. С современным GPU мы сможем распознавать объекты на видео в высоком разрешении на скорости в несколько кадров в секунду. Для нашего проекта этого должно быть достаточно.<br/>
<br/>
Кроме того, Mask R-CNN даёт много информации о каждом распознанном объекте. Большинство алгоритмов распознавания возвращают только ограничивающую рамку для каждого объекта. Однако Mask R-CNN не только даст нам местоположение каждого объекта, но и его контур (маску):<br/>
<br/>
<img src="/img/image-loader.svg" alt="image" data-src="https://habrastorage.org/webt/n2/b0/hp/n2b0hpwgwpkn6ahfhqetvbhq1rg.png"/><br/>
<br/>
Для обучения Mask R-CNN нам нужно много изображений объектов, которые мы хотим распознавать. Мы могли бы выйти на улицу, сфотографировать машины и обозначить их на фотографиях, что потребовало бы несколько дней работы. К счастью, машины — одни из тех объектов, которые люди часто хотят распознать, поэтому уже существуют несколько общедоступных датасетов с изображениями машин.<br/>
<br/>
Один из них — популярный датасет <a href="http://cocodataset.org/">СОСО</a>(сокращение для Common Objects In Context), в котором есть изображения, аннотированные масками объектов. В этом датасете находится более 12 000 изображений с уже размеченными машинами. Вот пример изображения из датасета:<br/>
<br/>
<img src="https://habrastorage.org/r/w780q1/webt/dv/lz/7l/dvlz7ltgwmudog9-b2f6i7tlmhe.jpeg" alt="image" data-src="https://habrastorage.org/webt/dv/lz/7l/dvlz7ltgwmudog9-b2f6i7tlmhe.jpeg" data-blurred="true"/><br/>
<br/>
Такие данные отлично подходят для обучения модели на основе Mask R-CNN.<br/>
<br/>
Но придержите коней, есть новости ещё лучше! Мы не первые, кому захотелось обучить свою модель с помощью датасета COCO — многие люди уже сделали это до нас и поделились своими результатами. Поэтому вместо обучения своей модели мы можем взять готовую, которая уже может распознавать машины. Для нашего проекта мы воспользуемся <a href="https://github.com/matterport/Mask_RCNN">open-source моделью от Matterport.</a><br/>
<br/>
Если дать на вход этой модели изображение с камеры, вот что мы получим уже «из коробки»:<br/>
<br/>
<img src="/img/image-loader.svg" alt="image" data-src="https://habrastorage.org/webt/vy/kq/50/vykq50pcxhyt_vkmfzmxk_fgl5g.png"/><br/>
<br/>
Модель распознала не только машины, но и такие объекты, как светофоры и люди. Забавно, что дерево она распознала как комнатное растение.<br/>
<br/>
Для каждого распознанного объекта модель Mask R-CNN возвращает 4 вещи:<br/>
<br/>
<ul>
<li>Тип обнаруженного объекта (целое число). Предобученная модель COCO умеет распознавать 80 разных часто встречающихся объектов вроде машин и грузовиков. С их полным списком можно ознакомиться <a href="https://gist.github.com/ageitgey/b143ee809bf08e4927dd59bace44db0d">здесь.</a></li>
<li>Степень уверенности в результатах распознавания. Чем выше число, тем сильнее модель уверена в правильности распознавания объекта.</li>
<li>Ограничивающая рамка для объекта в форме XY-координат пикселей на изображении.</li>
<li>«Маска», которая показывает, какие пиксели внутри ограничивающей рамки являются частью объекта. С помощью данных маски можно найти контур объекта.</li>
</ul><br/>
Ниже показан код на Python для обнаружения ограничивающей рамки для машин с помощью предобученной модели Mask R-CNN и OpenCV:<br/>
<br/>
<pre><code class="python">import numpy as np
import cv2
import mrcnn.config
import mrcnn.utils
from mrcnn.model import MaskRCNN
from pathlib import Path


# Конфигурация, которую будет использовать библиотека Mask-RCNN.
class MaskRCNNConfig(mrcnn.config.Config):
    NAME = "coco_pretrained_model_config"
    IMAGES_PER_GPU = 1
    GPU_COUNT = 1
    NUM_CLASSES = 1 + 80  # в датасете COCO находится 80 классов + 1 фоновый класс.
    DETECTION_MIN_CONFIDENCE = 0.6


# Фильтруем список результатов распознавания, чтобы остались только автомобили.
def get_car_boxes(boxes, class_ids):
    car_boxes = []

    for i, box in enumerate(boxes):
        # Если найденный объект не автомобиль, то пропускаем его.
        if class_ids[i] in [3, 8, 6]:
            car_boxes.append(box)

    return np.array(car_boxes)


# Корневая директория проекта.
ROOT_DIR = Path(".")

# Директория для сохранения логов и обученной модели.
MODEL_DIR = ROOT_DIR / "logs"

# Локальный путь к файлу с обученными весами.
COCO_MODEL_PATH = ROOT_DIR / "mask_rcnn_coco.h5"

# Загружаем датасет COCO при необходимости.
if not COCO_MODEL_PATH.exists():
    mrcnn.utils.download_trained_weights(COCO_MODEL_PATH)

# Директория с изображениями для обработки.
IMAGE_DIR = ROOT_DIR / "images"

# Видеофайл или камера для обработки — вставьте значение 0, если нужно использовать камеру, а не видеофайл.
VIDEO_SOURCE = "test_images/parking.mp4"

# Создаём модель Mask-RCNN в режиме вывода.
model = MaskRCNN(mode="inference", model_dir=MODEL_DIR, config=MaskRCNNConfig())

# Загружаем предобученную модель.
model.load_weights(COCO_MODEL_PATH, by_name=True)

# Местоположение парковочных мест.
parked_car_boxes = None

# Загружаем видеофайл, для которого хотим запустить распознавание.
video_capture = cv2.VideoCapture(VIDEO_SOURCE)

# Проходимся в цикле по каждому кадру.
while video_capture.isOpened():
    success, frame = video_capture.read()
    if not success:
        break

    # Конвертируем изображение из цветовой модели BGR (используется OpenCV) в RGB.
    rgb_image = frame[:, :, ::-1]

    # Подаём изображение модели Mask R-CNN для получения результата.
    results = model.detect([rgb_image], verbose=0)

    # Mask R-CNN предполагает, что мы распознаём объекты на множественных изображениях.
    # Мы передали только одно изображение, поэтому извлекаем только первый результат.
    r = results[0]

    # Переменная r теперь содержит результаты распознавания:
    # - r['rois'] — ограничивающая рамка для каждого распознанного объекта;
    # - r['class_ids'] — идентификатор (тип) объекта;
    # - r['scores'] — степень уверенности;
    # - r['masks'] — маски объектов (что даёт вам их контур).

    # Фильтруем результат для получения рамок автомобилей.
    car_boxes = get_car_boxes(r['rois'], r['class_ids'])

    print("Cars found in frame of video:")

    # Отображаем каждую рамку на кадре.
    for box in car_boxes:
        print("Car:", box)

        y1, x1, y2, x2 = box

        # Рисуем рамку.
        cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 255, 0), 1)

    # Показываем кадр на экране.
    cv2.imshow('Video', frame)

    # Нажмите 'q', чтобы выйти.
    if cv2.waitKey(1) &amp; 0xFF == ord('q'):
        break

# Очищаем всё после завершения.
video_capture.release()
cv2.destroyAllWindows()
</code></pre><br/>
После запуска этого скрипта на экране появится изображение с рамкой вокруг каждой обнаруженной машины:<br/>
<br/>
<img src="https://habrastorage.org/r/w780q1/webt/_p/il/0r/_pil0reoz3gj7dtqboav_rgerl8.jpeg" alt="image" data-src="https://habrastorage.org/webt/_p/il/0r/_pil0reoz3gj7dtqboav_rgerl8.jpeg" data-blurred="true"/><br/>
<br/>
Также в консоль будут выведены координаты каждой машины:<br/>
<br/>
<pre><code class="python">Cars found in frame of video:
Car: [492 871 551 961]
Car: [450 819 509 913]
Car: [411 774 470 856]
</code></pre><br/>
Вот мы и научились распознавать машины на изображении.<br/>
<br/>
<h3>Распознаём пустые парковочные места</h3><br/>
Мы знаем пиксельные координаты каждой машины. Просматривая несколько последовательных кадров, мы легко можем определить, какие из машин не двигались, и предположить, что там находятся парковочные места. Но как понять, что машина покинула парковку?<br/>
<br/>
Проблема в том, что рамки машин частично перекрывают друг друга:<br/>
<br/>
<img src="https://habrastorage.org/r/w780q1/webt/7t/vi/4q/7tvi4q1rgvkfkaljrsp8sjathr0.jpeg" alt="image" data-src="https://habrastorage.org/webt/7t/vi/4q/7tvi4q1rgvkfkaljrsp8sjathr0.jpeg" data-blurred="true"/><br/>
<br/>
Поэтому если представить, что каждая рамка представляет парковочное место, то может оказаться, что оно частично занято машиной, когда на самом деле оно пустое. Нам нужно найти способ измерить степень пересечения двух объектов, чтобы искать только «наиболее пустые» рамки.<br/>
<br/>
Мы воспользуемся мерой под названием Intersection Over Union (отношение площади пересечения к сумме площадей) или IoU. IoU можно найти, посчитав количество пикселей, где пересекаются два объекта, и разделить на количество пикселей, занимаемых этими объектами:<br/>
<br/>
<img src="/img/image-loader.svg" alt="image" data-src="https://habrastorage.org/webt/zs/c0/sz/zsc0szsct8xjwkx5eo-6ieynfuc.png"/><br/>
<br/>
Так мы сможем понять, как сильно ограничивающая рамка машины пересекается с рамкой парковочного места. Это позволит легко определить, свободна ли парковка. Если значение IoU низкое, вроде 0.15, значит, машина занимает малую часть парковочного места. А если оно высокое, вроде 0.6, то это значит, что машина занимает большую часть места и там нельзя припарковаться.<br/>
<br/>
Поскольку IoU используется довольно часто в компьютерном зрении, в соответствующих библиотеках с большой вероятностью есть реализация этой меры. В нашей библиотеке Mask R-CNN она реализована в виде функции mrcnn.utils.compute_overlaps().<br/>
<br/>
Если у нас есть список ограничивающих рамок для парковочных мест, то добавить проверку на наличие машин в этих рамках можно, добавив всего строку-другую кода:<br/>
<br/>
<pre><code class="python">    # Фильтруем результат для получения рамок автомобилей.
    car_boxes = get_car_boxes(r['rois'], r['class_ids'])

    # Смотрим, как сильно машины пересекаются с известными парковочными местами.
    overlaps = mrcnn.utils.compute_overlaps(car_boxes, parking_areas)

    print(overlaps)
</code></pre><br/>
Результат должен выглядеть примерно так:<br/>
<br/>
<pre><code class="python">[
 [1.         0.07040032 0.         0.]
 [0.07040032 1.         0.07673165 0.]
 [0.         0.         0.02332112 0.]
]
</code></pre><br/>
В этом двумерном массиве каждая строка отражает одну рамку парковочного места. А каждый столбец говорит о том, насколько сильно каждое из мест пересекается с одной из обнаруженных машин. Результат 1.0 означает, что всё место полностью занято машиной, а низкое значение вроде 0.02 говорит о том, что машина немного влезла на место, но на нём ещё можно припарковаться.<br/>
<br/>
Чтобы найти незанятые места, нужно всего лишь проверить каждую строку в этом массиве. Если все числа близки к нулю, то скорее всего место свободно!<br/>
<br/>
Однако имейте в виду, что распознавание объектов не всегда работает идеально с видео в реальном времени. Хоть модель на основе Mask R-CNN довольно точна, время от времени она может пропустить машину-другую в одном кадре видео. Поэтому прежде чем утверждать, что место свободно, нужно убедиться, что оно остаётся таким ещё на протяжении 5–10 следующих кадров видео. Таким образом мы сможем избежать ситуаций, когда система ошибочно помечает место пустым из-за глюка на одном кадре видео. Как только мы убедимся, что место остаётся свободным в течение нескольких кадров, можно отсылать сообщение!<br/>
<br/>
<h3>Отправляем SMS</h3><br/>
Последняя часть нашего конвейера — отправка SMS-уведомления при появлении свободного парковочного места.<br/>
<br/>
Отправить сообщение из Python очень легко, если использовать Twilio. Twilio — это популярный API, который позволяет отправлять SMS из практически любого языка программирования с помощью всего нескольких строк кода. Конечно, если вы предпочитаете другой сервис, то можете использовать и его. Я никак не связан с Twilio, просто это первое, что приходит на ум.<br/>
<br/>
Чтобы использовать Twilio, зарегистрируйте <a href="https://www.twilio.com/try-twilio">пробный аккаунт</a>, создайте номер телефона Twilio и получите аутентификационные данные аккаунта. Затем установите клиентскую библиотеку:<br/>
<br/>
<pre><code class="python">$ pip3 install twilio
</code></pre><br/>
После этого используйте следующий код для отправки сообщения:<br/>
<br/>
<pre><code class="python">from twilio.rest import Client

# Данные аккаунта Twilio.
twilio_account_sid = 'Ваш Twilio SID'
twilio_auth_token = 'Ваш токен аутентификации Twilio'
twilio_source_phone_number = 'Ваш номер телефона Twilio'

# Создаём объект клиента Twilio.
client = Client(twilio_account_sid, twilio_auth_token)

# Отправляем SMS.
message = client.messages.create(
    body="Тело сообщения",
    from_=twilio_source_phone_number,
    to="Ваш номер, куда придёт сообщение"
)
</code></pre><br/>
Чтобы добавить возможность отправки сообщений в наш скрипт, просто скопируйте туда этот код. Однако нужно сделать так, чтобы сообщение не отправлялось на каждом кадре, где видно свободное место. Поэтому у нас будет флаг, который в установленном состоянии не даст отправлять сообщения в течение какого-то времени или пока не освободится другое место.<br/>
<br/>
<h3>Складываем всё воедино</h3><br/>
<pre><code class="python">import numpy as np
import cv2
import mrcnn.config
import mrcnn.utils
from mrcnn.model import MaskRCNN
from pathlib import Path
from twilio.rest import Client

# Конфигурация, которую будет использовать библиотека Mask-RCNN.
class MaskRCNNConfig(mrcnn.config.Config):
    NAME = "coco_pretrained_model_config"
    IMAGES_PER_GPU = 1
    GPU_COUNT = 1
    NUM_CLASSES = 1 + 80  # в датасете COCO находится 80 классов + 1 фоновый класс.
    DETECTION_MIN_CONFIDENCE = 0.6

# Фильтруем список результатов распознавания, чтобы остались только автомобили.
def get_car_boxes(boxes, class_ids):
    car_boxes = []

    for i, box in enumerate(boxes):
        # Если найденный объект не автомобиль, то пропускаем его.
        if class_ids[i] in [3, 8, 6]:
            car_boxes.append(box)

    return np.array(car_boxes)

# Конфигурация Twilio.
twilio_account_sid = 'Ваш Twilio SID'
twilio_auth_token = 'Ваш токен аутентификации Twilio'
twilio_phone_number = 'Ваш номер телефона Twilio'
destination_phone_number = 'Номер, куда придёт сообщение'
client = Client(twilio_account_sid, twilio_auth_token)

# Корневая директория проекта.
ROOT_DIR = Path(".")

# Директория для сохранения логов и обученной модели.
MODEL_DIR = ROOT_DIR / "logs"

# Локальный путь к файлу с обученными весами.
COCO_MODEL_PATH = ROOT_DIR / "mask_rcnn_coco.h5"

# Загружаем датасет COCO при необходимости.
if not COCO_MODEL_PATH.exists():
    mrcnn.utils.download_trained_weights(COCO_MODEL_PATH)

# Директория с изображениями для обработки.
IMAGE_DIR = ROOT_DIR / "images"

# Видеофайл или камера для обработки — вставьте значение 0, если использовать камеру, а не видеофайл.
VIDEO_SOURCE = "test_images/parking.mp4"

# Создаём модель Mask-RCNN в режиме вывода.
model = MaskRCNN(mode="inference", model_dir=MODEL_DIR, config=MaskRCNNConfig())

# Загружаем предобученную модель.
model.load_weights(COCO_MODEL_PATH, by_name=True)

# Местоположение парковочных мест.
parked_car_boxes = None

# Загружаем видеофайл, для которого хотим запустить распознавание.
video_capture = cv2.VideoCapture(VIDEO_SOURCE)

# Сколько кадров подряд с пустым местом мы уже видели.
free_space_frames = 0

# Мы уже отправляли SMS?
sms_sent = False

# Проходимся в цикле по каждому кадру.
while video_capture.isOpened():
    success, frame = video_capture.read()
    if not success:
        break

    # Конвертируем изображение из цветовой модели BGR в RGB.
    rgb_image = frame[:, :, ::-1]

    # Подаём изображение модели Mask R-CNN для получения результата.
    results = model.detect([rgb_image], verbose=0)

    # Mask R-CNN предполагает, что мы распознаём объекты на множественных изображениях.
    # Мы передали только одно изображение, поэтому извлекаем только первый результат.
    r = results[0]

    # Переменная r теперь содержит результаты распознавания:
    # - r['rois'] — ограничивающая рамка для каждого распознанного объекта;
    # - r['class_ids'] — идентификатор (тип) объекта;
    # - r['scores'] — степень уверенности;
    # - r['masks'] — маски объектов (что даёт вам их контур).

    if parked_car_boxes is None:
        # Это первый кадр видео — допустим, что все обнаруженные машины стоят на парковке.
        # Сохраняем местоположение каждой машины как парковочное место и переходим к следующему кадру.
        parked_car_boxes = get_car_boxes(r['rois'], r['class_ids'])
    else:
        # Мы уже знаем, где места. Проверяем, есть ли свободные.

        # Ищем машины на текущем кадре.
        car_boxes = get_car_boxes(r['rois'], r['class_ids'])

        # Смотрим, как сильно эти машины пересекаются с известными парковочными местами.
        overlaps = mrcnn.utils.compute_overlaps(parked_car_boxes, car_boxes)

        # Предполагаем, что свободных мест нет, пока не найдём хотя бы одно.
        free_space = False

        # Проходимся в цикле по каждому известному парковочному месту.
        for parking_area, overlap_areas in zip(parked_car_boxes, overlaps):

            # Ищем максимальное значение пересечения с любой обнаруженной
            # на кадре машиной (неважно, какой).
            max_IoU_overlap = np.max(overlap_areas)

            # Получаем верхнюю левую и нижнюю правую координаты парковочного места.
            y1, x1, y2, x2 = parking_area

            # Проверяем, свободно ли место, проверив значение IoU.
            if max_IoU_overlap &lt; 0.15:
                # Место свободно! Рисуем зелёную рамку вокруг него.
                cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 255, 0), 3)
                # Отмечаем, что мы нашли как минимум оно свободное место.
                free_space = True
            else:
                # Место всё ещё занято — рисуем красную рамку.
                cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 0, 255), 1)

            # Записываем значение IoU внутри рамки.
            font = cv2.FONT_HERSHEY_DUPLEX
            cv2.putText(frame, f"{max_IoU_overlap:0.2}", (x1 + 6, y2 - 6), font, 0.3, (255, 255, 255))

        # Если хотя бы одно место было свободным, начинаем считать кадры.
        # Это для того, чтобы убедиться, что место действительно свободно
        # и не отправить лишний раз уведомление.
        if free_space:
            free_space_frames += 1
        else:
            # Если всё занято, обнуляем счётчик.
            free_space_frames = 0

        # Если место свободно на протяжении нескольких кадров, можно сказать, что оно свободно.
        if free_space_frames > 10:
            # Отображаем надпись SPACE AVAILABLE!! вверху экрана.
            font = cv2.FONT_HERSHEY_DUPLEX
            cv2.putText(frame, f"SPACE AVAILABLE!", (10, 150), font, 3.0, (0, 255, 0), 2, cv2.FILLED)

            # Отправляем сообщение, если ещё не сделали это.
            if not sms_sent:
                print("SENDING SMS!!!")
                message = client.messages.create(
                    body="Parking space open - go go go!",
                    from_=twilio_phone_number,
                    to=destination_phone_number
                )
                sms_sent = True

        # Показываем кадр на экране.
        cv2.imshow('Video', frame)

    # Нажмите 'q', чтобы выйти.
    if cv2.waitKey(1) &amp; 0xFF == ord('q'):
        break

# Нажмите 'q', чтобы выйти.
video_capture.release()
cv2.destroyAllWindows()
</code></pre><br/>
Для запуска того кода сначала нужно установить Python 3.6+, <a href="https://github.com/matterport/Mask_RCNN">Matterport Mask R-CNN</a> и <a href="https://pypi.org/project/opencv-python/">OpenCV</a>.<br/>
<br/>
Я специально писал код как можно проще. Например, если он видит на первом кадре машины, то делает вывод, что все они припаркованы. Попробуйте поэкспериментировать с ним и посмотрите, получится ли у вас повысить его надёжность.<br/>
<br/>
Просто изменив идентификаторы объектов, которые ищет модель, вы можете превратить код в нечто совершенно иное. Например, представьте, что вы работаете на горнолыжном курорте. Внеся пару изменений, вы можете превратить этот скрипт в систему, которая автоматически распознаёт сноубордистов, спрыгивающих с рампы, и записывает ролики с классными прыжками. Или, если вы работаете в заповеднике, вы можете создать систему, которая считает зебр. Вы ограничены лишь своим воображением. <br/>
<br/>
Больше подобных статей можно читать в телеграм-канале <a href="http://t.me/neurondata">Нейрон</a> (@neurondata)<br/>
<br/>
Ссылка на альтернативный перевод: <a href="https://tproger.ru/translations/parking-searching/">tproger.ru/translations/parking-searching/</a><br/>
<br/>
Всем знаний. Экспериментируйте!</div></div> <!----> <div class="tm-article-poll"><div class="tm-notice tm-article-poll__notice tm-notice_positive"><!----> <div class="tm-notice__inner"><!----> <div class="tm-notice__content"><span>Только зарегистрированные пользователи могут участвовать в опросе. <a rel="nofollow" href="/kek/v1/auth/habrahabr/?back=/ru/post/451164/&hl=ru">Войдите</a>, пожалуйста.</span></div></div></div> <div class="tm-article-poll__header">А что бы вы хотели распознавать и отслеживать?</div> <div class="tm-article-poll__answers"><div class="tm-article-poll__answer"><div class="tm-article-poll__answer-data"><span class="tm-article-poll__answer-percent">
            22.91%
          </span> <span class="tm-article-poll__answer-label">Парковочное место</span> <span class="tm-article-poll__answer-votes">
            85
          </span></div> <div class="tm-article-poll__answer-bar"><div class="tm-article-poll__answer-progress" style="width:22.91%;"></div></div></div><div class="tm-article-poll__answer"><div class="tm-article-poll__answer-data"><span class="tm-article-poll__answer-percent">
            11.32%
          </span> <span class="tm-article-poll__answer-label">Место в маршрутке</span> <span class="tm-article-poll__answer-votes">
            42
          </span></div> <div class="tm-article-poll__answer-bar"><div class="tm-article-poll__answer-progress" style="width:11.32%;"></div></div></div><div class="tm-article-poll__answer"><div class="tm-article-poll__answer-data"><span class="tm-article-poll__answer-percent tm-article-poll__answer-percent_winning">
            65.77%
          </span> <span class="tm-article-poll__answer-label">Комаров</span> <span class="tm-article-poll__answer-votes">
            244
          </span></div> <div class="tm-article-poll__answer-bar"><div class="tm-article-poll__answer-progress tm-article-poll__answer-progress_winning" style="width:65.77%;"></div></div></div></div> <div class="tm-article-poll__stats">
       Проголосовал 371 пользователь. 

       Воздержались 58 пользователей. 
    </div></div></div> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bpython%5D" class="tm-tags-list__link">python</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%B8%D1%81%D0%BA%D1%83%D1%81%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9%20%D0%B8%D0%BD%D1%82%D0%B5%D0%BB%D0%BB%D0%B5%D0%BA%D1%82%5D" class="tm-tags-list__link">искусственный интеллект</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bdata%20mining%5D" class="tm-tags-list__link">data mining</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/hub/python/" class="tm-hubs-list__link">
    Python
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/data_mining/" class="tm-hubs-list__link">
    Data Mining
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/artificial_intelligence/" class="tm-hubs-list__link">
    Искусственный интеллект
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/futurenow/" class="tm-hubs-list__link">
    Будущее здесь
  </a></li></ul></div></div></article></div> <!----></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_medium"><title>Всего голосов 110: ↑107 и ↓3</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-rating"></use></svg> <span title="Всего голосов 110: ↑107 и ↓3" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_medium">+104</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">46K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    492
  </span></button> <!----> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> </div></div> <!----> <!----> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="/ru/users/Syurmakov/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><img alt="" src="//habrastorage.org/getpro/habr/avatars/82c/a16/317/82ca1631721b8d3bbc7b4a0d98d4c2aa.jpg" class="tm-entity-image__pic"></div></a> <div class="tm-user-card__meta"><div title=" 138 голосов " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    53.5
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">0</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title_variant-article"><span class="tm-user-card__name tm-user-card__name_variant-article">Rushan</span> <a href="/ru/users/Syurmakov/" class="tm-user-card__nickname tm-user-card__nickname_variant-article">
          @Syurmakov
        </a> <!----></div> <p class="tm-user-card__short-info tm-user-card__short-info_variant-article">Создатель Telegram-канала Нейрон — @neurondata</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-article"><!----> <!----> <button type="submit" class="tm-user-card__button btn btn_transparent btn_small">
      Задонатить
    </button> <!----> <!----></div></div> <div class="tm-article-author__user-contacts"><a href="https://telegram.me/neurondata" rel="noopener" target="_blank" class="tm-article-author__contact">
      Telegram
    </a></div></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----></section> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="/ru/post/451164/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментарии 53 
    </span></a> <!----></div></div></div> <div class="tm-ad-banner__container tm-page-article__banner"><!----> <div id="articleBottomBanner" class="tm-ad-banner"></div></div> <!----> <!----> <!----> <!----> </div></div></div></div></div> <div class="tm-page__sidebar"><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__ads tm-layout-sidebar__ads_initial"><div class="tm-ad-banner__container tm-layout-sidebar__banner"><!----> <div id="sidebarBanner" class="tm-ad-banner"></div></div></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----> <!----></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/post/451164/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/post/451164/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2021 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"451164":{"id":"451164","timePublished":"2019-05-10T11:29:37+00:00","isCorporative":false,"lang":"ru","titleHtml":"Ищем свободное парковочное место с Python","leadData":{"textHtml":"\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fvz\u002Fx5\u002Fod\u002Fvzx5odyqel0ow-z2qolfdo1htd4.gif\" alt=\"image\"\u003E\u003Cbr\u003E\r\n\u003Cbr\u003E\r\nЯ живу в хорошем городе. Но, как и во многих других, поиск парковочного места всегда превращается в испытание. Свободные места быстро занимают, и даже если у вас есть своё собственное, друзьям будет сложно к вам заехать, ведь им будет негде припарковаться.\u003Cbr\u003E\r\n\u003Cbr\u003E\r\nПоэтому я решил направить камеру в окно и использовать глубокое обучение, чтобы мой компьютер сообщал мне, когда освободится место:\u003Cbr\u003E\r\n\u003Cbr\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Flx\u002Fmd\u002Fgy\u002Flxmdgyxkvnwtwc5nsqccy83mp34.gif\" alt=\"image\"\u003E\u003Cbr\u003E\r\n\u003Cbr\u003E\r\nЭто может звучать сложно, но на самом деле написать рабочий прототип с глубоким обучением — быстро и легко. Все нужные составляющие уже есть — нужно всего лишь знать, где их найти и как собрать воедино.\u003Cbr\u003E\r\n\u003Cbr\u003E\r\nПоэтому давайте немного развлечёмся и напишем точную систему уведомлений о свободной парковке с помощью Python и глубокого обучения","imageUrl":null,"buttonTextHtml":"Читать дальше →","image":null},"editorVersion":"1.0","postType":"article","postLabels":[{"type":"translation","data":{"originalAuthorName":"Adam Geitgey","originalUrl":"https:\u002F\u002Fmedium.com\u002F@ageitgey\u002Fsnagging-parking-spaces-with-mask-r-cnn-and-python-955f2231c400"}}],"author":{"scoreStats":{"score":53.5,"votesCount":138},"rating":0,"relatedData":null,"contacts":[{"title":"Telegram","url":"https:\u002F\u002Ftelegram.me\u002Fneurondata","value":"neurondata"}],"authorContacts":[{"title":"Telegram","url":"https:\u002F\u002Ftelegram.me\u002Fneurondata","value":"neurondata"}],"paymentDetails":{"paymentYandexMoney":"410011081596384","paymentPayPalMe":null,"paymentWebmoney":null},"id":"883129","alias":"Syurmakov","fullname":"Rushan","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F82c\u002Fa16\u002F317\u002F82ca1631721b8d3bbc7b4a0d98d4c2aa.jpg","speciality":"Создатель Telegram-канала Нейрон — @neurondata"},"statistics":{"commentsCount":53,"favoritesCount":492,"readingCount":45840,"score":104,"votesCount":110},"hubs":[{"relatedData":null,"id":"340","alias":"python","type":"collective","title":"Python","titleHtml":"Python","isProfiled":true},{"relatedData":null,"id":"7152","alias":"data_mining","type":"collective","title":"Data Mining","titleHtml":"Data Mining","isProfiled":true},{"relatedData":null,"id":"21922","alias":"artificial_intelligence","type":"collective","title":"Искусственный интеллект","titleHtml":"Искусственный интеллект","isProfiled":false},{"relatedData":null,"id":"22014","alias":"futurenow","type":"collective","title":"Будущее здесь","titleHtml":"Будущее здесь","isProfiled":false}],"flows":[{"id":"1","alias":"develop","title":"Разработка"},{"id":"7","alias":"popsci","title":"Научпоп"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"image\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fvz\u002Fx5\u002Fod\u002Fvzx5odyqel0ow-z2qolfdo1htd4.gif\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЯ живу в хорошем городе. Но, как и во многих других, поиск парковочного места всегда превращается в испытание. Свободные места быстро занимают, и даже если у вас есть своё собственное, друзьям будет сложно к вам заехать, ведь им будет негде припарковаться.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПоэтому я решил направить камеру в окно и использовать глубокое обучение, чтобы мой компьютер сообщал мне, когда освободится место:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"image\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Flx\u002Fmd\u002Fgy\u002Flxmdgyxkvnwtwc5nsqccy83mp34.gif\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЭто может звучать сложно, но на самом деле написать рабочий прототип с глубоким обучением — быстро и легко. Все нужные составляющие уже есть — нужно всего лишь знать, где их найти и как собрать воедино.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПоэтому давайте немного развлечёмся и напишем точную систему уведомлений о свободной парковке с помощью Python и глубокого обучения\u003Ca name=\"habracut\"\u003E\u003C\u002Fa\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EДекомпозируем задачу\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nКогда у нас есть сложная задача, которую мы хотим решить с помощью машинного обучения, первым шагом нужно разбить её на последовательность простых задач. Затем мы можем использовать различные инструменты для решения каждой из них. Объединив несколько простых решений воедино, мы получим систему, которая способна на нечто сложное.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВот, как я разбил свою задачу:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780q1\u002Fwebt\u002Fq7\u002Fgi\u002Fhi\u002Fq7gihifth7-k9mad7fhgbj4itcc.jpeg\" alt=\"image\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fq7\u002Fgi\u002Fhi\u002Fq7gihifth7-k9mad7fhgbj4itcc.jpeg\" data-blurred=\"true\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНа вход конвейера поступает видеопоток с веб-камеры, направленной в окно:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"image\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Faa\u002Fwk\u002Fig\u002Faawkigsexhbk5s4slqmvksvofcm.gif\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЧерез конвейер мы будем передавать каждый кадр видео, по одному за раз.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПервым шагом нужно распознать все возможные парковочные места на кадре. Очевидно, что прежде чем мы сможем искать незанятые места, нам нужно понять, в каких частях изображения находится парковка.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЗатем на каждом кадре нужно найти все машины. Это позволит нам отслеживать движение каждой машины от кадра к кадру.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТретьим шагом нужно определить, какие места заняты машинами, а какие — нет. Для этого нужно совместить результаты первых двух шагов.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНаконец, программа должна прислать оповещение, когда освободится парковочное место. Это будет определяться за счёт изменений в расположении машин между кадрами видео.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКаждый из этих этапов можно пройти разными способами с помощью разных технологий. Нет единственного правильного или неправильного способа составить этот конвейер, у разных подходов будут свои преимущества и недостатки. Давайте разберёмся с каждым шагом подробнее.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EРаспознаём парковочные места\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nВот, что видит наша камера:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"image\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002F2u\u002Fzl\u002Fxt\u002F2uzlxtgxbn6jvfkhfy0e523ow88.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНам нужно как-то просканировать это изображение и получить список мест, где можно припарковаться:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"image\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fm-\u002Fbq\u002Fxb\u002Fm-bqxb9ybcjc44blvsuzhnw6xyk.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nРешением «в лоб» было бы просто захардкодить местоположения всех парковочных мест вручную вместо автоматического распознавания. Но в таком случае, если мы переместим камеру или захотим искать парковочные места на другой улице, нам придётся проделывать всю процедуру заново. Звучит так себе, поэтому поищем автоматический способ распознавания парковочных мест.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКак вариант, можно искать на изображении паркометры и предположить, что рядом с каждым из них есть парковочное место:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"image\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fqi\u002Fg8\u002Fcj\u002Fqig8cjwmp7dmduejcddjk6tnoiw.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nОднако с этим подходом не всё так гладко. Во-первых, не у каждого парковочного места есть паркометр, да и вообще, нам больше интересен поиск парковочных мест, за которые не надо платить. Во-вторых, местоположение паркометра ничего не говорит нам о том, где находится парковочное место, а всего лишь позволяет сделать предположение.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДругая идея заключается в создании модели распознавания объектов, которая ищет метки парковочного места, нарисованные на дороге:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"image\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fbo\u002Fvv\u002Fnu\u002Fbovvnu6rsl-zimlr1gtpp1a_egm.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНо и этот подход — так себе. Во-первых, в моём городе все такие метки очень маленькие и трудноразличимые на расстоянии, поэтому их будет сложно обнаружить с помощью компьютера. Во-вторых, на улице полно всяких других линий и меток. Будет сложно отделить парковочные метки от разделителей полос и пешеходных переходов.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКогда вы сталкиваетесь с проблемой, которая на первый взгляд кажется сложной, потратьте несколько минут на поиск другого подхода к решению задачи, который поможет обойти некоторые технические проблемы. Что вообще есть парковочное место? Это всего лишь место, на которое на долгое время паркуют машину. Возможно, нам вовсе и не нужно распознавать парковочные места. Почему бы нам просто не распознавать машины, которые долгое время стоят на месте, и не делать предположение, что они стоят на парковочном месте?\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДругими словами, парковочные места расположены там, где подолгу стоят машины:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"image\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fb8\u002Ftb\u002Fua\u002Fb8tbuafyf4uci3jy61jnjlwanqa.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТаким образом, если мы сможем распознать машины и выяснить, которые из них не двигаются между кадрами, мы сможем предположить, где находятся парковочные места. Проще простого — переходим к распознаванию машин!\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EРаспознаём машины\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nРаспознавание машин на кадре видео является классической задачей распознавания объектов. Существует множество подходов на основе машинного обучения, которые мы могли бы использовать для распознавания. Вот некоторые из них в порядке от «старой школы» к «новой школе»:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EМожно обучить детектор на основе HOG (Histogram of Oriented Gradients, гистограммы направленных градиентов) и пройтись им по всему изображению, чтобы найти все машины. Этот старый подход, не использующий глубокое обучение, работает относительно быстро, но не очень хорошо справляется с машинами, расположенными по-разному.\u003C\u002Fli\u003E\r\n\u003Cli\u003EМожно обучить детектор на основе CNN (Convolutional Neural Network, свёрточная нейронная сеть) и пройтись им по всему изображению, пока не найдём все машины. Этот подход работает точно, но не так эффективно, так как нам нужно просканировать изображение несколько раз с помощью CNN, чтобы найти все машины. И хотя так мы сможем найти машины, расположенные по-разному, нам потребуется гораздо больше обучающих данных, чем для HOG-детектора.\u003C\u002Fli\u003E\r\n\u003Cli\u003EМожно использовать новый подход с глубоким обучением вроде Mask R-CNN, Faster R-CNN или YOLO, который совмещает в себе точность CNN и набор технических хитростей, сильно повышающих скорость распознавания. Такие модели будут работать относительно быстро (на GPU), если у нас есть много данных для обучения модели.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nВ общем случае нам нужно самое простое решение, которое будет работать как надо и потребует наименьшее количество обучающих данных. Не обязательно, чтобы это был самый новый и быстрый алгоритм. Однако конкретно в нашем случае Mask R-CNN — разумный выбор, несмотря на то, что он довольно новый и быстрый.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nАрхитектура Mask R-CNN разработана таким образом, что она распознаёт объекты на всём изображении, эффективно тратя ресурсы, и при этом не использует подход скользящего окна. Другими словами, она работает довольно быстро. С современным GPU мы сможем распознавать объекты на видео в высоком разрешении на скорости в несколько кадров в секунду. Для нашего проекта этого должно быть достаточно.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКроме того, Mask R-CNN даёт много информации о каждом распознанном объекте. Большинство алгоритмов распознавания возвращают только ограничивающую рамку для каждого объекта. Однако Mask R-CNN не только даст нам местоположение каждого объекта, но и его контур (маску):\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"image\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fn2\u002Fb0\u002Fhp\u002Fn2b0hpwgwpkn6ahfhqetvbhq1rg.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДля обучения Mask R-CNN нам нужно много изображений объектов, которые мы хотим распознавать. Мы могли бы выйти на улицу, сфотографировать машины и обозначить их на фотографиях, что потребовало бы несколько дней работы. К счастью, машины — одни из тех объектов, которые люди часто хотят распознать, поэтому уже существуют несколько общедоступных датасетов с изображениями машин.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nОдин из них — популярный датасет \u003Ca href=\"http:\u002F\u002Fcocodataset.org\u002F\"\u003EСОСО\u003C\u002Fa\u003E(сокращение для Common Objects In Context), в котором есть изображения, аннотированные масками объектов. В этом датасете находится более 12 000 изображений с уже размеченными машинами. Вот пример изображения из датасета:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780q1\u002Fwebt\u002Fdv\u002Flz\u002F7l\u002Fdvlz7ltgwmudog9-b2f6i7tlmhe.jpeg\" alt=\"image\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fdv\u002Flz\u002F7l\u002Fdvlz7ltgwmudog9-b2f6i7tlmhe.jpeg\" data-blurred=\"true\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТакие данные отлично подходят для обучения модели на основе Mask R-CNN.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНо придержите коней, есть новости ещё лучше! Мы не первые, кому захотелось обучить свою модель с помощью датасета COCO — многие люди уже сделали это до нас и поделились своими результатами. Поэтому вместо обучения своей модели мы можем взять готовую, которая уже может распознавать машины. Для нашего проекта мы воспользуемся \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fmatterport\u002FMask_RCNN\"\u003Eopen-source моделью от Matterport.\u003C\u002Fa\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЕсли дать на вход этой модели изображение с камеры, вот что мы получим уже «из коробки»:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"image\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fvy\u002Fkq\u002F50\u002Fvykq50pcxhyt_vkmfzmxk_fgl5g.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nМодель распознала не только машины, но и такие объекты, как светофоры и люди. Забавно, что дерево она распознала как комнатное растение.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДля каждого распознанного объекта модель Mask R-CNN возвращает 4 вещи:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EТип обнаруженного объекта (целое число). Предобученная модель COCO умеет распознавать 80 разных часто встречающихся объектов вроде машин и грузовиков. С их полным списком можно ознакомиться \u003Ca href=\"https:\u002F\u002Fgist.github.com\u002Fageitgey\u002Fb143ee809bf08e4927dd59bace44db0d\"\u003Eздесь.\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003EСтепень уверенности в результатах распознавания. Чем выше число, тем сильнее модель уверена в правильности распознавания объекта.\u003C\u002Fli\u003E\r\n\u003Cli\u003EОграничивающая рамка для объекта в форме XY-координат пикселей на изображении.\u003C\u002Fli\u003E\r\n\u003Cli\u003E«Маска», которая показывает, какие пиксели внутри ограничивающей рамки являются частью объекта. С помощью данных маски можно найти контур объекта.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nНиже показан код на Python для обнаружения ограничивающей рамки для машин с помощью предобученной модели Mask R-CNN и OpenCV:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eimport numpy as np\nimport cv2\nimport mrcnn.config\nimport mrcnn.utils\nfrom mrcnn.model import MaskRCNN\nfrom pathlib import Path\n\n\n# Конфигурация, которую будет использовать библиотека Mask-RCNN.\nclass MaskRCNNConfig(mrcnn.config.Config):\n    NAME = \"coco_pretrained_model_config\"\n    IMAGES_PER_GPU = 1\n    GPU_COUNT = 1\n    NUM_CLASSES = 1 + 80  # в датасете COCO находится 80 классов + 1 фоновый класс.\n    DETECTION_MIN_CONFIDENCE = 0.6\n\n\n# Фильтруем список результатов распознавания, чтобы остались только автомобили.\ndef get_car_boxes(boxes, class_ids):\n    car_boxes = []\n\n    for i, box in enumerate(boxes):\n        # Если найденный объект не автомобиль, то пропускаем его.\n        if class_ids[i] in [3, 8, 6]:\n            car_boxes.append(box)\n\n    return np.array(car_boxes)\n\n\n# Корневая директория проекта.\nROOT_DIR = Path(\".\")\n\n# Директория для сохранения логов и обученной модели.\nMODEL_DIR = ROOT_DIR \u002F \"logs\"\n\n# Локальный путь к файлу с обученными весами.\nCOCO_MODEL_PATH = ROOT_DIR \u002F \"mask_rcnn_coco.h5\"\n\n# Загружаем датасет COCO при необходимости.\nif not COCO_MODEL_PATH.exists():\n    mrcnn.utils.download_trained_weights(COCO_MODEL_PATH)\n\n# Директория с изображениями для обработки.\nIMAGE_DIR = ROOT_DIR \u002F \"images\"\n\n# Видеофайл или камера для обработки — вставьте значение 0, если нужно использовать камеру, а не видеофайл.\nVIDEO_SOURCE = \"test_images\u002Fparking.mp4\"\n\n# Создаём модель Mask-RCNN в режиме вывода.\nmodel = MaskRCNN(mode=\"inference\", model_dir=MODEL_DIR, config=MaskRCNNConfig())\n\n# Загружаем предобученную модель.\nmodel.load_weights(COCO_MODEL_PATH, by_name=True)\n\n# Местоположение парковочных мест.\nparked_car_boxes = None\n\n# Загружаем видеофайл, для которого хотим запустить распознавание.\nvideo_capture = cv2.VideoCapture(VIDEO_SOURCE)\n\n# Проходимся в цикле по каждому кадру.\nwhile video_capture.isOpened():\n    success, frame = video_capture.read()\n    if not success:\n        break\n\n    # Конвертируем изображение из цветовой модели BGR (используется OpenCV) в RGB.\n    rgb_image = frame[:, :, ::-1]\n\n    # Подаём изображение модели Mask R-CNN для получения результата.\n    results = model.detect([rgb_image], verbose=0)\n\n    # Mask R-CNN предполагает, что мы распознаём объекты на множественных изображениях.\n    # Мы передали только одно изображение, поэтому извлекаем только первый результат.\n    r = results[0]\n\n    # Переменная r теперь содержит результаты распознавания:\n    # - r['rois'] — ограничивающая рамка для каждого распознанного объекта;\n    # - r['class_ids'] — идентификатор (тип) объекта;\n    # - r['scores'] — степень уверенности;\n    # - r['masks'] — маски объектов (что даёт вам их контур).\n\n    # Фильтруем результат для получения рамок автомобилей.\n    car_boxes = get_car_boxes(r['rois'], r['class_ids'])\n\n    print(\"Cars found in frame of video:\")\n\n    # Отображаем каждую рамку на кадре.\n    for box in car_boxes:\n        print(\"Car:\", box)\n\n        y1, x1, y2, x2 = box\n\n        # Рисуем рамку.\n        cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 255, 0), 1)\n\n    # Показываем кадр на экране.\n    cv2.imshow('Video', frame)\n\n    # Нажмите 'q', чтобы выйти.\n    if cv2.waitKey(1) &amp; 0xFF == ord('q'):\n        break\n\n# Очищаем всё после завершения.\nvideo_capture.release()\ncv2.destroyAllWindows()\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПосле запуска этого скрипта на экране появится изображение с рамкой вокруг каждой обнаруженной машины:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780q1\u002Fwebt\u002F_p\u002Fil\u002F0r\u002F_pil0reoz3gj7dtqboav_rgerl8.jpeg\" alt=\"image\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002F_p\u002Fil\u002F0r\u002F_pil0reoz3gj7dtqboav_rgerl8.jpeg\" data-blurred=\"true\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТакже в консоль будут выведены координаты каждой машины:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003ECars found in frame of video:\nCar: [492 871 551 961]\nCar: [450 819 509 913]\nCar: [411 774 470 856]\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nВот мы и научились распознавать машины на изображении.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EРаспознаём пустые парковочные места\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nМы знаем пиксельные координаты каждой машины. Просматривая несколько последовательных кадров, мы легко можем определить, какие из машин не двигались, и предположить, что там находятся парковочные места. Но как понять, что машина покинула парковку?\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПроблема в том, что рамки машин частично перекрывают друг друга:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780q1\u002Fwebt\u002F7t\u002Fvi\u002F4q\u002F7tvi4q1rgvkfkaljrsp8sjathr0.jpeg\" alt=\"image\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002F7t\u002Fvi\u002F4q\u002F7tvi4q1rgvkfkaljrsp8sjathr0.jpeg\" data-blurred=\"true\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПоэтому если представить, что каждая рамка представляет парковочное место, то может оказаться, что оно частично занято машиной, когда на самом деле оно пустое. Нам нужно найти способ измерить степень пересечения двух объектов, чтобы искать только «наиболее пустые» рамки.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nМы воспользуемся мерой под названием Intersection Over Union (отношение площади пересечения к сумме площадей) или IoU. IoU можно найти, посчитав количество пикселей, где пересекаются два объекта, и разделить на количество пикселей, занимаемых этими объектами:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" alt=\"image\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fzs\u002Fc0\u002Fsz\u002Fzsc0szsct8xjwkx5eo-6ieynfuc.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТак мы сможем понять, как сильно ограничивающая рамка машины пересекается с рамкой парковочного места. Это позволит легко определить, свободна ли парковка. Если значение IoU низкое, вроде 0.15, значит, машина занимает малую часть парковочного места. А если оно высокое, вроде 0.6, то это значит, что машина занимает большую часть места и там нельзя припарковаться.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПоскольку IoU используется довольно часто в компьютерном зрении, в соответствующих библиотеках с большой вероятностью есть реализация этой меры. В нашей библиотеке Mask R-CNN она реализована в виде функции mrcnn.utils.compute_overlaps().\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЕсли у нас есть список ограничивающих рамок для парковочных мест, то добавить проверку на наличие машин в этих рамках можно, добавив всего строку-другую кода:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003E    # Фильтруем результат для получения рамок автомобилей.\n    car_boxes = get_car_boxes(r['rois'], r['class_ids'])\n\n    # Смотрим, как сильно машины пересекаются с известными парковочными местами.\n    overlaps = mrcnn.utils.compute_overlaps(car_boxes, parking_areas)\n\n    print(overlaps)\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nРезультат должен выглядеть примерно так:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003E[\n [1.         0.07040032 0.         0.]\n [0.07040032 1.         0.07673165 0.]\n [0.         0.         0.02332112 0.]\n]\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nВ этом двумерном массиве каждая строка отражает одну рамку парковочного места. А каждый столбец говорит о том, насколько сильно каждое из мест пересекается с одной из обнаруженных машин. Результат 1.0 означает, что всё место полностью занято машиной, а низкое значение вроде 0.02 говорит о том, что машина немного влезла на место, но на нём ещё можно припарковаться.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЧтобы найти незанятые места, нужно всего лишь проверить каждую строку в этом массиве. Если все числа близки к нулю, то скорее всего место свободно!\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nОднако имейте в виду, что распознавание объектов не всегда работает идеально с видео в реальном времени. Хоть модель на основе Mask R-CNN довольно точна, время от времени она может пропустить машину-другую в одном кадре видео. Поэтому прежде чем утверждать, что место свободно, нужно убедиться, что оно остаётся таким ещё на протяжении 5–10 следующих кадров видео. Таким образом мы сможем избежать ситуаций, когда система ошибочно помечает место пустым из-за глюка на одном кадре видео. Как только мы убедимся, что место остаётся свободным в течение нескольких кадров, можно отсылать сообщение!\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EОтправляем SMS\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nПоследняя часть нашего конвейера — отправка SMS-уведомления при появлении свободного парковочного места.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nОтправить сообщение из Python очень легко, если использовать Twilio. Twilio — это популярный API, который позволяет отправлять SMS из практически любого языка программирования с помощью всего нескольких строк кода. Конечно, если вы предпочитаете другой сервис, то можете использовать и его. Я никак не связан с Twilio, просто это первое, что приходит на ум.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЧтобы использовать Twilio, зарегистрируйте \u003Ca href=\"https:\u002F\u002Fwww.twilio.com\u002Ftry-twilio\"\u003Eпробный аккаунт\u003C\u002Fa\u003E, создайте номер телефона Twilio и получите аутентификационные данные аккаунта. Затем установите клиентскую библиотеку:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003E$ pip3 install twilio\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПосле этого используйте следующий код для отправки сообщения:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Efrom twilio.rest import Client\n\n# Данные аккаунта Twilio.\ntwilio_account_sid = 'Ваш Twilio SID'\ntwilio_auth_token = 'Ваш токен аутентификации Twilio'\ntwilio_source_phone_number = 'Ваш номер телефона Twilio'\n\n# Создаём объект клиента Twilio.\nclient = Client(twilio_account_sid, twilio_auth_token)\n\n# Отправляем SMS.\nmessage = client.messages.create(\n    body=\"Тело сообщения\",\n    from_=twilio_source_phone_number,\n    to=\"Ваш номер, куда придёт сообщение\"\n)\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЧтобы добавить возможность отправки сообщений в наш скрипт, просто скопируйте туда этот код. Однако нужно сделать так, чтобы сообщение не отправлялось на каждом кадре, где видно свободное место. Поэтому у нас будет флаг, который в установленном состоянии не даст отправлять сообщения в течение какого-то времени или пока не освободится другое место.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EСкладываем всё воедино\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003Eimport numpy as np\nimport cv2\nimport mrcnn.config\nimport mrcnn.utils\nfrom mrcnn.model import MaskRCNN\nfrom pathlib import Path\nfrom twilio.rest import Client\n\n# Конфигурация, которую будет использовать библиотека Mask-RCNN.\nclass MaskRCNNConfig(mrcnn.config.Config):\n    NAME = \"coco_pretrained_model_config\"\n    IMAGES_PER_GPU = 1\n    GPU_COUNT = 1\n    NUM_CLASSES = 1 + 80  # в датасете COCO находится 80 классов + 1 фоновый класс.\n    DETECTION_MIN_CONFIDENCE = 0.6\n\n# Фильтруем список результатов распознавания, чтобы остались только автомобили.\ndef get_car_boxes(boxes, class_ids):\n    car_boxes = []\n\n    for i, box in enumerate(boxes):\n        # Если найденный объект не автомобиль, то пропускаем его.\n        if class_ids[i] in [3, 8, 6]:\n            car_boxes.append(box)\n\n    return np.array(car_boxes)\n\n# Конфигурация Twilio.\ntwilio_account_sid = 'Ваш Twilio SID'\ntwilio_auth_token = 'Ваш токен аутентификации Twilio'\ntwilio_phone_number = 'Ваш номер телефона Twilio'\ndestination_phone_number = 'Номер, куда придёт сообщение'\nclient = Client(twilio_account_sid, twilio_auth_token)\n\n# Корневая директория проекта.\nROOT_DIR = Path(\".\")\n\n# Директория для сохранения логов и обученной модели.\nMODEL_DIR = ROOT_DIR \u002F \"logs\"\n\n# Локальный путь к файлу с обученными весами.\nCOCO_MODEL_PATH = ROOT_DIR \u002F \"mask_rcnn_coco.h5\"\n\n# Загружаем датасет COCO при необходимости.\nif not COCO_MODEL_PATH.exists():\n    mrcnn.utils.download_trained_weights(COCO_MODEL_PATH)\n\n# Директория с изображениями для обработки.\nIMAGE_DIR = ROOT_DIR \u002F \"images\"\n\n# Видеофайл или камера для обработки — вставьте значение 0, если использовать камеру, а не видеофайл.\nVIDEO_SOURCE = \"test_images\u002Fparking.mp4\"\n\n# Создаём модель Mask-RCNN в режиме вывода.\nmodel = MaskRCNN(mode=\"inference\", model_dir=MODEL_DIR, config=MaskRCNNConfig())\n\n# Загружаем предобученную модель.\nmodel.load_weights(COCO_MODEL_PATH, by_name=True)\n\n# Местоположение парковочных мест.\nparked_car_boxes = None\n\n# Загружаем видеофайл, для которого хотим запустить распознавание.\nvideo_capture = cv2.VideoCapture(VIDEO_SOURCE)\n\n# Сколько кадров подряд с пустым местом мы уже видели.\nfree_space_frames = 0\n\n# Мы уже отправляли SMS?\nsms_sent = False\n\n# Проходимся в цикле по каждому кадру.\nwhile video_capture.isOpened():\n    success, frame = video_capture.read()\n    if not success:\n        break\n\n    # Конвертируем изображение из цветовой модели BGR в RGB.\n    rgb_image = frame[:, :, ::-1]\n\n    # Подаём изображение модели Mask R-CNN для получения результата.\n    results = model.detect([rgb_image], verbose=0)\n\n    # Mask R-CNN предполагает, что мы распознаём объекты на множественных изображениях.\n    # Мы передали только одно изображение, поэтому извлекаем только первый результат.\n    r = results[0]\n\n    # Переменная r теперь содержит результаты распознавания:\n    # - r['rois'] — ограничивающая рамка для каждого распознанного объекта;\n    # - r['class_ids'] — идентификатор (тип) объекта;\n    # - r['scores'] — степень уверенности;\n    # - r['masks'] — маски объектов (что даёт вам их контур).\n\n    if parked_car_boxes is None:\n        # Это первый кадр видео — допустим, что все обнаруженные машины стоят на парковке.\n        # Сохраняем местоположение каждой машины как парковочное место и переходим к следующему кадру.\n        parked_car_boxes = get_car_boxes(r['rois'], r['class_ids'])\n    else:\n        # Мы уже знаем, где места. Проверяем, есть ли свободные.\n\n        # Ищем машины на текущем кадре.\n        car_boxes = get_car_boxes(r['rois'], r['class_ids'])\n\n        # Смотрим, как сильно эти машины пересекаются с известными парковочными местами.\n        overlaps = mrcnn.utils.compute_overlaps(parked_car_boxes, car_boxes)\n\n        # Предполагаем, что свободных мест нет, пока не найдём хотя бы одно.\n        free_space = False\n\n        # Проходимся в цикле по каждому известному парковочному месту.\n        for parking_area, overlap_areas in zip(parked_car_boxes, overlaps):\n\n            # Ищем максимальное значение пересечения с любой обнаруженной\n            # на кадре машиной (неважно, какой).\n            max_IoU_overlap = np.max(overlap_areas)\n\n            # Получаем верхнюю левую и нижнюю правую координаты парковочного места.\n            y1, x1, y2, x2 = parking_area\n\n            # Проверяем, свободно ли место, проверив значение IoU.\n            if max_IoU_overlap &lt; 0.15:\n                # Место свободно! Рисуем зелёную рамку вокруг него.\n                cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 255, 0), 3)\n                # Отмечаем, что мы нашли как минимум оно свободное место.\n                free_space = True\n            else:\n                # Место всё ещё занято — рисуем красную рамку.\n                cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 0, 255), 1)\n\n            # Записываем значение IoU внутри рамки.\n            font = cv2.FONT_HERSHEY_DUPLEX\n            cv2.putText(frame, f\"{max_IoU_overlap:0.2}\", (x1 + 6, y2 - 6), font, 0.3, (255, 255, 255))\n\n        # Если хотя бы одно место было свободным, начинаем считать кадры.\n        # Это для того, чтобы убедиться, что место действительно свободно\n        # и не отправить лишний раз уведомление.\n        if free_space:\n            free_space_frames += 1\n        else:\n            # Если всё занято, обнуляем счётчик.\n            free_space_frames = 0\n\n        # Если место свободно на протяжении нескольких кадров, можно сказать, что оно свободно.\n        if free_space_frames \u003E 10:\n            # Отображаем надпись SPACE AVAILABLE!! вверху экрана.\n            font = cv2.FONT_HERSHEY_DUPLEX\n            cv2.putText(frame, f\"SPACE AVAILABLE!\", (10, 150), font, 3.0, (0, 255, 0), 2, cv2.FILLED)\n\n            # Отправляем сообщение, если ещё не сделали это.\n            if not sms_sent:\n                print(\"SENDING SMS!!!\")\n                message = client.messages.create(\n                    body=\"Parking space open - go go go!\",\n                    from_=twilio_phone_number,\n                    to=destination_phone_number\n                )\n                sms_sent = True\n\n        # Показываем кадр на экране.\n        cv2.imshow('Video', frame)\n\n    # Нажмите 'q', чтобы выйти.\n    if cv2.waitKey(1) &amp; 0xFF == ord('q'):\n        break\n\n# Нажмите 'q', чтобы выйти.\nvideo_capture.release()\ncv2.destroyAllWindows()\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nДля запуска того кода сначала нужно установить Python 3.6+, \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fmatterport\u002FMask_RCNN\"\u003EMatterport Mask R-CNN\u003C\u002Fa\u003E и \u003Ca href=\"https:\u002F\u002Fpypi.org\u002Fproject\u002Fopencv-python\u002F\"\u003EOpenCV\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЯ специально писал код как можно проще. Например, если он видит на первом кадре машины, то делает вывод, что все они припаркованы. Попробуйте поэкспериментировать с ним и посмотрите, получится ли у вас повысить его надёжность.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПросто изменив идентификаторы объектов, которые ищет модель, вы можете превратить код в нечто совершенно иное. Например, представьте, что вы работаете на горнолыжном курорте. Внеся пару изменений, вы можете превратить этот скрипт в систему, которая автоматически распознаёт сноубордистов, спрыгивающих с рампы, и записывает ролики с классными прыжками. Или, если вы работаете в заповеднике, вы можете создать систему, которая считает зебр. Вы ограничены лишь своим воображением. \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nБольше подобных статей можно читать в телеграм-канале \u003Ca href=\"http:\u002F\u002Ft.me\u002Fneurondata\"\u003EНейрон\u003C\u002Fa\u003E (@neurondata)\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСсылка на альтернативный перевод: \u003Ca href=\"https:\u002F\u002Ftproger.ru\u002Ftranslations\u002Fparking-searching\u002F\"\u003Etproger.ru\u002Ftranslations\u002Fparking-searching\u002F\u003C\u002Fa\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВсем знаний. Экспериментируйте!\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"python"},{"titleHtml":"искусственный интеллект"},{"titleHtml":"data mining"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F451164\u002F8b6c4428e38fba9df4fdce9941680c81\u002F","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F451164\u002F8b6c4428e38fba9df4fdce9941680c81\u002F?format=vk","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F451164\\\u002F\"},\"headline\":\"Ищем свободное парковочное место с Python\",\"datePublished\":\"2019-05-10T14:29:37+03:00\",\"dateModified\":\"2019-05-22T14:41:06+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"Rushan\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"Я живу в хорошем городе. Но, как и во многих других, поиск парковочного места всегда превращается в испытание. Свободные места быстро занимают, и даже если у в...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F451164\\\u002F#post-content-body\",\"about\":[\"h_python\",\"h_data_mining\",\"h_artificial_intelligence\",\"h_futurenow\",\"f_develop\",\"f_popsci\"],\"image\":[\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fvz\\\u002Fx5\\\u002Fod\\\u002Fvzx5odyqel0ow-z2qolfdo1htd4.gif\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Flx\\\u002Fmd\\\u002Fgy\\\u002Flxmdgyxkvnwtwc5nsqccy83mp34.gif\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fq7\\\u002Fgi\\\u002Fhi\\\u002Fq7gihifth7-k9mad7fhgbj4itcc.jpeg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Faa\\\u002Fwk\\\u002Fig\\\u002Faawkigsexhbk5s4slqmvksvofcm.gif\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002F2u\\\u002Fzl\\\u002Fxt\\\u002F2uzlxtgxbn6jvfkhfy0e523ow88.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fm-\\\u002Fbq\\\u002Fxb\\\u002Fm-bqxb9ybcjc44blvsuzhnw6xyk.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fqi\\\u002Fg8\\\u002Fcj\\\u002Fqig8cjwmp7dmduejcddjk6tnoiw.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fbo\\\u002Fvv\\\u002Fnu\\\u002Fbovvnu6rsl-zimlr1gtpp1a_egm.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fb8\\\u002Ftb\\\u002Fua\\\u002Fb8tbuafyf4uci3jy61jnjlwanqa.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fn2\\\u002Fb0\\\u002Fhp\\\u002Fn2b0hpwgwpkn6ahfhqetvbhq1rg.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fdv\\\u002Flz\\\u002F7l\\\u002Fdvlz7ltgwmudog9-b2f6i7tlmhe.jpeg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fvy\\\u002Fkq\\\u002F50\\\u002Fvykq50pcxhyt_vkmfzmxk_fgl5g.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002F_p\\\u002Fil\\\u002F0r\\\u002F_pil0reoz3gj7dtqboav_rgerl8.jpeg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002F7t\\\u002Fvi\\\u002F4q\\\u002F7tvi4q1rgvkfkaljrsp8sjathr0.jpeg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fzs\\\u002Fc0\\\u002Fsz\\\u002Fzsc0szsct8xjwkx5eo-6ieynfuc.png\"]}","metaDescription":"Я живу в хорошем городе. Но, как и во многих других, поиск парковочного места всегда превращается в испытание. Свободные места быстро занимают, и даже если у вас есть своё собственное, друзьям...","mainImageUrl":null,"amp":false},"polls":[{"id":"30264","timeElapsed":null,"answersType":"radio","votesCount":371,"passCount":58,"textHtml":"А что бы вы хотели распознавать и отслеживать?","relatedData":null,"variants":[{"id":"145058","textHtml":"Парковочное место","votesCount":85,"percent":22.91,"selected":false},{"id":"145060","textHtml":"Место в маршрутке","votesCount":42,"percent":11.32,"selected":false},{"id":"145062","textHtml":"Комаров","votesCount":244,"percent":65.77,"selected":false}]}],"commentsEnabled":true,"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":false}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[],"hubs":"python,data_mining,artificial_intelligence,futurenow"},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{}},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"dfp":{"slotsDict":{}},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.c0af73e7.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
</body>
</html>
