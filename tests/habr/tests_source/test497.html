<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <title>Swift: ARC и управление памятью / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.c0af73e7.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.85eb77f0b17c8235e7b64b9f81ea5ec2.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" src="/js/ads.js" onload="window['zhY4i4nJ9K'] = true" data-vmid="checkad"></script><script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/post\/451130\/"},"headline":"Swift: ARC и управление памятью","datePublished":"2019-05-14T11:12:23+03:00","dateModified":"2020-02-13T10:30:28+03:00","author":{"@type":"Person","name":"Юрий"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"Будучи современным языком высокого уровня, Swift в основном берёт на себя управление памятью в ваших приложениях, занимаясь выделением и освобождением памяти. Эт...","url":"https:\/\/habr.com\/ru\/post\/451130\/#post-content-body","about":["h_ios_dev","h_swift","h_osx_dev","f_develop"],"image":["https:\/\/habrastorage.org\/webt\/b5\/oo\/78\/b5oo78ealf173ey0ayz7rngnszk.png","https:\/\/habrastorage.org\/webt\/hd\/zp\/ff\/hdzpffk1eh3rug0fgmgnlghnb3q.png","https:\/\/habrastorage.org\/webt\/lo\/az\/mu\/loazmuamyoww2ttr7wnwcd8_n4w.png","https:\/\/habrastorage.org\/webt\/ti\/qd\/kc\/tiqdkcyfstrndd8xswpf8zfebfo.png","https:\/\/habrastorage.org\/webt\/ym\/ax\/_m\/ymax_mv9cvlpi8xqwnxmb14vr2g.png","https:\/\/habrastorage.org\/webt\/i9\/hf\/bc\/i9hfbcizzk2eg38s_hidjq3evju.png","https:\/\/habrastorage.org\/webt\/uu\/fg\/eq\/uufgeqkvqa31jwwlsnlikc-iob8.png","https:\/\/habrastorage.org\/webt\/en\/vx\/cu\/envxcuihbevfcfqv1cyg-kc3lo4.png","https:\/\/habrastorage.org\/webt\/z-\/lh\/ow\/z-lhowlkfyvy4ycusafxhygjisw.png","https:\/\/habrastorage.org\/webt\/7t\/rb\/ax\/7trbaxtrrhtadtm29-dvqwehzo4.png","https:\/\/habrastorage.org\/webt\/a8\/ce\/l1\/a8cel1rgbdkm_fel_d880f2swf4.png","https:\/\/habrastorage.org\/webt\/xu\/d9\/qf\/xud9qf3rcyaf5ot_08l8vauizto.png","https:\/\/habrastorage.org\/webt\/la\/na\/km\/lanakmzc0d2ousrcf5jwkpu-ova.png","https:\/\/habrastorage.org\/webt\/uc\/ko\/vj\/uckovjp_eqoplopih79xuz1jl7e.png","https:\/\/habrastorage.org\/webt\/7f\/wi\/os\/7fwios8n7zdk4ww7bj81p4kvgle.png"]}</script>
  <script src="//www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.49.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_eng"><meta data-vue-meta="ssr" property="og:title" content="Swift: ARC и управление памятью" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="Swift: ARC и управление памятью" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="Swift: ARC и управление памятью" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="Будучи современным языком высокого уровня, Swift в основном берёт на себя управление памятью в ваших приложениях, занимаясь выделением и освобождением памяти. Это происходит благодаря механизму,..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="Будучи современным языком высокого уровня, Swift в основном берёт на себя управление памятью в ваших приложениях, занимаясь выделением и освобождением памяти. Это происходит благодаря механизму,..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="Будучи современным языком высокого уровня, Swift в основном берёт на себя управление памятью в ваших приложениях, занимаясь выделением и освобождением памяти. Это происходит благодаря механизму,..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="Будучи современным языком высокого уровня, Swift в основном берёт на себя управление памятью в ваших приложениях, занимаясь выделением и освобождением памяти. Это происходит благодаря механизму,..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="Будучи современным языком высокого уровня, Swift в основном берёт на себя управление памятью в ваших приложениях, занимаясь выделением и освобождением памяти. Это происходит благодаря механизму,..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habr.com/share/publication/451130/8e062cd8cd1dcce249e9426332925d20/" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habr.com/share/publication/451130/8e062cd8cd1dcce249e9426332925d20/" data-vmid="og:image"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habr.com/share/publication/451130/8e062cd8cd1dcce249e9426332925d20/" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habr.com/share/publication/451130/8e062cd8cd1dcce249e9426332925d20/" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habr.com/share/publication/451130/8e062cd8cd1dcce249e9426332925d20/" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="451130" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2019-05-14T08:12:23.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/451130/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="https://habr.com/ru/post/451130/" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habr.com/share/publication/451130/8e062cd8cd1dcce249e9426332925d20/" data-vmid="image:href">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="/ru/sandbox/start/" class="tm-header__become-author-btn">
            Как стать автором
          </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="/ru/all/" class="tm-main-menu__item">
        Все потоки
      </a> <a href="/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" data-async-called="true" class="tm-page"><div class="tm-page-width"><!----> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="/ru/users/infund/" title="infund" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="" height="24" loading="lazy" src="//habrastorage.org/r/w32/getpro/habr/avatars/409/bcf/087/409bcf0876262edf747ff8abd8522a6f.png" width="24" class="tm-entity-image__pic"></div></a> <span class="tm-user-info__user"><a href="/ru/users/infund/" class="tm-user-info__username">
      infund
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2019-05-14T08:12:23.000Z" title="2019-05-14, 11:12">14  мая  2019 в 11:12</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>Swift: ARC и управление памятью</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/ios_dev/" class="tm-article-snippet__hubs-item-link"><span>Разработка под iOS</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/swift/" class="tm-article-snippet__hubs-item-link"><span>Swift</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/osx_dev/" class="tm-article-snippet__hubs-item-link"><span>Разработка под MacOS</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span></div> <div class="tm-article-snippet__labels"><div class="tm-article-snippet__label"><span>
        Перевод
      </span></div><div class="tm-article-snippet__label"><span>
        Tutorial
      </span></div></div> <!----> <!----></div></div> <div class="tm-article-presenter__origin"><a href="https://www.raywenderlich.com/966538-arc-and-memory-management-in-swift" target="_blank" class="tm-article-presenter__origin-link">
                Автор оригинала:
                <span>
                  Maxime Defauw, Mark Struzinski
                </span></a></div> <div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-1"><div xmlns="http://www.w3.org/1999/xhtml">Будучи современным языком высокого уровня, <b>Swift</b> в основном берёт на себя управление памятью в ваших приложениях, занимаясь выделением и освобождением памяти. Это происходит благодаря механизму, который называется <b>Automatic Reference Counting</b>, или сокращенно <b>ARC</b>. В этом руководстве вы разберётесь, как работает ARC и как правильно управлять памятью в Swift. Понимая этот механизм, вы сможете влиять на время жизни объектов, размещенных в куче (<b>heap</b>).<br/>
<br/>
В этом руководстве вы прокачаете свои знания Swift и ARC, изучив следующее:<br/>
<br/>
<ul>
<li>как работает ARC</li>
<li>что такое циклы ссылок (<b>reference cycles</b>) и как их правильно устранять</li>
<li>как создать пример цикла ссылок</li>
<li>как находить циклы ссылок при помощи визуальных средств, предлагаемых Xcode</li>
<li>как обращаться с ссылочными типами и типами-значениями</li>
</ul><a name="habracut"></a><br/>
<h2>Начинаем</h2><br/>
Загрузите <a href="https://koenig-media.raywenderlich.com/uploads/2019/03/ARC-and-Memory-Management.zip" rel="nofollow">исходные материалы.</a> Откройте проект в папке <b>Cycles/Starter</b>. В первой части нашего руководства, разбираясь в ключевых понятиях, мы будем заниматься исключительно файлом <b>MainViewController.swif</b>t.<br/>
<br/>
Добавьте этот класс внизу MainViewController.swift:<br/>
<br/>
<pre><code class="swift">class User {
  let name: String
  
  init(name: String) {
    self.name = name
    print("User \(name) was initialized")
  }

  deinit {
    print("Deallocating user named: \(name)")
  }
}</code></pre><br/>
Здесь определяется класс <b>User</b>, который при помощи операторов <b>print</b> сигнализирует нам об инициализации и освобождении экземпляра класса.<br/>
<br/>
Теперь создадим экземпляр класса User вверху MainViewController.<br/>
<br/>
Разместите этот код перед методом <b>viewDidLoad()</b>:<br/>
<br/>
<pre><code class="swift">let user = User(name: "John")</code></pre><br/>
Запустите приложение. Сделайте консоль Xcode видимой при помощи <b>Command-Shift-Y</b>, чтобы видеть вывод операторов print.<br/>
<br/>
Обратите внимание на то, что на консоли появилась надпись <b>User John was initialized</b>, но оператор print внутри <b>deinit</b> не был исполнен. Значит, этот объект не был освобождён, так как он не вышел из области видимости (<b>scope</b>).<br/>
<br/>
Другими словами, пока view controller, содержащий этот объект, не выйдет из области видимости, объект никогда не будет освобождён.<br/>
<br/>
<h2>Он в области видимости?</h2><br/>
Завернув экземпляр класса User в метод, мы разрешим выйти ему из области видимости, тем самым позволив ARC освободить его.<br/>
<br/>
Создадим метод <b>runScenario()</b> внутри класса MainViewController и переместим инициализацию экземпляра класса User внутри него.<br/>
<br/>
<pre><code class="swift">func runScenario() {
  let user = User(name: "John")
}    
</code></pre><br/>
runScenario() определяет области видимости экземпляра User. На выходе из этой зоны <b>user</b> должен быть высвобожден.<br/>
<br/>
Теперь вызовем runScenario() добавив это в конце viewDidLoad():<br/>
<br/>
<pre><code class="swift">runScenario()</code></pre><br/>
Запустите приложение. Вывод в консоли теперь выглядит так:<br/>
<br/>
User John was initialized<br/>
Deallocating user named: John<br/>
<br/>
Это означает, что вы высвободили объект, покинувший области видимости.<br/>
<br/>
<h2>Время жизни объекта</h2><br/>
<br/>
Существование объекта делится на пять этапов:<br/>
<br/>
<ul>
<li>выделение памяти: из стека или из кучи</li>
<li>инициализация: выполняется код внутри init</li>
<li>использование</li>
<li>деинициализация: выполняется код внутри deinit</li>
<li>высвобождение памяти: выделенная память возвращается в стек или кучу</li>
</ul><br/>
Не существует прямого способа чтобы отследить этапы выделения и освобождения памяти, но можно использовать код внутри init и deinit. <br/>
<br/>
Счётчик ссылок (<b>reference counts</b>), также известный как 'количество использований' (<b>usage counts</b>), определяет, когда объект больше не нужен. Этот счётчик показывает число тех, кто «пользуется» этим объектом. Объект становится ненужным, когда счётчик использований равен нулю. Затем объект деинициализируется и высвобождается.<br/>
<br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/b5/oo/78/b5oo78ealf173ey0ayz7rngnszk.png"/><br/>
<br/>
При инициализации объекта User его счетчик ссылок равен 1, так как константа <b>user</b> ссылается на этот объект.<br/>
<br/>
В конце runScenario(), user выходит из области видимости и счётчик ссылок уменьшается до 0. В результате user деинициализируется и затем высвобождается.<br/>
<br/>
<h2>Циклы ссылок (Reference Cycles)</h2><br/>
В большинстве случаев ARC работает так, как надо. Разработчику обычно не нужно беспокоиться об утечках памяти, когда неиспользуемые объекты остаются неосвобожденными на неопределённое время.<br/>
<br/>
Но не всегда! Возможны утечки памяти.<br/>
<br/>
Как это может произойти? Представим ситуацию, когда два объекта больше не используются, но каждый из них ссылается на другой. Так как у каждого счетчик ссылок не равен 0, ни один из них не будет освобождён.<br/>
<br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/hd/zp/ff/hdzpffk1eh3rug0fgmgnlghnb3q.png"/><br/>
<br/>
Это цикл сильных ссылок (<b>strong reference cycle</b>). Такая ситуация сбивает с толку ARC и не позволяет ему очистить память.<br/>
<br/>
Как видите, счетчик ссылок в конце не равен 0 и, хотя никакие объекты уже не нужны, object1 и object2 не будут освобождены.<br/>
<br/>
<h2>Проверим наши ссылки</h2><br/>
Чтобы проверить все это в деле, добавьте этот код после класса User в MainViewController.swift:<br/>
<br/>
<pre><code class="swift">class Phone {
  let model: String
  var owner: User?
  
  init(model: String) {
    self.model = model
    print("Phone \(model) was initialized")
  }

  deinit {
    print("Deallocating phone named: \(model)")
  }
}    </code></pre> <br/>
Этот код добавляет новый класс <b>Phone</b> с двумя свойствами, одно для модели и другое для владельца, а также методы init и deinit. Свойство владельца опциональное, так как у телефона может и не быть владельца.<br/>
<br/>
Теперь добавьте эту строчку в runScenario():<br/>
<br/>
<pre><code class="swift">let iPhone = Phone(model: "iPhone Xs")
</code></pre><br/>
Это создаст экземпляр класса Phone.<br/>
<br/>
<h2>Удерживаем мобилу</h2><br/>
Теперь добавьте этот код в класс User, сразу после свойства name:<br/>
<br/>
<pre><code class="swift">private(set) var phones: [Phone] = []

func add(phone: Phone) {
  phones.append(phone)
  phone.owner = self
}
</code></pre><br/>
Добавляем массив телефонов, которыми владеет user. Сеттер помечен как private, так что нужно использовать add(phone:).<br/>
<br/>
Запустите приложение. Как видите, экземпляры классов Phone и User objects высвобождаются, как надо<br/>
<br/>
User John was initialized<br/>
Phone iPhone XS was initialized<br/>
Deallocating phone named: iPhone Xs<br/>
Deallocating user named: John<br/>
<br/>
Теперь добавим это в конце runScenario():<br/>
<pre><code class="swift">user.add(phone: iPhone)</code></pre><br/>
<br/>
Здесь мы добавляем наш айфончик в список телефонов, которыми владеет <b>user</b>, а также устанавливаем свойство телефона <b>owner</b> в '<b>user</b>'.<br/>
<br/>
Еще раз запустите приложение. Вы увидите, что объекты user и iPhone не высвобождаются. Цикл сильных ссылок между ними не позволяет ARC высвободить их.<br/>
<br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/lo/az/mu/loazmuamyoww2ttr7wnwcd8_n4w.png"/><br/>
<br/>
<h2>Ссылки Weak </h2><br/>
Чтобы разорвать цикл сильных ссылок, вы можете обозначить отношение между объектами как слабое (<b>weak</b>).<br/>
<br/>
По умолчанию все ссылки являются сильными и присваивание приводит к увеличению счётчика ссылок. При использовании слабых ссылок (weak references) счётчик ссылок не увеличивается.<br/>
<br/>
Другими словами, <b>слабые ссылки не влияют на управление жизнью объекта</b>. Слабые ссылки всегда объявлены как <b>optional</b>. Таким образом, когда счётчик ссылок станет равным 0, ссылка может быть установлена в nil.<br/>
<br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/ti/qd/kc/tiqdkcyfstrndd8xswpf8zfebfo.png"/><br/>
<br/>
На этой иллюстрации штриховые линии обозначают слабые ссылки. Обратите внимание, что счётчик ссылок object1 равен 1, так как на него ссылается variable1. Счётчик ссылок object2 равен 2, так как на него ссылается variable2 и object1.<br/>
<br/>
object2 также ссылается на object1, но <b>СЛАБО</b>, что означает, что это не влияет на счетчик ссылок на object1.<br/>
<br/>
Когда variable1 и variable2 освобождаются, у object1 счётчик ссылок становится равным 0, что высвобождает его. Это, в свою очередь, освобождает сильную ссылку на object2, что приводит уже к его высвобождению.<br/>
<br/>
В классе Phone измените объявление свойства owner следующим образом:<br/>
<br/>
<pre><code class="swift">weak var owner: User?</code></pre><br/>
Объявлением ссылки на свойство owner как 'weak' мы разрываем цикл сильных ссылок между классами User и Phone.<br/>
<br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/ym/ax/_m/ymax_mv9cvlpi8xqwnxmb14vr2g.png"/><br/>
<br/>
Запустите приложение. Теперь user и phone корректно высвобождаются.<br/>
<br/>
<h2>Ссылки Unowned</h2><br/>
Существует также другой модификатор ссылки, который не приводит к увеличению счётчика ссылок: <b>unowned</b>.<br/>
<br/>
В чём же отличие <b>unowned</b> от <b>weak</b>? Ссылка weak всегда optional и автоматически становится nil, когда ссылаемый объект высвобождается.<br/>
<br/>
Вот почему мы должны объявлять weak свойства как переменную optional типа: это свойство должно измениться. <br/>
<br/>
Ссылки Unowned, напротив, никогда не optional. Если вы попробуете получить доступ к unowned свойству, которое ссылается на освобождённый объект, вы получите ошибку, похожую на принудительное разворачивание содержащую nil переменной (force unwrapping).<br/>
<br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/i9/hf/bc/i9hfbcizzk2eg38s_hidjq3evju.png"/><br/>
<br/>
Давайте попробуем применить <b>unowned</b>.<br/>
<br/>
Добавим новый класс <b>CarrierSubscription</b> в конце MainViewController.swift:<br/>
<br/>
<pre><code class="swift">class CarrierSubscription {
  let name: String
  let countryCode: String
  let number: String
  let user: User
              
  init(name: String, countryCode: String, number: String, user: User) {
    self.name = name
    self.countryCode = countryCode
    self.number = number
    self.user = user
    
    print("CarrierSubscription \(name) is initialized")
  }

  deinit {
    print("Deallocating CarrierSubscription named: \(name)")
  }
}        </code></pre><br/>
У CarrierSubscription четыре свойства:<br/>
<br/>
Name: название провайдера.<br/>
CountryCode: код страны.<br/>
Number: телефонный номер.<br/>
User: ссылка на пользователя.<br/>
<br/>
<h2>Кто ваш провайдер?</h2><br/>
Теперь добавьте это в класс User после свойства name:<br/>
<br/>
<pre><code class="swift">var subscriptions: [CarrierSubscription] = []</code></pre><br/>
Здесь мы держим массив провайдеров пользователя.<br/>
<br/>
Теперь добавьте это в класс Phone class, после свойства owner:<br/>
<br/>
<pre><code class="swift">var carrierSubscription: CarrierSubscription?

func provision(carrierSubscription: CarrierSubscription) {
  self.carrierSubscription = carrierSubscription
}

func decommission() {
  carrierSubscription = nil
}</code></pre><br/>
Это добавляет опциональное свойство CarrierSubscription и два метода для регистрации и разрегистрации телефона у провайдера.<br/>
<br/>
Теперь добвьте внутри метода init у класса CarrierSubscription, прямо перед оператором print:<br/>
<br/>
<pre><code class="swift">user.subscriptions.append(self)</code></pre><br/>
Мы добавляем CarrierSubscription в массив провайдеров пользователя.<br/>
<br/>
И, наконец, добавьте это в конце метода runScenario():<br/>
<br/>
<pre><code class="swift">let subscription = CarrierSubscription(
  name: "TelBel", 
  countryCode: "0032",
  number: "31415926", 
  user: user)
iPhone.provision(carrierSubscription: subscription)</code></pre><br/>
Мы создаем подписку на провайдера для пользователя и подключаем к ней телефон.<br/>
<br/>
Запустите приложение. В консоли вы увидите:<br/>
<br/>
User John was initialized<br/>
Phone iPhone Xs was initialized<br/>
CarrierSubscription TelBel is initialized<br/>
<br/>
И опять цикл ссылок! user, iPhone и subscription не высвободились в конце.<br/>
<br/>
Сможете найти проблему?<br/>
<br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/uu/fg/eq/uufgeqkvqa31jwwlsnlikc-iob8.png"/><br/>
<br/>
<h2>Разрываем цепь</h2><br/>
Или ссылка из user на subscription или ссылка из subscription на user должна быть unowned, чтобы разорвать цикл. Вопрос в том, какой вариант выбрать. Давайте разберемся в структурах.<br/>
<br/>
Пользователь владеет подпиской на провайдера, но наоборот — нет, подписка на провайдера не владеет пользователем. <br/>
<br/>
Более того, нет никакого смысла в существовании CarrierSubscription без привязки к владеющему ей пользователю. <br/>
<br/>
Таким образом, ссылка на пользователя должна быть unowned.<br/>
<br/>
Измените объявление user в CarrierSubscription:<br/>
<br/>
<pre><code class="swift">unowned let user: User
</code></pre><br/>
Теперь user unowned, что разрывает цикл ссылок и позволит высвободить все объекты.<br/>
<br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/en/vx/cu/envxcuihbevfcfqv1cyg-kc3lo4.png"/><br/>
<br/>
<h2>Циклы ссылок в замыканиях</h2><br/>
Циклы ссылок применительно к объектам возникают, когда у объектов есть свойства, ссылающиеся друг на друга. Как и объекты, замыкания — это ссылочный тип, и могут приводить к циклам ссылок. Замыкания «захватывают» (capture) объекты, которые используют.<br/>
<br/>
Например, если вы присвоите замыкание свойству класса, и это замыкание использует свойства того же класса, то у нас появляется цикл ссылок. Другими словами, объект держит ссылку на замыкание через свойство. Замыкание содержит ссылку на объект через захваченное значение self.<br/>
<br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/z-/lh/ow/z-lhowlkfyvy4ycusafxhygjisw.png"/><br/>
<br/>
Добавьте этот код к CarrierSubscription сразу после свойства user:<br/>
<br/>
<pre><code class="swift">lazy var completePhoneNumber: () -> String = {
  self.countryCode + " " + self.number
}
</code></pre><br/>
Это замыкание вычисляет и возвращает полный телефонный номер. Свойство объявлено как <b>lazy</b>, оно будет присвоено при первом использовании.<br/>
<br/>
Это необходимо так как оно использует self.countryCode и self.number, которые будут недоступны до выполнения кода инициалайзера.<br/>
<br/>
Добавьте в конец runScenario():<br/>
<br/>
<pre><code class="swift">print(subscription.completePhoneNumber())</code></pre><br/>
Вызов completePhoneNumber() приведет к исполнению замыкания.<br/>
<br/>
Запустите приложение и вы увидите, что user и iPhone высвобождаются, а CarrierSubscription — нет, по причине цикла сильных ссылок между объектом и замыканием.<br/>
<br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/7t/rb/ax/7trbaxtrrhtadtm29-dvqwehzo4.png"/><br/>
<br/>
<h2>Списки захвата (Capture Lists)</h2><br/>
В Swift предусмотрен простой и элегантный способ разорвать цикл сильных ссылок в замыканиях. Вы объявляете список захвата, в котором определяете отношения между замыканием и объектами, которое оно захватывает.<br/>
<br/>
Для демонстрации списка захвата рассмотрим следующий код:<br/>
<br/>
<pre><code class="swift">var x = 5
var y = 5

let someClosure = { [x] in
  print("\(x), \(y)")
}
x = 6
y = 6

someClosure()        // Prints 5, 6
print("\(x), \(y)")  // Prints 6, 6</code></pre><br/>
x есть в списке захвата замыкания, таким образом значение x копируется в месте определения замыкания. Оно захвачено по значению.<br/>
<br/>
y нет в списке захвата, оно захвачено по ссылке. Это означает, что значение y будет таким, какое оно в момент вызова замыкания.<br/>
<br/>
Списки замыкания помогают определить отношения weak или unowned взаимодействие по отношению к захвачиваемым внутри замыкания объектам. В нашем случае подходящий выбор — unowned, так как замыкание не может существовать, если экземпляр CarrierSubscription высвободится.<br/>
<br/>
<h2>Захватите себя</h2><br/>
Замените определение completePhoneNumber в CarrierSubscription::<br/>
<br/>
<pre><code class="swift">lazy var completePhoneNumber: () -> String = { [unowned self] in
  return self.countryCode + " " + self.number
}</code></pre><br/>
Мы добавляем <b>[unowned self]</b> в список захвата замыкания. Это означает, что мы захватили <b>self</b> как <b>unowned</b> ссылку вместо сильной.<br/>
<br/>
Запустите приложение и вы увидите, что теперь CarrierSubscription высвобождается.<br/>
<br/>
На самом деле приведённый выше синтаксис — это короткая форма более длинного и полного, в котором появляется новая переменная:<br/>
<br/>
<pre><code class="swift">var closure = { [unowned newID = self] in
  // Use unowned newID here...
}</code></pre><br/>
Тут newID — это unowned копия self. Вне замыкания self остается самим собой. В короткой форме, приведенной ранее, мы <b>создаём новую переменную self</b>, которая затеняет существующий self внутри замыкания.<br/>
<br/>
<h2>Используйте Unowned осторожно</h2><br/>
В вашем коде отношения между self и completePhoneNumber обозначены как unowned.<br/>
<br/>
Если вы уверены, что объект, используемый в замыкании, не высвободится, можете использовать unowned. Если он всё-таки высвободится, вы в беде!<br/>
<br/>
Добавьте этот код в конце MainViewController.swift:<br/>
<br/>
<pre><code class="swift">class WWDCGreeting {
  let who: String
  
  init(who: String) {
    self.who = who
  }

  lazy var greetingMaker: () -> String = { [unowned self] in
    return "Hello \(self.who)."
  }
}
</code></pre><br/>
Теперь вот это в конце runScenario():<br/>
<br/>
<pre><code class="swift">let greetingMaker: () -> String

do {
  let mermaid = WWDCGreeting(who: "caffeinated mermaid")
  greetingMaker = mermaid.greetingMaker
}

print(greetingMaker()) // ЛОВУШКА!        </code></pre><br/>
Запустите приложение и вы увидите аварийное завершение и что-такое в консоли:<br/>
<br/>
User John was initialized<br/>
Phone iPhone XS was initialized<br/>
CarrierSubscription TelBel is initialized<br/>
0032 31415926<br/>
Fatal error: Attempted to read an unowned reference but object 0x600000f0de30 was already deallocated2019-02-24 12:29:40.744248-0600 Cycles[33489:5926466] Fatal error: Attempted to read an unowned reference but object 0x600000f0de30 was already deallocated<br/>
<br/>
Исключение возникло по причине того, что замыкание ждёт, что self.who существует, но он был высвобожден, как только mermaid вышла из области действия в конце блока do.<br/>
<br/>
Это пример может выглядеть высосанным из пальца, но такие вещи случаются. Например, когда мы используем замыкания, чтобы запустить что-то значительно позже, скажем, после того, как закончился асинхронный вызов в сети.<br/>
<br/>
<h2>Разминируем ловушку</h2><br/>
Замените greetingMaker в классе WWDCGreeting таким образом:<br/>
<br/>
<pre><code class="swift">lazy var greetingMaker: () -> String = { [weak self] in
  return "Hello \(self?.who)."
}</code></pre><br/>
Мы сделали две вещи: во-первых, мы заменили unowned на weak. Во-вторых, так как self стал weak, мы получаем доступ к свойству who через self?.who. Игнорируйте предупреждение Xcode, мы его скоро исправим.<br/>
<br/>
Приложение больше не крашится, но, если его запустить, мы получим забавный результат: “Hello nil.”<br/>
<br/>
Возможно, полученный результат вполне приемлем, но часто нам нужно сделать что-то, если объект был освобождён. Это можно сделать при помощи оператора guard.<br/>
<br/>
Замените текст замыкания этим:<br/>
<br/>
<pre><code class="swift">lazy var greetingMaker: () -> String = { [weak self] in
  guard let self = self else {
    return "No greeting available."
  }
  return "Hello \(self.who)."
}
</code></pre><br/>
Оператор guard присваивает self, взятое из weak self. Если self — nil, замыкание возвращает “No greeting available.” В противном случае, self становится сильной ссылкой, так что объект гарантированно доживёт до конца выполнения замыкания.<br/>
<br/>
<h2>Ищем циклы ссылок в Xcode 10</h2><br/>
Теперь, когда вы понимаете принципы работы ARC, что такое циклы ссылок и как их разрывать, пришло время посмотреть пример реального приложения.<br/>
<br/>
Откройте проект Starter, находящийся в папке Contacts.<br/>
<br/>
Запустите приложение.<br/>
<br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/a8/ce/l1/a8cel1rgbdkm_fel_d880f2swf4.png"/><br/>
<br/>
Это простейший менеджер контактов. Попробуйте кликнуть на контакте, добавьте пару новых.<br/>
<br/>
Назначение файлов:<br/>
<br/>
ContactsTableViewController: показывает все контакты.<br/>
DetailViewController: показывает подробную информацию выбранного контакта.<br/>
NewContactViewController: позволяет добавить новый контакт.<br/>
ContactTableViewCell: ячейка таблицы, показывающая детали контакта.<br/>
Contact: модель контакта.<br/>
Number: модель номера телефона.<br/>
<br/>
Однако, с этим проектом всё плохо: тут затаился цикл ссылок. Пользователи сначала не заметят проблем по причине небольшого размера утекающей памяти, по этой же причине сложно найти место утечки.<br/>
<br/>
К счастью, в Xcode 10 есть встроенные средства, чтобы найти мельчайшую утечку памяти.<br/>
<br/>
Запустите снова приложение. Удалите 3-4 контакта при помощи свайпа влево и кнопки delete. Похоже, что они исчезают совсем, да?<br/>
<br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/xu/d9/qf/xud9qf3rcyaf5ot_08l8vauizto.png"/><br/>
<br/>
<h2>Где же течёт?</h2><br/>
При запущенном приложении кликните на кнопке Debug Memory Graph:<br/>
<br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/la/na/km/lanakmzc0d2ousrcf5jwkpu-ova.png"/><br/>
<br/>
Понаблюдайте за Runtime Issues в Debug navigator. Они отмечены пурпурными квадратами с белым восклицательным знаком внутри:<br/>
<br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/uc/ko/vj/uckovjp_eqoplopih79xuz1jl7e.png"/><br/>
<br/>
Выберите в навигаторе один из проблемных Contact объектов. Цикл чётко виден: объекты Contact и Number ссылаясь друг на друга, удерживают.<br/>
<br/>
<img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/7f/wi/os/7fwios8n7zdk4ww7bj81p4kvgle.png"/><br/>
<br/>
Похоже, вам пора заглянуть в код. Учитывайте, что контакт может существовать без номера, но не наоборот.<br/>
<br/>
Как бы вы разрешили этот цикл? Ссылка из Contact на Number или из Number на Contact? weak или unowned? Попробуйте сначала сами! <br/>
<br/>
<div class="spoiler"><b class="spoiler_title">Если потребовалась помощь...</b><div class="spoiler_text">Есть 2 возможных решения: или сделать ссылку из Contact на Number weak, или из Number на Contact unowned.<br/>
<br/>
Документация Apple рекомендует, чтобы родительский объект владел сильной ссылкой на «детский» — не наоборот. Это означает, что мы даем Contact сильную ссылку на Number, а Number — unowned ссылку на Contact:<br/>
<br/>
<pre><code class="swift">class Number {
  unowned var contact: Contact
  // Other code...
}

class Contact {
  var number: Number?
  // Other code...
}</code></pre><br/>
</div></div><br/>
<h2>Бонус: циклы с ссылочными типами и типами-значениями.</h2><br/>
В Swift есть ссылочные типы (классы и замыкания) и типы-значения (структуры, перечисления). Тип-значение копируется при его передаче, а ссылочные типы делят одно значение при помощи ссылки.<br/>
<br/>
Это значит, что в случае типов-значений циклов не может быть. Для возникновения цикла нам нужно как минимум 2 ссылочных типа.<br/>
<br/>
Вернёмся к проекту Cycles project и добавим этот код в конце MainViewController.swift:<br/>
<br/>
<pre><code class="swift">struct Node { // Error
  var payload = 0
  var next: Node?
}
</code></pre><br/>
Не выйдет! Структура — тип значение и не может иметь рекурсию на экземпляр самой себя. В противном случае, у такой структуры был бы бесконечный размер.<br/>
<br/>
Изменим структуру на класс.<br/>
<br/>
<pre><code class="swift">class Node {
  var payload = 0
  var next: Node?
}</code></pre><br/>
Ссылка на себя вполне допустима для классов (ссылочный тип), так что проблем у компилятора не возникает.<br/>
<br/>
Теперь добавим это в конце MainViewController.swift:<br/>
<br/>
<pre><code class="swift">class Person {
  var name: String
  var friends: [Person] = []
  init(name: String) {
    self.name = name
    print("New person instance: \(name)")
  }

  deinit {
    print("Person instance \(name) is being deallocated")
  }
}</code></pre><br/>
А это — в конце runScenario():<br/>
<br/>
<pre><code class="swift">do {
  let ernie = Person(name: "Ernie")
  let bert = Person(name: "Bert")
  
  ernie.friends.append(bert) // Not deallocated
  bert.friends.append(ernie) // Not deallocated
}
</code></pre><br/>
Запустите приложение. Обратите внимание: ни ernie, ни bert не высвобождены.<br/>
<br/>
<h2>Ссылка и значение</h2><br/>
Это пример сочетания ссылочного типа и типа-значения, которое привело к циклу ссылок.<br/>
<br/>
ernie и bert остаются невысвобожденными, держа друг друга в своих массивах друзей, хотя массивы сами по себе — типы-значения.<br/>
<br/>
Попробуйте сделать архив friends как unowned, и Xcode покажет ошибку: unowned применим только к классам.<br/>
<br/>
Чтобы пофиксить этот цикл, нам придётся создать объект-обёртку и использовать его для добавления экземпляров в массив.<br/>
<br/>
Добавьте следующее определение перед классом Person:<br/>
<br/>
<pre><code class="swift">class Unowned&lt;T: AnyObject> {
  unowned var value: T
  init (_ value: T) {
    self.value = value
  }
}
</code></pre><br/>
Затем измените определение friends в классе Person:<br/>
<br/>
<pre><code class="swift">var friends: [Unowned&lt;Person>] = []</code></pre><br/>
Наконец, замените содержимое блока do в runScenario():<br/>
<br/>
<pre><code class="swift">do {
  let ernie = Person(name: "Ernie")
  let bert = Person(name: "Bert")
  
  ernie.friends.append(Unowned(bert))
  bert.friends.append(Unowned(ernie))
}</code></pre><br/>
Запустите приложение, теперь ernie и bert корректно высвобождаются!<br/>
<br/>
Массив friends больше не является коллекцией объектов Person. Теперь это <b>коллекция объектов класса Unowned</b>, которые служат обёрткой для экземпляров Person.<br/>
<br/>
Чтобы получить объекты Person из Unowned, используйте свойство value:<br/>
<br/>
<pre><code class="swift">let firstFriend = bert.friends.first?.value // get ernie </code></pre><br/>
<h2>Заключение</h2><br/>
Теперь вы хорошо понимаете управление памятью в Swift и знаете, как работает ARC. Надеюсь, публикация была для вас полезной.<br/>
<br/>
<a href="https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html" rel="nofollow">Apple: Automatic Reference Counting</a></div></div> <!----> <!----></div> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bswift%5D" class="tm-tags-list__link">swift</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5BARC%5D" class="tm-tags-list__link">ARC</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/hub/ios_dev/" class="tm-hubs-list__link">
    Разработка под iOS
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/swift/" class="tm-hubs-list__link">
    Swift
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/osx_dev/" class="tm-hubs-list__link">
    Разработка под MacOS
  </a></li></ul></div></div></article></div> <!----></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_medium"><title>Всего голосов 8: ↑8 и ↓0</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-rating"></use></svg> <span title="Всего голосов 8: ↑8 и ↓0" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_medium">+8</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">29K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    96
  </span></button> <!----> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> </div></div> <!----> <!----> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="/ru/users/infund/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><img alt="" src="//habrastorage.org/getpro/habr/avatars/409/bcf/087/409bcf0876262edf747ff8abd8522a6f.png" class="tm-entity-image__pic"></div></a> <div class="tm-user-card__meta"><div title=" 46 голосов " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    27.2
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">0</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title_variant-article"><span class="tm-user-card__name tm-user-card__name_variant-article">Юрий</span> <a href="/ru/users/infund/" class="tm-user-card__nickname tm-user-card__nickname_variant-article">
          @infund
        </a> <!----></div> <p class="tm-user-card__short-info tm-user-card__short-info_variant-article">Пользователь</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-article"><!----> <!----> <!----> <!----> <!----></div></div> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----></section> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="/ru/post/451130/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментарии 18 
    </span></a> <!----></div></div></div> <div class="tm-ad-banner__container tm-page-article__banner"><!----> <div id="articleBottomBanner" class="tm-ad-banner"></div></div> <!----> <!----> <!----> <!----> </div></div></div></div></div> <div class="tm-page__sidebar"><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__ads tm-layout-sidebar__ads_initial"><div class="tm-ad-banner__container tm-layout-sidebar__banner"><!----> <div id="sidebarBanner" class="tm-ad-banner"></div></div></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----> <!----></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/post/451130/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/post/451130/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2021 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"451130":{"id":"451130","timePublished":"2019-05-14T08:12:23+00:00","isCorporative":false,"lang":"ru","titleHtml":"Swift: ARC и управление памятью","leadData":{"textHtml":"Будучи современным языком высокого уровня, \u003Cb\u003ESwift\u003C\u002Fb\u003E в основном берёт на себя управление памятью в ваших приложениях, занимаясь выделением и освобождением памяти. Это происходит благодаря механизму, который называется \u003Cb\u003EAutomatic Reference Counting\u003C\u002Fb\u003E, или сокращенно \u003Cb\u003EARC\u003C\u002Fb\u003E. В этом руководстве вы разберётесь, как работает ARC и как правильно управлять памятью в Swift. Понимая этот механизм, вы сможете влиять на время жизни объектов, размещенных в куче (\u003Cb\u003Eheap\u003C\u002Fb\u003E).\u003Cbr\u003E\r\n\u003Cbr\u003E\r\nВ этом руководстве вы прокачаете свои знания Swift и ARC, изучив следующее:\u003Cbr\u003E\r\n\u003Cbr\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003Eкак работает ARC\u003C\u002Fli\u003E\r\n\u003Cli\u003Eчто такое циклы ссылок (\u003Cb\u003Ereference cycles\u003C\u002Fb\u003E) и как их правильно устранять\u003C\u002Fli\u003E\r\n\u003Cli\u003Eкак создать пример цикла ссылок\u003C\u002Fli\u003E\r\n\u003Cli\u003Eкак находить циклы ссылок при помощи визуальных средств, предлагаемых Xcode\u003C\u002Fli\u003E\r\n\u003Cli\u003Eкак обращаться с ссылочными типами и типами-значениями\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E","imageUrl":null,"buttonTextHtml":"Читать дальше &rarr;","image":null},"editorVersion":"1.0","postType":"article","postLabels":[{"type":"translation","data":{"originalAuthorName":"Maxime Defauw, Mark Struzinski","originalUrl":"https:\u002F\u002Fwww.raywenderlich.com\u002F966538-arc-and-memory-management-in-swift"}},{"type":"tutorial","data":null}],"author":{"scoreStats":{"score":27.2,"votesCount":46},"rating":0,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"141179","alias":"infund","fullname":"Юрий","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F409\u002Fbcf\u002F087\u002F409bcf0876262edf747ff8abd8522a6f.png","speciality":"Пользователь"},"statistics":{"commentsCount":18,"favoritesCount":96,"readingCount":28902,"score":8,"votesCount":8},"hubs":[{"relatedData":null,"id":"548","alias":"ios_dev","type":"collective","title":"Разработка под iOS","titleHtml":"Разработка под iOS","isProfiled":true},{"relatedData":null,"id":"19039","alias":"swift","type":"collective","title":"Swift","titleHtml":"Swift","isProfiled":true},{"relatedData":null,"id":"19253","alias":"osx_dev","type":"collective","title":"Разработка под MacOS","titleHtml":"Разработка под MacOS","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003EБудучи современным языком высокого уровня, \u003Cb\u003ESwift\u003C\u002Fb\u003E в основном берёт на себя управление памятью в ваших приложениях, занимаясь выделением и освобождением памяти. Это происходит благодаря механизму, который называется \u003Cb\u003EAutomatic Reference Counting\u003C\u002Fb\u003E, или сокращенно \u003Cb\u003EARC\u003C\u002Fb\u003E. В этом руководстве вы разберётесь, как работает ARC и как правильно управлять памятью в Swift. Понимая этот механизм, вы сможете влиять на время жизни объектов, размещенных в куче (\u003Cb\u003Eheap\u003C\u002Fb\u003E).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ этом руководстве вы прокачаете свои знания Swift и ARC, изучив следующее:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003Eкак работает ARC\u003C\u002Fli\u003E\r\n\u003Cli\u003Eчто такое циклы ссылок (\u003Cb\u003Ereference cycles\u003C\u002Fb\u003E) и как их правильно устранять\u003C\u002Fli\u003E\r\n\u003Cli\u003Eкак создать пример цикла ссылок\u003C\u002Fli\u003E\r\n\u003Cli\u003Eкак находить циклы ссылок при помощи визуальных средств, предлагаемых Xcode\u003C\u002Fli\u003E\r\n\u003Cli\u003Eкак обращаться с ссылочными типами и типами-значениями\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Ca name=\"habracut\"\u003E\u003C\u002Fa\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EНачинаем\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nЗагрузите \u003Ca href=\"https:\u002F\u002Fkoenig-media.raywenderlich.com\u002Fuploads\u002F2019\u002F03\u002FARC-and-Memory-Management.zip\" rel=\"nofollow\"\u003Eисходные материалы.\u003C\u002Fa\u003E Откройте проект в папке \u003Cb\u003ECycles\u002FStarter\u003C\u002Fb\u003E. В первой части нашего руководства, разбираясь в ключевых понятиях, мы будем заниматься исключительно файлом \u003Cb\u003EMainViewController.swif\u003C\u002Fb\u003Et.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДобавьте этот класс внизу MainViewController.swift:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Eclass User {\n  let name: String\n  \n  init(name: String) {\n    self.name = name\n    print(\"User \\(name) was initialized\")\n  }\n\n  deinit {\n    print(\"Deallocating user named: \\(name)\")\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЗдесь определяется класс \u003Cb\u003EUser\u003C\u002Fb\u003E, который при помощи операторов \u003Cb\u003Eprint\u003C\u002Fb\u003E сигнализирует нам об инициализации и освобождении экземпляра класса.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТеперь создадим экземпляр класса User вверху MainViewController.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nРазместите этот код перед методом \u003Cb\u003EviewDidLoad()\u003C\u002Fb\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Elet user = User(name: \"John\")\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЗапустите приложение. Сделайте консоль Xcode видимой при помощи \u003Cb\u003ECommand-Shift-Y\u003C\u002Fb\u003E, чтобы видеть вывод операторов print.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nОбратите внимание на то, что на консоли появилась надпись \u003Cb\u003EUser John was initialized\u003C\u002Fb\u003E, но оператор print внутри \u003Cb\u003Edeinit\u003C\u002Fb\u003E не был исполнен. Значит, этот объект не был освобождён, так как он не вышел из области видимости (\u003Cb\u003Escope\u003C\u002Fb\u003E).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДругими словами, пока view controller, содержащий этот объект, не выйдет из области видимости, объект никогда не будет освобождён.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EОн в области видимости?\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nЗавернув экземпляр класса User в метод, мы разрешим выйти ему из области видимости, тем самым позволив ARC освободить его.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСоздадим метод \u003Cb\u003ErunScenario()\u003C\u002Fb\u003E внутри класса MainViewController и переместим инициализацию экземпляра класса User внутри него.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Efunc runScenario() {\n  let user = User(name: \"John\")\n}    \n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nrunScenario() определяет области видимости экземпляра User. На выходе из этой зоны \u003Cb\u003Euser\u003C\u002Fb\u003E должен быть высвобожден.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТеперь вызовем runScenario() добавив это в конце viewDidLoad():\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"swift\"\u003ErunScenario()\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЗапустите приложение. Вывод в консоли теперь выглядит так:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nUser John was initialized\u003Cbr\u002F\u003E\r\nDeallocating user named: John\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЭто означает, что вы высвободили объект, покинувший области видимости.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EВремя жизни объекта\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСуществование объекта делится на пять этапов:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003Eвыделение памяти: из стека или из кучи\u003C\u002Fli\u003E\r\n\u003Cli\u003Eинициализация: выполняется код внутри init\u003C\u002Fli\u003E\r\n\u003Cli\u003Eиспользование\u003C\u002Fli\u003E\r\n\u003Cli\u003Eдеинициализация: выполняется код внутри deinit\u003C\u002Fli\u003E\r\n\u003Cli\u003Eвысвобождение памяти: выделенная память возвращается в стек или кучу\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nНе существует прямого способа чтобы отследить этапы выделения и освобождения памяти, но можно использовать код внутри init и deinit. \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСчётчик ссылок (\u003Cb\u003Ereference counts\u003C\u002Fb\u003E), также известный как 'количество использований' (\u003Cb\u003Eusage counts\u003C\u002Fb\u003E), определяет, когда объект больше не нужен. Этот счётчик показывает число тех, кто «пользуется» этим объектом. Объект становится ненужным, когда счётчик использований равен нулю. Затем объект деинициализируется и высвобождается.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fb5\u002Foo\u002F78\u002Fb5oo78ealf173ey0ayz7rngnszk.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПри инициализации объекта User его счетчик ссылок равен 1, так как константа \u003Cb\u003Euser\u003C\u002Fb\u003E ссылается на этот объект.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ конце runScenario(), user выходит из области видимости и счётчик ссылок уменьшается до 0. В результате user деинициализируется и затем высвобождается.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EЦиклы ссылок (Reference Cycles)\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nВ большинстве случаев ARC работает так, как надо. Разработчику обычно не нужно беспокоиться об утечках памяти, когда неиспользуемые объекты остаются неосвобожденными на неопределённое время.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНо не всегда! Возможны утечки памяти.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКак это может произойти? Представим ситуацию, когда два объекта больше не используются, но каждый из них ссылается на другой. Так как у каждого счетчик ссылок не равен 0, ни один из них не будет освобождён.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fhd\u002Fzp\u002Fff\u002Fhdzpffk1eh3rug0fgmgnlghnb3q.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЭто цикл сильных ссылок (\u003Cb\u003Estrong reference cycle\u003C\u002Fb\u003E). Такая ситуация сбивает с толку ARC и не позволяет ему очистить память.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКак видите, счетчик ссылок в конце не равен 0 и, хотя никакие объекты уже не нужны, object1 и object2 не будут освобождены.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EПроверим наши ссылки\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nЧтобы проверить все это в деле, добавьте этот код после класса User в MainViewController.swift:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Eclass Phone {\n  let model: String\n  var owner: User?\n  \n  init(model: String) {\n    self.model = model\n    print(\"Phone \\(model) was initialized\")\n  }\n\n  deinit {\n    print(\"Deallocating phone named: \\(model)\")\n  }\n}    \u003C\u002Fcode\u003E\u003C\u002Fpre\u003E \u003Cbr\u002F\u003E\r\nЭтот код добавляет новый класс \u003Cb\u003EPhone\u003C\u002Fb\u003E с двумя свойствами, одно для модели и другое для владельца, а также методы init и deinit. Свойство владельца опциональное, так как у телефона может и не быть владельца.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТеперь добавьте эту строчку в runScenario():\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Elet iPhone = Phone(model: \"iPhone Xs\")\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЭто создаст экземпляр класса Phone.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EУдерживаем мобилу\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nТеперь добавьте этот код в класс User, сразу после свойства name:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Eprivate(set) var phones: [Phone] = []\n\nfunc add(phone: Phone) {\n  phones.append(phone)\n  phone.owner = self\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nДобавляем массив телефонов, которыми владеет user. Сеттер помечен как private, так что нужно использовать add(phone:).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЗапустите приложение. Как видите, экземпляры классов Phone и User objects высвобождаются, как надо\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nUser John was initialized\u003Cbr\u002F\u003E\r\nPhone iPhone XS was initialized\u003Cbr\u002F\u003E\r\nDeallocating phone named: iPhone Xs\u003Cbr\u002F\u003E\r\nDeallocating user named: John\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТеперь добавим это в конце runScenario():\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Euser.add(phone: iPhone)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЗдесь мы добавляем наш айфончик в список телефонов, которыми владеет \u003Cb\u003Euser\u003C\u002Fb\u003E, а также устанавливаем свойство телефона \u003Cb\u003Eowner\u003C\u002Fb\u003E в '\u003Cb\u003Euser\u003C\u002Fb\u003E'.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЕще раз запустите приложение. Вы увидите, что объекты user и iPhone не высвобождаются. Цикл сильных ссылок между ними не позволяет ARC высвободить их.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Flo\u002Faz\u002Fmu\u002Floazmuamyoww2ttr7wnwcd8_n4w.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EСсылки Weak \u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nЧтобы разорвать цикл сильных ссылок, вы можете обозначить отношение между объектами как слабое (\u003Cb\u003Eweak\u003C\u002Fb\u003E).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПо умолчанию все ссылки являются сильными и присваивание приводит к увеличению счётчика ссылок. При использовании слабых ссылок (weak references) счётчик ссылок не увеличивается.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДругими словами, \u003Cb\u003Eслабые ссылки не влияют на управление жизнью объекта\u003C\u002Fb\u003E. Слабые ссылки всегда объявлены как \u003Cb\u003Eoptional\u003C\u002Fb\u003E. Таким образом, когда счётчик ссылок станет равным 0, ссылка может быть установлена в nil.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fti\u002Fqd\u002Fkc\u002Ftiqdkcyfstrndd8xswpf8zfebfo.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНа этой иллюстрации штриховые линии обозначают слабые ссылки. Обратите внимание, что счётчик ссылок object1 равен 1, так как на него ссылается variable1. Счётчик ссылок object2 равен 2, так как на него ссылается variable2 и object1.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nobject2 также ссылается на object1, но \u003Cb\u003EСЛАБО\u003C\u002Fb\u003E, что означает, что это не влияет на счетчик ссылок на object1.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКогда variable1 и variable2 освобождаются, у object1 счётчик ссылок становится равным 0, что высвобождает его. Это, в свою очередь, освобождает сильную ссылку на object2, что приводит уже к его высвобождению.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ классе Phone измените объявление свойства owner следующим образом:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Eweak var owner: User?\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nОбъявлением ссылки на свойство owner как 'weak' мы разрываем цикл сильных ссылок между классами User и Phone.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fym\u002Fax\u002F_m\u002Fymax_mv9cvlpi8xqwnxmb14vr2g.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЗапустите приложение. Теперь user и phone корректно высвобождаются.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EСсылки Unowned\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nСуществует также другой модификатор ссылки, который не приводит к увеличению счётчика ссылок: \u003Cb\u003Eunowned\u003C\u002Fb\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ чём же отличие \u003Cb\u003Eunowned\u003C\u002Fb\u003E от \u003Cb\u003Eweak\u003C\u002Fb\u003E? Ссылка weak всегда optional и автоматически становится nil, когда ссылаемый объект высвобождается.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВот почему мы должны объявлять weak свойства как переменную optional типа: это свойство должно измениться. \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСсылки Unowned, напротив, никогда не optional. Если вы попробуете получить доступ к unowned свойству, которое ссылается на освобождённый объект, вы получите ошибку, похожую на принудительное разворачивание содержащую nil переменной (force unwrapping).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fi9\u002Fhf\u002Fbc\u002Fi9hfbcizzk2eg38s_hidjq3evju.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДавайте попробуем применить \u003Cb\u003Eunowned\u003C\u002Fb\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДобавим новый класс \u003Cb\u003ECarrierSubscription\u003C\u002Fb\u003E в конце MainViewController.swift:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Eclass CarrierSubscription {\n  let name: String\n  let countryCode: String\n  let number: String\n  let user: User\n              \n  init(name: String, countryCode: String, number: String, user: User) {\n    self.name = name\n    self.countryCode = countryCode\n    self.number = number\n    self.user = user\n    \n    print(\"CarrierSubscription \\(name) is initialized\")\n  }\n\n  deinit {\n    print(\"Deallocating CarrierSubscription named: \\(name)\")\n  }\n}        \u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nУ CarrierSubscription четыре свойства:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nName: название провайдера.\u003Cbr\u002F\u003E\r\nCountryCode: код страны.\u003Cbr\u002F\u003E\r\nNumber: телефонный номер.\u003Cbr\u002F\u003E\r\nUser: ссылка на пользователя.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EКто ваш провайдер?\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nТеперь добавьте это в класс User после свойства name:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Evar subscriptions: [CarrierSubscription] = []\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЗдесь мы держим массив провайдеров пользователя.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТеперь добавьте это в класс Phone class, после свойства owner:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Evar carrierSubscription: CarrierSubscription?\n\nfunc provision(carrierSubscription: CarrierSubscription) {\n  self.carrierSubscription = carrierSubscription\n}\n\nfunc decommission() {\n  carrierSubscription = nil\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЭто добавляет опциональное свойство CarrierSubscription и два метода для регистрации и разрегистрации телефона у провайдера.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТеперь добвьте внутри метода init у класса CarrierSubscription, прямо перед оператором print:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Euser.subscriptions.append(self)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nМы добавляем CarrierSubscription в массив провайдеров пользователя.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИ, наконец, добавьте это в конце метода runScenario():\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Elet subscription = CarrierSubscription(\n  name: \"TelBel\", \n  countryCode: \"0032\",\n  number: \"31415926\", \n  user: user)\niPhone.provision(carrierSubscription: subscription)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nМы создаем подписку на провайдера для пользователя и подключаем к ней телефон.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЗапустите приложение. В консоли вы увидите:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nUser John was initialized\u003Cbr\u002F\u003E\r\nPhone iPhone Xs was initialized\u003Cbr\u002F\u003E\r\nCarrierSubscription TelBel is initialized\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИ опять цикл ссылок! user, iPhone и subscription не высвободились в конце.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСможете найти проблему?\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fuu\u002Ffg\u002Feq\u002Fuufgeqkvqa31jwwlsnlikc-iob8.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EРазрываем цепь\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nИли ссылка из user на subscription или ссылка из subscription на user должна быть unowned, чтобы разорвать цикл. Вопрос в том, какой вариант выбрать. Давайте разберемся в структурах.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПользователь владеет подпиской на провайдера, но наоборот — нет, подписка на провайдера не владеет пользователем. \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nБолее того, нет никакого смысла в существовании CarrierSubscription без привязки к владеющему ей пользователю. \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТаким образом, ссылка на пользователя должна быть unowned.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИзмените объявление user в CarrierSubscription:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Eunowned let user: User\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТеперь user unowned, что разрывает цикл ссылок и позволит высвободить все объекты.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fen\u002Fvx\u002Fcu\u002Fenvxcuihbevfcfqv1cyg-kc3lo4.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EЦиклы ссылок в замыканиях\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nЦиклы ссылок применительно к объектам возникают, когда у объектов есть свойства, ссылающиеся друг на друга. Как и объекты, замыкания — это ссылочный тип, и могут приводить к циклам ссылок. Замыкания «захватывают» (capture) объекты, которые используют.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНапример, если вы присвоите замыкание свойству класса, и это замыкание использует свойства того же класса, то у нас появляется цикл ссылок. Другими словами, объект держит ссылку на замыкание через свойство. Замыкание содержит ссылку на объект через захваченное значение self.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fz-\u002Flh\u002Fow\u002Fz-lhowlkfyvy4ycusafxhygjisw.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДобавьте этот код к CarrierSubscription сразу после свойства user:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Elazy var completePhoneNumber: () -\u003E String = {\n  self.countryCode + \" \" + self.number\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЭто замыкание вычисляет и возвращает полный телефонный номер. Свойство объявлено как \u003Cb\u003Elazy\u003C\u002Fb\u003E, оно будет присвоено при первом использовании.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЭто необходимо так как оно использует self.countryCode и self.number, которые будут недоступны до выполнения кода инициалайзера.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДобавьте в конец runScenario():\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Eprint(subscription.completePhoneNumber())\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nВызов completePhoneNumber() приведет к исполнению замыкания.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЗапустите приложение и вы увидите, что user и iPhone высвобождаются, а CarrierSubscription — нет, по причине цикла сильных ссылок между объектом и замыканием.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002F7t\u002Frb\u002Fax\u002F7trbaxtrrhtadtm29-dvqwehzo4.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EСписки захвата (Capture Lists)\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nВ Swift предусмотрен простой и элегантный способ разорвать цикл сильных ссылок в замыканиях. Вы объявляете список захвата, в котором определяете отношения между замыканием и объектами, которое оно захватывает.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДля демонстрации списка захвата рассмотрим следующий код:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Evar x = 5\nvar y = 5\n\nlet someClosure = { [x] in\n  print(\"\\(x), \\(y)\")\n}\nx = 6\ny = 6\n\nsomeClosure()        \u002F\u002F Prints 5, 6\nprint(\"\\(x), \\(y)\")  \u002F\u002F Prints 6, 6\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nx есть в списке захвата замыкания, таким образом значение x копируется в месте определения замыкания. Оно захвачено по значению.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\ny нет в списке захвата, оно захвачено по ссылке. Это означает, что значение y будет таким, какое оно в момент вызова замыкания.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСписки замыкания помогают определить отношения weak или unowned взаимодействие по отношению к захвачиваемым внутри замыкания объектам. В нашем случае подходящий выбор — unowned, так как замыкание не может существовать, если экземпляр CarrierSubscription высвободится.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EЗахватите себя\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nЗамените определение completePhoneNumber в CarrierSubscription::\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Elazy var completePhoneNumber: () -\u003E String = { [unowned self] in\n  return self.countryCode + \" \" + self.number\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nМы добавляем \u003Cb\u003E[unowned self]\u003C\u002Fb\u003E в список захвата замыкания. Это означает, что мы захватили \u003Cb\u003Eself\u003C\u002Fb\u003E как \u003Cb\u003Eunowned\u003C\u002Fb\u003E ссылку вместо сильной.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЗапустите приложение и вы увидите, что теперь CarrierSubscription высвобождается.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНа самом деле приведённый выше синтаксис — это короткая форма более длинного и полного, в котором появляется новая переменная:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Evar closure = { [unowned newID = self] in\n  \u002F\u002F Use unowned newID here...\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТут newID — это unowned копия self. Вне замыкания self остается самим собой. В короткой форме, приведенной ранее, мы \u003Cb\u003Eсоздаём новую переменную self\u003C\u002Fb\u003E, которая затеняет существующий self внутри замыкания.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EИспользуйте Unowned осторожно\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nВ вашем коде отношения между self и completePhoneNumber обозначены как unowned.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЕсли вы уверены, что объект, используемый в замыкании, не высвободится, можете использовать unowned. Если он всё-таки высвободится, вы в беде!\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДобавьте этот код в конце MainViewController.swift:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Eclass WWDCGreeting {\n  let who: String\n  \n  init(who: String) {\n    self.who = who\n  }\n\n  lazy var greetingMaker: () -\u003E String = { [unowned self] in\n    return \"Hello \\(self.who).\"\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТеперь вот это в конце runScenario():\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Elet greetingMaker: () -\u003E String\n\ndo {\n  let mermaid = WWDCGreeting(who: \"caffeinated mermaid\")\n  greetingMaker = mermaid.greetingMaker\n}\n\nprint(greetingMaker()) \u002F\u002F ЛОВУШКА!        \u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЗапустите приложение и вы увидите аварийное завершение и что-такое в консоли:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nUser John was initialized\u003Cbr\u002F\u003E\r\nPhone iPhone XS was initialized\u003Cbr\u002F\u003E\r\nCarrierSubscription TelBel is initialized\u003Cbr\u002F\u003E\r\n0032 31415926\u003Cbr\u002F\u003E\r\nFatal error: Attempted to read an unowned reference but object 0x600000f0de30 was already deallocated2019-02-24 12:29:40.744248-0600 Cycles[33489:5926466] Fatal error: Attempted to read an unowned reference but object 0x600000f0de30 was already deallocated\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИсключение возникло по причине того, что замыкание ждёт, что self.who существует, но он был высвобожден, как только mermaid вышла из области действия в конце блока do.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЭто пример может выглядеть высосанным из пальца, но такие вещи случаются. Например, когда мы используем замыкания, чтобы запустить что-то значительно позже, скажем, после того, как закончился асинхронный вызов в сети.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EРазминируем ловушку\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nЗамените greetingMaker в классе WWDCGreeting таким образом:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Elazy var greetingMaker: () -\u003E String = { [weak self] in\n  return \"Hello \\(self?.who).\"\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nМы сделали две вещи: во-первых, мы заменили unowned на weak. Во-вторых, так как self стал weak, мы получаем доступ к свойству who через self?.who. Игнорируйте предупреждение Xcode, мы его скоро исправим.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПриложение больше не крашится, но, если его запустить, мы получим забавный результат: “Hello nil.”\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВозможно, полученный результат вполне приемлем, но часто нам нужно сделать что-то, если объект был освобождён. Это можно сделать при помощи оператора guard.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЗамените текст замыкания этим:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Elazy var greetingMaker: () -\u003E String = { [weak self] in\n  guard let self = self else {\n    return \"No greeting available.\"\n  }\n  return \"Hello \\(self.who).\"\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nОператор guard присваивает self, взятое из weak self. Если self — nil, замыкание возвращает “No greeting available.” В противном случае, self становится сильной ссылкой, так что объект гарантированно доживёт до конца выполнения замыкания.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EИщем циклы ссылок в Xcode 10\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nТеперь, когда вы понимаете принципы работы ARC, что такое циклы ссылок и как их разрывать, пришло время посмотреть пример реального приложения.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nОткройте проект Starter, находящийся в папке Contacts.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЗапустите приложение.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fa8\u002Fce\u002Fl1\u002Fa8cel1rgbdkm_fel_d880f2swf4.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЭто простейший менеджер контактов. Попробуйте кликнуть на контакте, добавьте пару новых.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНазначение файлов:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nContactsTableViewController: показывает все контакты.\u003Cbr\u002F\u003E\r\nDetailViewController: показывает подробную информацию выбранного контакта.\u003Cbr\u002F\u003E\r\nNewContactViewController: позволяет добавить новый контакт.\u003Cbr\u002F\u003E\r\nContactTableViewCell: ячейка таблицы, показывающая детали контакта.\u003Cbr\u002F\u003E\r\nContact: модель контакта.\u003Cbr\u002F\u003E\r\nNumber: модель номера телефона.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nОднако, с этим проектом всё плохо: тут затаился цикл ссылок. Пользователи сначала не заметят проблем по причине небольшого размера утекающей памяти, по этой же причине сложно найти место утечки.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nК счастью, в Xcode 10 есть встроенные средства, чтобы найти мельчайшую утечку памяти.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЗапустите снова приложение. Удалите 3-4 контакта при помощи свайпа влево и кнопки delete. Похоже, что они исчезают совсем, да?\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fxu\u002Fd9\u002Fqf\u002Fxud9qf3rcyaf5ot_08l8vauizto.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EГде же течёт?\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nПри запущенном приложении кликните на кнопке Debug Memory Graph:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fla\u002Fna\u002Fkm\u002Flanakmzc0d2ousrcf5jwkpu-ova.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПонаблюдайте за Runtime Issues в Debug navigator. Они отмечены пурпурными квадратами с белым восклицательным знаком внутри:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fuc\u002Fko\u002Fvj\u002Fuckovjp_eqoplopih79xuz1jl7e.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВыберите в навигаторе один из проблемных Contact объектов. Цикл чётко виден: объекты Contact и Number ссылаясь друг на друга, удерживают.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002F7f\u002Fwi\u002Fos\u002F7fwios8n7zdk4ww7bj81p4kvgle.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПохоже, вам пора заглянуть в код. Учитывайте, что контакт может существовать без номера, но не наоборот.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКак бы вы разрешили этот цикл? Ссылка из Contact на Number или из Number на Contact? weak или unowned? Попробуйте сначала сами! \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\"\u003E\u003Cb class=\"spoiler_title\"\u003EЕсли потребовалась помощь...\u003C\u002Fb\u003E\u003Cdiv class=\"spoiler_text\"\u003EЕсть 2 возможных решения: или сделать ссылку из Contact на Number weak, или из Number на Contact unowned.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДокументация Apple рекомендует, чтобы родительский объект владел сильной ссылкой на «детский» — не наоборот. Это означает, что мы даем Contact сильную ссылку на Number, а Number — unowned ссылку на Contact:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Eclass Number {\n  unowned var contact: Contact\n  \u002F\u002F Other code...\n}\n\nclass Contact {\n  var number: Number?\n  \u002F\u002F Other code...\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EБонус: циклы с ссылочными типами и типами-значениями.\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nВ Swift есть ссылочные типы (классы и замыкания) и типы-значения (структуры, перечисления). Тип-значение копируется при его передаче, а ссылочные типы делят одно значение при помощи ссылки.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЭто значит, что в случае типов-значений циклов не может быть. Для возникновения цикла нам нужно как минимум 2 ссылочных типа.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВернёмся к проекту Cycles project и добавим этот код в конце MainViewController.swift:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Estruct Node { \u002F\u002F Error\n  var payload = 0\n  var next: Node?\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nНе выйдет! Структура — тип значение и не может иметь рекурсию на экземпляр самой себя. В противном случае, у такой структуры был бы бесконечный размер.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИзменим структуру на класс.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Eclass Node {\n  var payload = 0\n  var next: Node?\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nСсылка на себя вполне допустима для классов (ссылочный тип), так что проблем у компилятора не возникает.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТеперь добавим это в конце MainViewController.swift:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Eclass Person {\n  var name: String\n  var friends: [Person] = []\n  init(name: String) {\n    self.name = name\n    print(\"New person instance: \\(name)\")\n  }\n\n  deinit {\n    print(\"Person instance \\(name) is being deallocated\")\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nА это — в конце runScenario():\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Edo {\n  let ernie = Person(name: \"Ernie\")\n  let bert = Person(name: \"Bert\")\n  \n  ernie.friends.append(bert) \u002F\u002F Not deallocated\n  bert.friends.append(ernie) \u002F\u002F Not deallocated\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЗапустите приложение. Обратите внимание: ни ernie, ни bert не высвобождены.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EСсылка и значение\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nЭто пример сочетания ссылочного типа и типа-значения, которое привело к циклу ссылок.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nernie и bert остаются невысвобожденными, держа друг друга в своих массивах друзей, хотя массивы сами по себе — типы-значения.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПопробуйте сделать архив friends как unowned, и Xcode покажет ошибку: unowned применим только к классам.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЧтобы пофиксить этот цикл, нам придётся создать объект-обёртку и использовать его для добавления экземпляров в массив.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДобавьте следующее определение перед классом Person:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Eclass Unowned&lt;T: AnyObject\u003E {\n  unowned var value: T\n  init (_ value: T) {\n    self.value = value\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЗатем измените определение friends в классе Person:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Evar friends: [Unowned&lt;Person\u003E] = []\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nНаконец, замените содержимое блока do в runScenario():\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Edo {\n  let ernie = Person(name: \"Ernie\")\n  let bert = Person(name: \"Bert\")\n  \n  ernie.friends.append(Unowned(bert))\n  bert.friends.append(Unowned(ernie))\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЗапустите приложение, теперь ernie и bert корректно высвобождаются!\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nМассив friends больше не является коллекцией объектов Person. Теперь это \u003Cb\u003Eколлекция объектов класса Unowned\u003C\u002Fb\u003E, которые служат обёрткой для экземпляров Person.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЧтобы получить объекты Person из Unowned, используйте свойство value:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"swift\"\u003Elet firstFriend = bert.friends.first?.value \u002F\u002F get ernie \u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EЗаключение\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nТеперь вы хорошо понимаете управление памятью в Swift и знаете, как работает ARC. Надеюсь, публикация была для вас полезной.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca href=\"https:\u002F\u002Fdocs.swift.org\u002Fswift-book\u002FLanguageGuide\u002FAutomaticReferenceCounting.html\" rel=\"nofollow\"\u003EApple: Automatic Reference Counting\u003C\u002Fa\u003E\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"swift"},{"titleHtml":"ARC"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F451130\u002F8e062cd8cd1dcce249e9426332925d20\u002F","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F451130\u002F8e062cd8cd1dcce249e9426332925d20\u002F?format=vk","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F451130\\\u002F\"},\"headline\":\"Swift: ARC и управление памятью\",\"datePublished\":\"2019-05-14T11:12:23+03:00\",\"dateModified\":\"2020-02-13T10:30:28+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"Юрий\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"Будучи современным языком высокого уровня, Swift в основном берёт на себя управление памятью в ваших приложениях, занимаясь выделением и освобождением памяти. Эт...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F451130\\\u002F#post-content-body\",\"about\":[\"h_ios_dev\",\"h_swift\",\"h_osx_dev\",\"f_develop\"],\"image\":[\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fb5\\\u002Foo\\\u002F78\\\u002Fb5oo78ealf173ey0ayz7rngnszk.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fhd\\\u002Fzp\\\u002Fff\\\u002Fhdzpffk1eh3rug0fgmgnlghnb3q.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Flo\\\u002Faz\\\u002Fmu\\\u002Floazmuamyoww2ttr7wnwcd8_n4w.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fti\\\u002Fqd\\\u002Fkc\\\u002Ftiqdkcyfstrndd8xswpf8zfebfo.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fym\\\u002Fax\\\u002F_m\\\u002Fymax_mv9cvlpi8xqwnxmb14vr2g.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fi9\\\u002Fhf\\\u002Fbc\\\u002Fi9hfbcizzk2eg38s_hidjq3evju.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fuu\\\u002Ffg\\\u002Feq\\\u002Fuufgeqkvqa31jwwlsnlikc-iob8.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fen\\\u002Fvx\\\u002Fcu\\\u002Fenvxcuihbevfcfqv1cyg-kc3lo4.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fz-\\\u002Flh\\\u002Fow\\\u002Fz-lhowlkfyvy4ycusafxhygjisw.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002F7t\\\u002Frb\\\u002Fax\\\u002F7trbaxtrrhtadtm29-dvqwehzo4.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa8\\\u002Fce\\\u002Fl1\\\u002Fa8cel1rgbdkm_fel_d880f2swf4.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fxu\\\u002Fd9\\\u002Fqf\\\u002Fxud9qf3rcyaf5ot_08l8vauizto.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fla\\\u002Fna\\\u002Fkm\\\u002Flanakmzc0d2ousrcf5jwkpu-ova.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fuc\\\u002Fko\\\u002Fvj\\\u002Fuckovjp_eqoplopih79xuz1jl7e.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002F7f\\\u002Fwi\\\u002Fos\\\u002F7fwios8n7zdk4ww7bj81p4kvgle.png\"]}","metaDescription":"Будучи современным языком высокого уровня, Swift в основном берёт на себя управление памятью в ваших приложениях, занимаясь выделением и освобождением памяти. Это происходит благодаря механизму,...","mainImageUrl":null,"amp":false},"polls":[],"commentsEnabled":true,"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":false}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[],"hubs":"ios_dev,swift,osx_dev"},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{}},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"dfp":{"slotsDict":{}},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.c0af73e7.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
</body>
</html>
