<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <title>How We Find Lambda Expressions in IntelliJ IDEA / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.c0af73e7.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.85eb77f0b17c8235e7b64b9f81ea5ec2.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" src="/js/ads.js" onload="window['zhY4i4nJ9K'] = true" data-vmid="checkad"></script><script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/en\/company\/JetBrains\/blog\/451754\/"},"headline":"How We Find Lambda Expressions in IntelliJ IDEA","datePublished":"2019-05-14T12:50:29+03:00","dateModified":"2019-05-14T15:42:08+03:00","author":{"@type":"Person","name":"Тагир Валеев"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"Code search and navigation are important features of any IDE. In Java, one of the commonly used search options is searching for all implementations of an...","url":"https:\/\/habr.com\/en\/company\/JetBrains\/blog\/451754\/#post-content-body","about":["c_JetBrains","h_programming","h_java","f_develop"],"image":["https:\/\/habrastorage.org\/webt\/ff\/js\/7m\/ffjs7m9ycsved2ciyrqdvb4uiwe.png","https:\/\/habrastorage.org\/webt\/e-\/nn\/0y\/e-nn0ynvtojiydboaco5uiyzwms.png"]}</script>
  <script src="//www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.49.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_eng"><meta data-vue-meta="ssr" property="og:title" content="How We Find Lambda Expressions in IntelliJ IDEA" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="How We Find Lambda Expressions in IntelliJ IDEA" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="How We Find Lambda Expressions in IntelliJ IDEA" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="Code search and navigation are important features of any IDE. In Java, one of the commonly used search options is searching for all implementations of an interface. This feature is often called Type..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="Code search and navigation are important features of any IDE. In Java, one of the commonly used search options is searching for all implementations of an interface. This feature is often called Type..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="Code search and navigation are important features of any IDE. In Java, one of the commonly used search options is searching for all implementations of an interface. This feature is often called Type..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="Code search and navigation are important features of any IDE. In Java, one of the commonly used search options is searching for all implementations of an interface. This feature is often called Type..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="Code search and navigation are important features of any IDE. In Java, one of the commonly used search options is searching for all implementations of an interface. This feature is often called Type..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habr.com/share/publication/451754/b25ed51433a925cd292a361158856dde/" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habr.com/share/publication/451754/b25ed51433a925cd292a361158856dde/" data-vmid="og:image"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habr.com/share/publication/451754/b25ed51433a925cd292a361158856dde/" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habr.com/share/publication/451754/b25ed51433a925cd292a361158856dde/" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habr.com/share/publication/451754/b25ed51433a925cd292a361158856dde/" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="451754" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2019-05-14T09:50:29.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="en_US" data-vmid="og:locale"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/451754/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="https://habr.com/en/company/JetBrains/blog/451754/" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habr.com/share/publication/451754/b25ed51433a925cd292a361158856dde/" data-vmid="image:href">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="/ru/sandbox/start/" class="tm-header__become-author-btn">
            Как стать автором
          </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="/ru/all/" class="tm-main-menu__item">
        Все потоки
      </a> <a href="/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" companyName="JetBrains" data-async-called="true" class="tm-page"><div class="tm-page-width"><div class="tm-page__header"><div class="tm-company-card__branding tm-company-article__branding tm-company-card__branding_loading"><div class="tm-company-card__branding-placeholder"><!----></div> <a href="https://www.jetbrains.com/ru-ru/"><img src="//habrastorage.org/getpro/habr/branding/2e8/d41/b77/2e8d41b772b3231a100471e973e90c6d.png" width="100%" class="tm-company-card__branding-image"></a></div></div> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"><div class="tm-company-card tm-company-article__company-card"><div class="tm-company-card__info"><div class="tm-company-card__header"><a href="/ru/company/JetBrains/profile/" class="tm-company-card__avatar"><div class="tm-entity-image"><img alt="" height="48" src="//habrastorage.org/getpro/habr/company/8dc/19c/a06/8dc19ca065174d2bc9027bbd2a47f072.png" width="48" class="tm-entity-image__pic"></div></a> <!----> <div class="tm-rating tm-company-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">185.01</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div> <div class="tm-company-card__info"><a href="/ru/company/JetBrains/profile/" class="tm-company-card__name">
        JetBrains
      </a> <div class="tm-company-card__description">Делаем эффективные инструменты для разработчиков</div></div></div> <div class="tm-company-card__buttons"><!----> <!----></div></div> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="/ru/users/lany/" title="lany" class="tm-user-info__userpic"><div class="tm-entity-image"><svg height="24" width="24" class="tm-svg-img tm-image-placeholder tm-image-placeholder_blue"><!----> <use xlink:href="/img/megazord-v24.ce74655c.svg#placeholder-user"></use></svg></div></a> <span class="tm-user-info__user"><a href="/ru/users/lany/" class="tm-user-info__username">
      lany
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2019-05-14T09:50:29.000Z" title="2019-05-14, 12:50">14  мая  2019 в 12:50</time></span></div> <!----></div> <h1 lang="en" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>How We Find Lambda Expressions in IntelliJ IDEA</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="/ru/company/JetBrains/blog/" class="tm-article-snippet__hubs-item-link router-link-active"><span>Блог компании JetBrains</span> <!----></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/programming/" class="tm-article-snippet__hubs-item-link"><span>Программирование</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/java/" class="tm-article-snippet__hubs-item-link"><span>Java</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span></div> <div class="tm-article-snippet__labels"><div class="tm-article-snippet__label"><span>
        Перевод
      </span></div></div> <!----> <!----></div></div> <div class="tm-article-presenter__origin"><a href="https://habr.com/ru/company/JetBrains/blog/444052/" target="_blank" class="tm-article-presenter__origin-link">
                Автор оригинала:
                <span>
                  Tagir Valeev
                </span></a></div> <div data-gallery-root="" lang="en" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-1"><div xmlns="http://www.w3.org/1999/xhtml"><p><img alt="Type Hierarchy in IntelliJ IDEA" src="/img/image-loader.svg" align="right" data-src="https://habrastorage.org/webt/ff/js/7m/ffjs7m9ycsved2ciyrqdvb4uiwe.png" data-width="300"/>Code search and navigation are important features of any IDE. In Java, one of the commonly used search options is searching for all implementations of an interface. This feature is often called Type Hierarchy, and it looks just like the image on the right.</p><br/>
<p>It's inefficient to iterate over all project classes when this feature is invoked. One option is to save the complete class hierarchy in the index during compilation since the compiler builds it anyway. We do this when the compilation is run by the IDE and not delegated, for example, to Gradle. But this works only if nothing has been changed in the module after the compilation. In general, the source code is the most up-to-date information provider, and indexes are based on the source code.</p><br/>
<p>Finding immediate children is a simple task if we are not dealing with a functional interface. When searching for implementations of the <code>Foo</code> interface, we need to find all the classes that have <code>implements Foo</code> and interfaces that have <code>extends Foo</code>, as well as <code>new Foo(...) {...}</code> anonymous classes. To do this, it is enough to build a syntax tree of each project file in advance, find the corresponding constructs, and add them to an index. <a name="habracut"></a>There is, however, an intricacy here: you might be looking for the <code>com.example.goodcompany.Foo</code> interface, while <code>org.example.evilcompany.Foo</code> is actually used. Can we put the full name of the parent interface into the index in advance? It can be tricky. For example, the file where the interface is used may look like this:</p><br/>
<pre><code class="java">// MyFoo.java
import org.example.foo.*;
import org.example.bar.*;
import org.example.evilcompany.*;

class MyFoo implements Foo {...}</code></pre><br/>
<p>By looking at the file alone, it's impossible to tell what the actual fully qualified name of <code>Foo</code> is. We'll have to look into the content of several packages. And each package can be defined in several places in the project (for example, in several JAR files). If we perform proper symbol resolution when analyzing this file, indexing will take a lot of time. But the main problem is that the index built on <code>MyFoo.java</code> will depend on other files as well. We can move the declaration of the <code>Foo</code> interface, for example, from the <code>org.example.foo</code> package to the <code>org.example.bar</code> package, without changing anything in the <code>MyFoo.java</code> file, but the fully qualified name of <code>Foo</code> will change.</p><br/>
<p>In IntelliJ IDEA, indexes depend only on the content of a single file. On the one hand, it is very convenient: the index associated with a specific file becomes invalid when the file is changed. On the other hand, it imposes major restrictions on what can be put into the index. For example, it does not allow the fully qualified names of parent classes to be saved reliably in the index. But, in general, it's not that bad. When requesting a type hierarchy, we can find everything that matches our request by a short name, and then perform the proper symbol resolution for these files and determine whether that's what we are looking for. In most cases, there won't be too many redundant symbols and the check won't take long.</p><br/>
<p><img alt="Functional interface hierarchy in IntelliJ IDEA" src="/img/image-loader.svg" align="right" data-src="https://habrastorage.org/webt/e-/nn/0y/e-nn0ynvtojiydboaco5uiyzwms.png" data-width="300"/>Things change, however, when the class whose children we are looking for is a functional interface. Then, in addition to the explicit and anonymous subclasses, there'll be lambda expressions and method references. What do we put into the index now, and what is to be evaluated during the search?</p><br/>
<p>Let's assume we have a functional interface:</p><br/>
<pre><code class="java">@FunctionalInterface
public interface StringConsumer {
  void consume(String s);
}</code></pre><br/>
<p>The code contains different lambda expressions. For instance:</p><br/>
<pre><code class="java">() -> {} // a certain mismatch: no parameters
(a, b) -> a + b // a certain mismatch: two parameters
s -> {
  return list.add(s); // a certain mismatch: a value is returned
}
s -> list.add(s); // a potential match</code></pre><br/>
<p>It means we can quickly filter out lambdas that have an inappropriate number of parameters or a clearly inappropriate return type, for example, void instead of non-void. It is usually impossible to determine the return type more precisely. For instance, in <code>s -> list.add(s)</code> you will have to resolve <code>list</code> and <code>add</code>, and, possibly, run a regular type inference procedure. It takes time and depends on the content of other files.</p><br/>
<p>We’re lucky if the functional interface takes five arguments. But if it only takes one, the filter will keep a huge number of unnecessary lambdas. It's even worse when it gets to method references. By the way it looks, one cannot tell whether a method reference is suitable or not.</p><br/>
<p>To get things straight, it might be worth looking at what surrounds the lambda. Sometimes, it works. For instance:</p><br/>
<pre><code class="java">// declaration of a local variable or a field of different type
Predicate&lt;String> p = s -> list.add(s);

// a different return type
IntPredicate getPredicate() {
  return s -> list.add(s);
}

// assignment to a variable of a different type
SomeType fn;
fn = s -> list.add(s);

// cast to a different type
foo((SomeFunctionalType)(s -> list.add(s)));

// declaration of a different type array
Foo[] myLambdas = {s -> list.add(s), s -> list.remove(s)};</code></pre><br/>
<p>In all these cases, the short name of the corresponding functional interface can be determined from the current file and can be put into the index next to the functional expression, be it a lambda or a method reference. Unfortunately, in real-life projects, these cases cover a very small percentage of all lambdas. In most cases, lambdas are used as method arguments:</p><br/>
<pre><code class="java">list.stream()
    .filter(s -> StringUtil.isNonEmpty(s))
    .map(s -> s.trim())
    .forEach(s -> list.add(s));</code></pre><br/>
<p>Which of the three lambdas can contain <code>StringConsumer</code>? Obviously, none. Here we have a Stream API chain that only features functional interfaces from the standard library, it can't have the custom type.</p><br/>
<p>However, the IDE should be able to see through the trick and give us an exact answer. What if <code>list</code> is not exactly <code>java.util.List</code>, and <code>list.stream()</code> returns something different from <code>java.util.stream.Stream</code>? Then we'll have to resolve <code>list</code>, which, as we know, cannot be reliably done based only on the content of the current file. And even if we do, the search should not rely on the implementation of the standard library. What if in this particular project we have replaced <code>java.util.List</code> with a class of our own? The search must take this into account. And, naturally, lambdas are used not only in standard streams: there are many other methods to which they are passed.</p><br/>
<p>As a result, we can query the index for a list of all Java files that use lambdas with the required number of parameters and a valid return type (in fact, we only search for four options: void, non-void, boolean, and any). And what's next? Do we need to build a complete PSI tree (a kind of a parse tree with symbol resolution, type inference, and other smart features) for each of these files and perform proper type inference for lambdas? For a big project, it will take ages to get the list of all interface implementations, even if there are only two of them.</p><br/>
<p>So, we need to take the following steps:</p><br/>
<ul>
<li>Ask index (not costly)</li>
<li>Build PSI (costly)</li>
<li>Infer lambda type (very costly)</li>
</ul><br/>
<p>For Java 8 and later, type inference is an extremely costly operation. In a complex call chain, there might be many substitutional generic parameters, the values of which have to be determined using the hard-hitting procedure described in <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-18.html">Chapter 18</a> of the specification. For the current file, this can be done in the background, but processing thousands of unopened files this way would be an expensive task.</p><br/>
<p>Here, however, it is possible to slightly cut corners: in most cases, we don’t need the concrete type. Unless a method accepts a generic parameter where the lambda is passed to it, the final parameter substitution step can be avoided. If we have inferred the <code>java.util.function.Function&lt;T, R></code> lambda type, we don't have to evaluate the values of the substitutional parameters <code>T</code> and <code>R</code>: it is already clear whether to include the lambda into search results or not. However, it won't work for a method like this:</p><br/>
<pre><code class="java">static &lt;T> void doSmth(Class&lt;T> aClass, T value) {}</code></pre><br/>
<p>This method can be called with <code>doSmth(Runnable.class, () -> {})</code>. Then the lambda type will be inferred as <code>T</code>, substitution still required. However, this is a rare case. We can actually save some CPU time here, but only about 10%, so this doesn't solve the problem in its essence.</p><br/>
<p>Alternatively, when the precise type inference is too complicated, it can be made approximate. Unlike the specification suggests, let it work only on the erased class types and make no reduction of the set of constraints, but simply follow a call chain. As long as the erased type does not include generic parameters, everything is fine. Let's consider the stream from the example above and determine whether the last lambda implements <code>StringConsumer</code>:</p><br/>
<ul>
<li><code>list</code> variable → <code>java.util.List</code> type</li>
<li><code>List.stream()</code> method → <code>java.util.stream.Stream</code> type</li>
<li><code>Stream.filter(...)</code> method → <code>java.util.stream.Stream</code> type, we don't have to consider <code>filter</code> arguments</li>
<li>similarly, <code>Stream.map(...)</code> method → <code>java.util.stream.Stream</code> type</li>
<li><code>Stream.forEach(...)</code> method → such a method exists, its parameter has <code>Consumer</code> type, which is obviously not <code>StringConsumer</code>.</li>
</ul><br/>
<p>And that's how we could do without regular type inference. With this simple approach, however, it is easy to run into overloaded methods. If we do not perform proper type inference, we cannot choose the correct overloaded method. Sometimes it's possible, however: if methods have a different number of parameters. For example:</p><br/>
<pre><code class="java">CompletableFuture.supplyAsync(Foo::bar, myExecutor).thenRunAsync(s -> list.add(s));</code></pre><br/>
<p>Here we can see that:</p><br/>
<ul>
<li>There are two <code>CompletableFuture.supplyAsync</code> methods; the first one takes one argument and the second takes two, so we choose the second one. It returns <code>CompletableFuture</code>.</li>
<li>There are two <code>thenRunAsync</code> methods as well, and we can similarly choose the one that takes one argument. The corresponding parameter has <code>Runnable</code> type, which means it is not <code>StringConsumer</code>.</li>
</ul><br/>
<p>If several methods take the same number of parameters or have a variable number of parameters but look appropriate, we'll have to search through all the options. Often it's not that scary: </p><br/>
<pre><code class="java">new StringBuilder().append(foo).append(bar).chars().forEach(s -> list.add(s));</code></pre><br/>
<ul>
<li><code>new StringBuilder()</code> obviously creates <code>java.lang.StringBuilder</code>. For constructors, we still resolve the reference, but complex type inference is not required here. Even if there was <code>new Foo&lt;>(x, y, z)</code>, we would not infer the values of the type parameters since only <code>Foo</code> is of interest to us.</li>
<li>There are a lot of <code>StringBuilder.append</code> methods that take one argument, but they all return <code>java.lang.StringBuilder</code> type, so we do not care about the types of <code>foo</code> and <code>bar</code>.</li>
<li>There's one <code>StringBuilder.chars</code> method, and it returns <code>java.util.stream.IntStream</code>.</li>
<li>There's a single <code>IntStream.forEach</code> method, and it takes <code>IntConsumer</code> type.</li>
</ul><br/>
<p>Even if several options remain, you can still track them all. For example, the lambda type passed to <code>ForkJoinPool.getInstance().submit(...)</code> may be <code>Runnable</code> or <code>Callable</code>, and if we are looking for another option, we can still discard this lambda.</p><br/>
<p>Things get worse when the method returns a generic parameter. Then the procedure fails and you have to perform proper type inference. However, we have supported one case. It is well showcased in my StreamEx library, which has an <code>AbstractStreamEx&lt;T, S extends AbstractStreamEx&lt;T, S>></code> abstract class which contains methods like <code>S filter(Predicate&lt;? super T> predicate)</code>. Usually people work with a concrete <code>StreamEx&lt;T> extends AbstractStreamEx&lt;T, StreamEx&lt;T>></code> class. In this case, you can substitute the type parameter and find out that <code>S = StreamEx</code>.</p><br/>
<p>That's how we've got rid of the costly type inference for many cases. But we haven't done anything with the construction of PSI. It's disappointing to have parsed a file with 500 lines of code only to find out that the lambda on line 480 does not match our query. Let's get back to our stream:</p><br/>
<pre><code class="java">list.stream()
    .filter(s -> StringUtil.isNonEmpty(s))
    .map(s -> s.trim())
    .forEach(s -> list.add(s));</code></pre><br/>
<p>If <code>list</code> is a local variable, a method parameter, or a field in the current class, already at the indexing stage, we can find its declaration and establish that the short type name is <code>List</code>. Accordingly, we can put the following information into the index for the last lambda:</p><br/>
<blockquote>This lambda type is a parameter type of a <code>forEach</code> method which takes one argument, called on the result of a <code>map</code> method which takes one argument, called on the result of a <code>filter</code> method which takes one argument, called on the result of a <code>stream</code> method which takes zero arguments, called on a <code>List</code> object.</blockquote><p>All this information is available from the current file and, therefore, can be placed in the index. While searching, we request such information about all lambdas from the index and try to restore the lambda type without building a PSI. First, we'll have to perform a global search for classes with the short <code>List</code> name. Obviously, we will find not only <code>java.util.List</code> but also <code>java.awt.List</code> or something from the project code. Next, all these classes will go through the same approximate type inference procedure that we used before. Redundant classes are often quickly filtered out. For example, <code>java.awt.List</code> has no <code>stream</code> method, therefore it will be excluded. But even if something redundant remains and we find several candidates for the lambda type, chances are none of them will match the search query, and we will still avoid building a complete PSI.</p><br/>
<p>Global search could turn out to be too costly (when a project contains too many <code>List</code> classes), or the beginning of the chain could not be resolved in the context of one file (say, it's a field of а parent class), or the chain could break as the method returns a generic parameter. We won't give up and will try to start over with global search on the next method of the chain. For example, for the <code>map.get(key).updateAndGet(a -> a * 2)</code> chain, the following instruction goes to the index:</p><br/>
<blockquote>This lambda type is the type of the single parameter of an <code>updateAndGet</code> method, called on the result of a <code>get</code> method with one parameter, called on a <code>Map</code> object.</blockquote><p>Imagine we're lucky, and the project has only one <code>Map</code> type—<code>java.util.Map</code>. It does have a <code>get(Object)</code> method, but, unfortunately, it returns a generic parameter <code>V</code>. Then we'll discard the chain and look for the <code>updateAndGet</code> method with one parameter globally (using the index, of course). And we are happy to discover that there are only three such methods in the project: in <code>AtomicInteger</code>, <code>AtomicLong</code>, and <code>AtomicReference</code> classes with parameter types <code>IntUnaryOperator</code>, <code>LongUnaryOperator</code>, and <code>UnaryOperator</code>, respectively. If we are looking for any other type, we have already discovered that this lambda does not match the request, and we don't have to build the PSI.</p><br/>
<p>Surprisingly, this is a good example of a feature which works slower with time. For example, when you are looking for implementations of a functional interface and have only three of them in your project, it takes ten seconds for IntelliJ IDEA to find them. You remember that three years ago their number was the same, but the IDE provided you with the search results in just two seconds on the same machine. And though your project is huge, it has grown only by five percent over these years. It's reasonable to start grumbling about what the IDE developers have done wrong to make it so terribly slow. </p><br/>
<p>While we might have changed nothing at all. The search works just as it used to three years ago. The thing is that three years ago, you just switched to Java 8 and only had a hundred lambdas in your project. By now, your colleagues have turned anonymous classes into lambdas, have started using streams or some reactive library. As a result, instead of a hundred lambdas, there are ten thousand. And now, to find the three necessary ones, the IDE has to search through a hundred times more options.</p><br/>
<p>I said “we might” because, naturally, we get back to this search from time to time and try speeding it up. But it's like rowing up the stream, or rather up the waterfall. We try hard, but the number of lambdas in projects keeps growing very fast.</p></div></div> <!----> <!----></div> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5BIDE%5D" class="tm-tags-list__link">IDE</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bsearch%5D" class="tm-tags-list__link">search</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bprogram%20analysis%5D" class="tm-tags-list__link">program analysis</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bindexing%5D" class="tm-tags-list__link">indexing</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Blambdas%5D" class="tm-tags-list__link">lambdas</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Blambda%20expressions%5D" class="tm-tags-list__link">lambda expressions</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bjava%5D" class="tm-tags-list__link">java</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/company/JetBrains/blog/" class="tm-hubs-list__link router-link-active">
    Блог компании JetBrains
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/programming/" class="tm-hubs-list__link">
    Программирование
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/java/" class="tm-hubs-list__link">
    Java
  </a></li></ul></div></div></article></div> <!----></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_medium"><title>Всего голосов 11: ↑11 и ↓0</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-rating"></use></svg> <span title="Всего голосов 11: ↑11 и ↓0" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_medium">+11</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">5.9K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    4
  </span></button> <!----> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> </div></div> <!----> <!----> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"><div class="tm-article-author__company"><div class="tm-article-author__company-card"><div class="tm-company-snippet"><a href="/ru/company/JetBrains/profile/" class="tm-company-snippet__logo-link"><div class="tm-entity-image"><img alt="" height="40" src="//habrastorage.org/getpro/habr/company/8dc/19c/a06/8dc19ca065174d2bc9027bbd2a47f072.png" width="40" class="tm-entity-image__pic"></div></a> <div class="tm-company-snippet__info"><a href="/ru/company/JetBrains/profile/" class="tm-company-snippet__title">JetBrains</a> <div class="tm-company-snippet__description">Делаем эффективные инструменты для разработчиков</div></div></div> <div class="tm-article-author__buttons"><!----> <!----></div></div> <!----> <div class="tm-article-author__separator"></div></div> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="/ru/users/lany/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><svg class="tm-svg-img tm-image-placeholder tm-image-placeholder_blue"><!----> <use xlink:href="/img/megazord-v24.ce74655c.svg#placeholder-user"></use></svg></div></a> <div class="tm-user-card__meta"><div title=" 740 голосов " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    611.2
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">0</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title_variant-article"><span class="tm-user-card__name tm-user-card__name_variant-article">Тагир Валеев</span> <a href="/ru/users/lany/" class="tm-user-card__nickname tm-user-card__nickname_variant-article">
          @lany
        </a> <!----></div> <p class="tm-user-card__short-info tm-user-card__short-info_variant-article">Программист</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-article"><!----> <!----> <!----> <!----> <!----></div></div> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----></section> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="/ru/company/JetBrains/blog/451754/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментировать 
    </span></a> <!----></div></div></div>  <!---->  <!----> <!----></div></div></div></div></div> <div class="tm-page__sidebar"><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__placeholder_initial"></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----> <section class="tm-block tm-block_spacing-bottom"><header class="tm-block__header"><h2 class="tm-block__title">Информация</h2> <!----></header> <div class="tm-block__body"><div class="tm-company-basic-info"><dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Дата основания</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><time datetime="2000-01-31T21:00:00.000Z" title="2000-02-01, 00:00">1  февраля  2000</time></dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Местоположение</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap">
    Россия
  </dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Сайт</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><a href="http://jetbrains.com/ru-ru" target="_blank" class="tm-company-basic-info__link">
      jetbrains.com
    </a></dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Численность</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap">
    1 001–5 000 человек
  </dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Дата регистрации</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><time datetime="2008-12-02T12:00:08.000Z" title="2008-12-02, 15:00">2  декабря  2008</time></dd></dl> <!----></div></div> <!----></section> <div class="tm-company-widgets"></div> <!----></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/company/JetBrains/blog/451754/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/company/JetBrains/blog/451754/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2021 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"451754":{"id":"451754","timePublished":"2019-05-14T09:50:29+00:00","isCorporative":true,"lang":"en","titleHtml":"How We Find Lambda Expressions in IntelliJ IDEA","leadData":{"textHtml":"\u003Cp\u003E\u003Cimg alt=\"Type Hierarchy in IntelliJ IDEA\" src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fff\u002Fjs\u002F7m\u002Fffjs7m9ycsved2ciyrqdvb4uiwe.png\" align=\"right\" width=\"300\"\u003ECode search and navigation are important features of any IDE. In Java, one of the commonly used search options is searching for all implementations of an interface. This feature is often called Type Hierarchy, and it looks just like the image on the right.\u003C\u002Fp\u003E\u003Cbr\u003E\r\n\u003Cp\u003EIt's inefficient to iterate over all project classes when this feature is invoked. One option is to save the complete class hierarchy in the index during compilation since the compiler builds it anyway. We do this when the compilation is run by the IDE and not delegated, for example, to Gradle. But this works only if nothing has been changed in the module after the compilation. In general, the source code is the most up-to-date information provider, and indexes are based on the source code.\u003C\u002Fp\u003E\u003Cbr\u003E\r\n\u003Cp\u003EFinding immediate children is a simple task if we are not dealing with a functional interface. When searching for implementations of the \u003Ccode\u003EFoo\u003C\u002Fcode\u003E interface, we need to find all the classes that have \u003Ccode\u003Eimplements Foo\u003C\u002Fcode\u003E and interfaces that have \u003Ccode\u003Eextends Foo\u003C\u002Fcode\u003E, as well as \u003Ccode\u003Enew Foo(...) {...}\u003C\u002Fcode\u003E anonymous classes. To do this, it is enough to build a syntax tree of each project file in advance, find the corresponding constructs, and add them to an index. \u003C\u002Fp\u003E","imageUrl":null,"buttonTextHtml":"Read more →","image":null},"editorVersion":"1.0","postType":"article","postLabels":[{"type":"translation","data":{"originalAuthorName":"Tagir Valeev","originalUrl":"https:\u002F\u002Fhabr.com\u002Fru\u002Fcompany\u002FJetBrains\u002Fblog\u002F444052\u002F"}}],"author":{"scoreStats":{"score":611.2,"votesCount":740},"rating":0,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"20275","alias":"lany","fullname":"Тагир Валеев","avatarUrl":null,"speciality":"Программист"},"statistics":{"commentsCount":0,"favoritesCount":4,"readingCount":5903,"score":11,"votesCount":11},"hubs":[{"relatedData":null,"id":"7575","alias":"JetBrains","type":"corporative","title":"Блог компании JetBrains","titleHtml":"Блог компании JetBrains","isProfiled":false},{"relatedData":null,"id":"359","alias":"programming","type":"collective","title":"Программирование","titleHtml":"Программирование","isProfiled":true},{"relatedData":null,"id":"375","alias":"java","type":"collective","title":"Java","titleHtml":"Java","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Cp\u003E\u003Cimg alt=\"Type Hierarchy in IntelliJ IDEA\" src=\"\u002Fimg\u002Fimage-loader.svg\" align=\"right\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fff\u002Fjs\u002F7m\u002Fffjs7m9ycsved2ciyrqdvb4uiwe.png\" data-width=\"300\"\u002F\u003ECode search and navigation are important features of any IDE. In Java, one of the commonly used search options is searching for all implementations of an interface. This feature is often called Type Hierarchy, and it looks just like the image on the right.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EIt's inefficient to iterate over all project classes when this feature is invoked. One option is to save the complete class hierarchy in the index during compilation since the compiler builds it anyway. We do this when the compilation is run by the IDE and not delegated, for example, to Gradle. But this works only if nothing has been changed in the module after the compilation. In general, the source code is the most up-to-date information provider, and indexes are based on the source code.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EFinding immediate children is a simple task if we are not dealing with a functional interface. When searching for implementations of the \u003Ccode\u003EFoo\u003C\u002Fcode\u003E interface, we need to find all the classes that have \u003Ccode\u003Eimplements Foo\u003C\u002Fcode\u003E and interfaces that have \u003Ccode\u003Eextends Foo\u003C\u002Fcode\u003E, as well as \u003Ccode\u003Enew Foo(...) {...}\u003C\u002Fcode\u003E anonymous classes. To do this, it is enough to build a syntax tree of each project file in advance, find the corresponding constructs, and add them to an index. \u003Ca name=\"habracut\"\u003E\u003C\u002Fa\u003EThere is, however, an intricacy here: you might be looking for the \u003Ccode\u003Ecom.example.goodcompany.Foo\u003C\u002Fcode\u003E interface, while \u003Ccode\u003Eorg.example.evilcompany.Foo\u003C\u002Fcode\u003E is actually used. Can we put the full name of the parent interface into the index in advance? It can be tricky. For example, the file where the interface is used may look like this:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003E\u002F\u002F MyFoo.java\nimport org.example.foo.*;\nimport org.example.bar.*;\nimport org.example.evilcompany.*;\n\nclass MyFoo implements Foo {...}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EBy looking at the file alone, it's impossible to tell what the actual fully qualified name of \u003Ccode\u003EFoo\u003C\u002Fcode\u003E is. We'll have to look into the content of several packages. And each package can be defined in several places in the project (for example, in several JAR files). If we perform proper symbol resolution when analyzing this file, indexing will take a lot of time. But the main problem is that the index built on \u003Ccode\u003EMyFoo.java\u003C\u002Fcode\u003E will depend on other files as well. We can move the declaration of the \u003Ccode\u003EFoo\u003C\u002Fcode\u003E interface, for example, from the \u003Ccode\u003Eorg.example.foo\u003C\u002Fcode\u003E package to the \u003Ccode\u003Eorg.example.bar\u003C\u002Fcode\u003E package, without changing anything in the \u003Ccode\u003EMyFoo.java\u003C\u002Fcode\u003E file, but the fully qualified name of \u003Ccode\u003EFoo\u003C\u002Fcode\u003E will change.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EIn IntelliJ IDEA, indexes depend only on the content of a single file. On the one hand, it is very convenient: the index associated with a specific file becomes invalid when the file is changed. On the other hand, it imposes major restrictions on what can be put into the index. For example, it does not allow the fully qualified names of parent classes to be saved reliably in the index. But, in general, it's not that bad. When requesting a type hierarchy, we can find everything that matches our request by a short name, and then perform the proper symbol resolution for these files and determine whether that's what we are looking for. In most cases, there won't be too many redundant symbols and the check won't take long.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg alt=\"Functional interface hierarchy in IntelliJ IDEA\" src=\"\u002Fimg\u002Fimage-loader.svg\" align=\"right\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fe-\u002Fnn\u002F0y\u002Fe-nn0ynvtojiydboaco5uiyzwms.png\" data-width=\"300\"\u002F\u003EThings change, however, when the class whose children we are looking for is a functional interface. Then, in addition to the explicit and anonymous subclasses, there'll be lambda expressions and method references. What do we put into the index now, and what is to be evaluated during the search?\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003ELet's assume we have a functional interface:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003E@FunctionalInterface\npublic interface StringConsumer {\n  void consume(String s);\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EThe code contains different lambda expressions. For instance:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003E() -\u003E {} \u002F\u002F a certain mismatch: no parameters\n(a, b) -\u003E a + b \u002F\u002F a certain mismatch: two parameters\ns -\u003E {\n  return list.add(s); \u002F\u002F a certain mismatch: a value is returned\n}\ns -\u003E list.add(s); \u002F\u002F a potential match\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EIt means we can quickly filter out lambdas that have an inappropriate number of parameters or a clearly inappropriate return type, for example, void instead of non-void. It is usually impossible to determine the return type more precisely. For instance, in \u003Ccode\u003Es -\u003E list.add(s)\u003C\u002Fcode\u003E you will have to resolve \u003Ccode\u003Elist\u003C\u002Fcode\u003E and \u003Ccode\u003Eadd\u003C\u002Fcode\u003E, and, possibly, run a regular type inference procedure. It takes time and depends on the content of other files.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EWe’re lucky if the functional interface takes five arguments. But if it only takes one, the filter will keep a huge number of unnecessary lambdas. It's even worse when it gets to method references. By the way it looks, one cannot tell whether a method reference is suitable or not.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003ETo get things straight, it might be worth looking at what surrounds the lambda. Sometimes, it works. For instance:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003E\u002F\u002F declaration of a local variable or a field of different type\nPredicate&lt;String\u003E p = s -\u003E list.add(s);\n\n\u002F\u002F a different return type\nIntPredicate getPredicate() {\n  return s -\u003E list.add(s);\n}\n\n\u002F\u002F assignment to a variable of a different type\nSomeType fn;\nfn = s -\u003E list.add(s);\n\n\u002F\u002F cast to a different type\nfoo((SomeFunctionalType)(s -\u003E list.add(s)));\n\n\u002F\u002F declaration of a different type array\nFoo[] myLambdas = {s -\u003E list.add(s), s -\u003E list.remove(s)};\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EIn all these cases, the short name of the corresponding functional interface can be determined from the current file and can be put into the index next to the functional expression, be it a lambda or a method reference. Unfortunately, in real-life projects, these cases cover a very small percentage of all lambdas. In most cases, lambdas are used as method arguments:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003Elist.stream()\n    .filter(s -\u003E StringUtil.isNonEmpty(s))\n    .map(s -\u003E s.trim())\n    .forEach(s -\u003E list.add(s));\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EWhich of the three lambdas can contain \u003Ccode\u003EStringConsumer\u003C\u002Fcode\u003E? Obviously, none. Here we have a Stream API chain that only features functional interfaces from the standard library, it can't have the custom type.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EHowever, the IDE should be able to see through the trick and give us an exact answer. What if \u003Ccode\u003Elist\u003C\u002Fcode\u003E is not exactly \u003Ccode\u003Ejava.util.List\u003C\u002Fcode\u003E, and \u003Ccode\u003Elist.stream()\u003C\u002Fcode\u003E returns something different from \u003Ccode\u003Ejava.util.stream.Stream\u003C\u002Fcode\u003E? Then we'll have to resolve \u003Ccode\u003Elist\u003C\u002Fcode\u003E, which, as we know, cannot be reliably done based only on the content of the current file. And even if we do, the search should not rely on the implementation of the standard library. What if in this particular project we have replaced \u003Ccode\u003Ejava.util.List\u003C\u002Fcode\u003E with a class of our own? The search must take this into account. And, naturally, lambdas are used not only in standard streams: there are many other methods to which they are passed.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EAs a result, we can query the index for a list of all Java files that use lambdas with the required number of parameters and a valid return type (in fact, we only search for four options: void, non-void, boolean, and any). And what's next? Do we need to build a complete PSI tree (a kind of a parse tree with symbol resolution, type inference, and other smart features) for each of these files and perform proper type inference for lambdas? For a big project, it will take ages to get the list of all interface implementations, even if there are only two of them.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003ESo, we need to take the following steps:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EAsk index (not costly)\u003C\u002Fli\u003E\r\n\u003Cli\u003EBuild PSI (costly)\u003C\u002Fli\u003E\r\n\u003Cli\u003EInfer lambda type (very costly)\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EFor Java 8 and later, type inference is an extremely costly operation. In a complex call chain, there might be many substitutional generic parameters, the values of which have to be determined using the hard-hitting procedure described in \u003Ca href=\"https:\u002F\u002Fdocs.oracle.com\u002Fjavase\u002Fspecs\u002Fjls\u002Fse8\u002Fhtml\u002Fjls-18.html\"\u003EChapter 18\u003C\u002Fa\u003E of the specification. For the current file, this can be done in the background, but processing thousands of unopened files this way would be an expensive task.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EHere, however, it is possible to slightly cut corners: in most cases, we don’t need the concrete type. Unless a method accepts a generic parameter where the lambda is passed to it, the final parameter substitution step can be avoided. If we have inferred the \u003Ccode\u003Ejava.util.function.Function&lt;T, R\u003E\u003C\u002Fcode\u003E lambda type, we don't have to evaluate the values of the substitutional parameters \u003Ccode\u003ET\u003C\u002Fcode\u003E and \u003Ccode\u003ER\u003C\u002Fcode\u003E: it is already clear whether to include the lambda into search results or not. However, it won't work for a method like this:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003Estatic &lt;T\u003E void doSmth(Class&lt;T\u003E aClass, T value) {}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EThis method can be called with \u003Ccode\u003EdoSmth(Runnable.class, () -\u003E {})\u003C\u002Fcode\u003E. Then the lambda type will be inferred as \u003Ccode\u003ET\u003C\u002Fcode\u003E, substitution still required. However, this is a rare case. We can actually save some CPU time here, but only about 10%, so this doesn't solve the problem in its essence.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EAlternatively, when the precise type inference is too complicated, it can be made approximate. Unlike the specification suggests, let it work only on the erased class types and make no reduction of the set of constraints, but simply follow a call chain. As long as the erased type does not include generic parameters, everything is fine. Let's consider the stream from the example above and determine whether the last lambda implements \u003Ccode\u003EStringConsumer\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ccode\u003Elist\u003C\u002Fcode\u003E variable → \u003Ccode\u003Ejava.util.List\u003C\u002Fcode\u003E type\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003EList.stream()\u003C\u002Fcode\u003E method → \u003Ccode\u003Ejava.util.stream.Stream\u003C\u002Fcode\u003E type\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003EStream.filter(...)\u003C\u002Fcode\u003E method → \u003Ccode\u003Ejava.util.stream.Stream\u003C\u002Fcode\u003E type, we don't have to consider \u003Ccode\u003Efilter\u003C\u002Fcode\u003E arguments\u003C\u002Fli\u003E\r\n\u003Cli\u003Esimilarly, \u003Ccode\u003EStream.map(...)\u003C\u002Fcode\u003E method → \u003Ccode\u003Ejava.util.stream.Stream\u003C\u002Fcode\u003E type\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003EStream.forEach(...)\u003C\u002Fcode\u003E method → such a method exists, its parameter has \u003Ccode\u003EConsumer\u003C\u002Fcode\u003E type, which is obviously not \u003Ccode\u003EStringConsumer\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EAnd that's how we could do without regular type inference. With this simple approach, however, it is easy to run into overloaded methods. If we do not perform proper type inference, we cannot choose the correct overloaded method. Sometimes it's possible, however: if methods have a different number of parameters. For example:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003ECompletableFuture.supplyAsync(Foo::bar, myExecutor).thenRunAsync(s -\u003E list.add(s));\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EHere we can see that:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EThere are two \u003Ccode\u003ECompletableFuture.supplyAsync\u003C\u002Fcode\u003E methods; the first one takes one argument and the second takes two, so we choose the second one. It returns \u003Ccode\u003ECompletableFuture\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\r\n\u003Cli\u003EThere are two \u003Ccode\u003EthenRunAsync\u003C\u002Fcode\u003E methods as well, and we can similarly choose the one that takes one argument. The corresponding parameter has \u003Ccode\u003ERunnable\u003C\u002Fcode\u003E type, which means it is not \u003Ccode\u003EStringConsumer\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EIf several methods take the same number of parameters or have a variable number of parameters but look appropriate, we'll have to search through all the options. Often it's not that scary: \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003Enew StringBuilder().append(foo).append(bar).chars().forEach(s -\u003E list.add(s));\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ccode\u003Enew StringBuilder()\u003C\u002Fcode\u003E obviously creates \u003Ccode\u003Ejava.lang.StringBuilder\u003C\u002Fcode\u003E. For constructors, we still resolve the reference, but complex type inference is not required here. Even if there was \u003Ccode\u003Enew Foo&lt;\u003E(x, y, z)\u003C\u002Fcode\u003E, we would not infer the values of the type parameters since only \u003Ccode\u003EFoo\u003C\u002Fcode\u003E is of interest to us.\u003C\u002Fli\u003E\r\n\u003Cli\u003EThere are a lot of \u003Ccode\u003EStringBuilder.append\u003C\u002Fcode\u003E methods that take one argument, but they all return \u003Ccode\u003Ejava.lang.StringBuilder\u003C\u002Fcode\u003E type, so we do not care about the types of \u003Ccode\u003Efoo\u003C\u002Fcode\u003E and \u003Ccode\u003Ebar\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\r\n\u003Cli\u003EThere's one \u003Ccode\u003EStringBuilder.chars\u003C\u002Fcode\u003E method, and it returns \u003Ccode\u003Ejava.util.stream.IntStream\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\r\n\u003Cli\u003EThere's a single \u003Ccode\u003EIntStream.forEach\u003C\u002Fcode\u003E method, and it takes \u003Ccode\u003EIntConsumer\u003C\u002Fcode\u003E type.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EEven if several options remain, you can still track them all. For example, the lambda type passed to \u003Ccode\u003EForkJoinPool.getInstance().submit(...)\u003C\u002Fcode\u003E may be \u003Ccode\u003ERunnable\u003C\u002Fcode\u003E or \u003Ccode\u003ECallable\u003C\u002Fcode\u003E, and if we are looking for another option, we can still discard this lambda.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EThings get worse when the method returns a generic parameter. Then the procedure fails and you have to perform proper type inference. However, we have supported one case. It is well showcased in my StreamEx library, which has an \u003Ccode\u003EAbstractStreamEx&lt;T, S extends AbstractStreamEx&lt;T, S\u003E\u003E\u003C\u002Fcode\u003E abstract class which contains methods like \u003Ccode\u003ES filter(Predicate&lt;? super T\u003E predicate)\u003C\u002Fcode\u003E. Usually people work with a concrete \u003Ccode\u003EStreamEx&lt;T\u003E extends AbstractStreamEx&lt;T, StreamEx&lt;T\u003E\u003E\u003C\u002Fcode\u003E class. In this case, you can substitute the type parameter and find out that \u003Ccode\u003ES = StreamEx\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EThat's how we've got rid of the costly type inference for many cases. But we haven't done anything with the construction of PSI. It's disappointing to have parsed a file with 500 lines of code only to find out that the lambda on line 480 does not match our query. Let's get back to our stream:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003Elist.stream()\n    .filter(s -\u003E StringUtil.isNonEmpty(s))\n    .map(s -\u003E s.trim())\n    .forEach(s -\u003E list.add(s));\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EIf \u003Ccode\u003Elist\u003C\u002Fcode\u003E is a local variable, a method parameter, or a field in the current class, already at the indexing stage, we can find its declaration and establish that the short type name is \u003Ccode\u003EList\u003C\u002Fcode\u003E. Accordingly, we can put the following information into the index for the last lambda:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003EThis lambda type is a parameter type of a \u003Ccode\u003EforEach\u003C\u002Fcode\u003E method which takes one argument, called on the result of a \u003Ccode\u003Emap\u003C\u002Fcode\u003E method which takes one argument, called on the result of a \u003Ccode\u003Efilter\u003C\u002Fcode\u003E method which takes one argument, called on the result of a \u003Ccode\u003Estream\u003C\u002Fcode\u003E method which takes zero arguments, called on a \u003Ccode\u003EList\u003C\u002Fcode\u003E object.\u003C\u002Fblockquote\u003E\u003Cp\u003EAll this information is available from the current file and, therefore, can be placed in the index. While searching, we request such information about all lambdas from the index and try to restore the lambda type without building a PSI. First, we'll have to perform a global search for classes with the short \u003Ccode\u003EList\u003C\u002Fcode\u003E name. Obviously, we will find not only \u003Ccode\u003Ejava.util.List\u003C\u002Fcode\u003E but also \u003Ccode\u003Ejava.awt.List\u003C\u002Fcode\u003E or something from the project code. Next, all these classes will go through the same approximate type inference procedure that we used before. Redundant classes are often quickly filtered out. For example, \u003Ccode\u003Ejava.awt.List\u003C\u002Fcode\u003E has no \u003Ccode\u003Estream\u003C\u002Fcode\u003E method, therefore it will be excluded. But even if something redundant remains and we find several candidates for the lambda type, chances are none of them will match the search query, and we will still avoid building a complete PSI.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EGlobal search could turn out to be too costly (when a project contains too many \u003Ccode\u003EList\u003C\u002Fcode\u003E classes), or the beginning of the chain could not be resolved in the context of one file (say, it's a field of а parent class), or the chain could break as the method returns a generic parameter. We won't give up and will try to start over with global search on the next method of the chain. For example, for the \u003Ccode\u003Emap.get(key).updateAndGet(a -\u003E a * 2)\u003C\u002Fcode\u003E chain, the following instruction goes to the index:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003EThis lambda type is the type of the single parameter of an \u003Ccode\u003EupdateAndGet\u003C\u002Fcode\u003E method, called on the result of a \u003Ccode\u003Eget\u003C\u002Fcode\u003E method with one parameter, called on a \u003Ccode\u003EMap\u003C\u002Fcode\u003E object.\u003C\u002Fblockquote\u003E\u003Cp\u003EImagine we're lucky, and the project has only one \u003Ccode\u003EMap\u003C\u002Fcode\u003E type—\u003Ccode\u003Ejava.util.Map\u003C\u002Fcode\u003E. It does have a \u003Ccode\u003Eget(Object)\u003C\u002Fcode\u003E method, but, unfortunately, it returns a generic parameter \u003Ccode\u003EV\u003C\u002Fcode\u003E. Then we'll discard the chain and look for the \u003Ccode\u003EupdateAndGet\u003C\u002Fcode\u003E method with one parameter globally (using the index, of course). And we are happy to discover that there are only three such methods in the project: in \u003Ccode\u003EAtomicInteger\u003C\u002Fcode\u003E, \u003Ccode\u003EAtomicLong\u003C\u002Fcode\u003E, and \u003Ccode\u003EAtomicReference\u003C\u002Fcode\u003E classes with parameter types \u003Ccode\u003EIntUnaryOperator\u003C\u002Fcode\u003E, \u003Ccode\u003ELongUnaryOperator\u003C\u002Fcode\u003E, and \u003Ccode\u003EUnaryOperator\u003C\u002Fcode\u003E, respectively. If we are looking for any other type, we have already discovered that this lambda does not match the request, and we don't have to build the PSI.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003ESurprisingly, this is a good example of a feature which works slower with time. For example, when you are looking for implementations of a functional interface and have only three of them in your project, it takes ten seconds for IntelliJ IDEA to find them. You remember that three years ago their number was the same, but the IDE provided you with the search results in just two seconds on the same machine. And though your project is huge, it has grown only by five percent over these years. It's reasonable to start grumbling about what the IDE developers have done wrong to make it so terribly slow. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EWhile we might have changed nothing at all. The search works just as it used to three years ago. The thing is that three years ago, you just switched to Java 8 and only had a hundred lambdas in your project. By now, your colleagues have turned anonymous classes into lambdas, have started using streams or some reactive library. As a result, instead of a hundred lambdas, there are ten thousand. And now, to find the three necessary ones, the IDE has to search through a hundred times more options.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EI said “we might” because, naturally, we get back to this search from time to time and try speeding it up. But it's like rowing up the stream, or rather up the waterfall. We try hard, but the number of lambdas in projects keeps growing very fast.\u003C\u002Fp\u003E\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"IDE"},{"titleHtml":"search"},{"titleHtml":"program analysis"},{"titleHtml":"indexing"},{"titleHtml":"lambdas"},{"titleHtml":"lambda expressions"},{"titleHtml":"java"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F451754\u002Fb25ed51433a925cd292a361158856dde\u002F","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F451754\u002Fb25ed51433a925cd292a361158856dde\u002F?format=vk","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fen\\\u002Fcompany\\\u002FJetBrains\\\u002Fblog\\\u002F451754\\\u002F\"},\"headline\":\"How We Find Lambda Expressions in IntelliJ IDEA\",\"datePublished\":\"2019-05-14T12:50:29+03:00\",\"dateModified\":\"2019-05-14T15:42:08+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"Тагир Валеев\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"Code search and navigation are important features of any IDE. In Java, one of the commonly used search options is searching for all implementations of an...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fen\\\u002Fcompany\\\u002FJetBrains\\\u002Fblog\\\u002F451754\\\u002F#post-content-body\",\"about\":[\"c_JetBrains\",\"h_programming\",\"h_java\",\"f_develop\"],\"image\":[\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fff\\\u002Fjs\\\u002F7m\\\u002Fffjs7m9ycsved2ciyrqdvb4uiwe.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fe-\\\u002Fnn\\\u002F0y\\\u002Fe-nn0ynvtojiydboaco5uiyzwms.png\"]}","metaDescription":"Code search and navigation are important features of any IDE. In Java, one of the commonly used search options is searching for all implementations of an interface. This feature is often called Type...","mainImageUrl":null,"amp":false},"polls":[],"commentsEnabled":true,"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":false}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[],"hubs":""},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{"jetbrains":{"alias":"JetBrains","imageUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fcompany\u002F8dc\u002F19c\u002Fa06\u002F8dc19ca065174d2bc9027bbd2a47f072.png","titleHtml":"JetBrains","descriptionHtml":"Делаем эффективные инструменты для разработчиков","relatedData":null,"statistics":{"postsCount":411,"newsCount":6,"vacanciesCount":1,"employeesCount":88,"careerRating":null,"subscribersCount":69579,"rating":185.01,"invest":null},"foundationDate":{"year":"2000","month":"02","day":"01"},"location":{"city":{"id":"447733","title":"Санкт-Петербург"},"region":{"id":"1948","title":"Санкт-Петербург и область"},"country":{"id":"168","title":"Россия"}},"siteUrl":"http:\u002F\u002Fjetbrains.com\u002Fru-ru","staffNumber":"1 001–5 000 человек","registrationDate":"2008-12-02T12:00:08+00:00","representativeUser":null,"contacts":[],"settings":{"analyticsSettings":[{"type":"ym","trackingId":"83712025"}],"branding":{"imageUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fbranding\u002F2e8\u002Fd41\u002Fb77\u002F2e8d41b772b3231a100471e973e90c6d.png","linkUrl":"https:\u002F\u002Fwww.jetbrains.com\u002Fru-ru\u002F","pixelUrl":""},"status":"active"},"metadata":{"titleHtml":"JetBrains, Санкт-Петербург - Делаем эффективные инструменты для разработчиков с 1 февраля 2000 г.","title":"JetBrains, Санкт-Петербург - Делаем эффективные инструменты для разработчиков с 1 февраля 2000 г.","keywords":["Программирование","Машинное обучение","Управление проектами","Управление разработкой","Kotlin","c++","pvs-studio","c","с++","статический анализ кода","программирование","open source","си++","c++17","qt","static code analysis","c++11","c++20","c++14","си","opengl","перевод","c#","компиляторы","clang"],"descriptionHtml":"411 статей от авторов компании JetBrains","description":"411 статей от авторов компании JetBrains"},"aDeskSettings":null,"careerAlias":"jetbrains","maxCustomTrackerLinks":3}},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{}},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"dfp":{"slotsDict":{}},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.c0af73e7.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
</body>
</html>
