<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <title>Случайные числа и децентрализованные сети: имплементации / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.c0af73e7.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.85eb77f0b17c8235e7b64b9f81ea5ec2.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" src="/js/ads.js" onload="window['zhY4i4nJ9K'] = true" data-vmid="checkad"></script><script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/post\/452340\/"},"headline":"Случайные числа и децентрализованные сети: имплементации","datePublished":"2019-05-17T16:47:43+03:00","dateModified":"2019-05-17T18:37:59+03:00","author":{"@type":"Person","name":"Сергей Прилуцкий"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"Введение function getAbsolutelyRandomNumer() {         return 4; \/\/ returns absolutely random number! } Как и в случае с концепцией абсолютно стойкого шифра из к...","url":"https:\/\/habr.com\/ru\/post\/452340\/#post-content-body","about":["h_p2p","h_infosecurity","h_crypto","h_algorithms","f_develop","f_admin"],"image":["https:\/\/habr.com\/share\/publication\/452340\/11164206129fceeebb4b1e57f0042a9b\/"]}</script>
  <script src="//www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.49.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_eng"><meta data-vue-meta="ssr" property="og:title" content="Случайные числа и децентрализованные сети: имплементации" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="Случайные числа и децентрализованные сети: имплементации" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="Случайные числа и децентрализованные сети: имплементации" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="Введение
function getAbsolutelyRandomNumer() {
        return 4; // returns absolutely random number!
}
Как и в случае с концепцией абсолютно стойкого шифра из криптографии, реальные протоколы..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="Введение
function getAbsolutelyRandomNumer() {
        return 4; // returns absolutely random number!
}
Как и в случае с концепцией абсолютно стойкого шифра из криптографии, реальные протоколы..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="Введение
function getAbsolutelyRandomNumer() {
        return 4; // returns absolutely random number!
}
Как и в случае с концепцией абсолютно стойкого шифра из криптографии, реальные протоколы..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="Введение
function getAbsolutelyRandomNumer() {
        return 4; // returns absolutely random number!
}
Как и в случае с концепцией абсолютно стойкого шифра из криптографии, реальные протоколы..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="Введение
function getAbsolutelyRandomNumer() {
        return 4; // returns absolutely random number!
}
Как и в случае с концепцией абсолютно стойкого шифра из криптографии, реальные протоколы..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habr.com/share/publication/452340/11164206129fceeebb4b1e57f0042a9b/" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habr.com/share/publication/452340/11164206129fceeebb4b1e57f0042a9b/" data-vmid="og:image"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habr.com/share/publication/452340/11164206129fceeebb4b1e57f0042a9b/" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habr.com/share/publication/452340/11164206129fceeebb4b1e57f0042a9b/" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habr.com/share/publication/452340/11164206129fceeebb4b1e57f0042a9b/" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="452340" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2019-05-17T13:47:43.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/452340/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="https://habr.com/ru/post/452340/" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habr.com/share/publication/452340/11164206129fceeebb4b1e57f0042a9b/" data-vmid="image:href">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="/ru/sandbox/start/" class="tm-header__become-author-btn">
            Как стать автором
          </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="/ru/all/" class="tm-main-menu__item">
        Все потоки
      </a> <a href="/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" data-async-called="true" class="tm-page"><div class="tm-page-width"><!----> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="/ru/users/BoogerWooger/" title="BoogerWooger" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="" height="24" loading="lazy" src="//habrastorage.org/r/w32/getpro/habr/avatars/100/f80/86a/100f8086a32f1a1e3c582b6b4f9c61d0.png" width="24" class="tm-entity-image__pic"></div></a> <span class="tm-user-info__user"><a href="/ru/users/BoogerWooger/" class="tm-user-info__username">
      BoogerWooger
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2019-05-17T13:47:43.000Z" title="2019-05-17, 16:47">17  мая  2019 в 16:47</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>Случайные числа и децентрализованные сети: имплементации</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/p2p/" class="tm-article-snippet__hubs-item-link"><span>Децентрализованные сети</span> <!----></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/infosecurity/" class="tm-article-snippet__hubs-item-link"><span>Информационная безопасность</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/crypto/" class="tm-article-snippet__hubs-item-link"><span>Криптография</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/algorithms/" class="tm-article-snippet__hubs-item-link"><span>Алгоритмы</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span></div> <!----> <!----> <!----></div></div> <!----> <div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-1"><div xmlns="http://www.w3.org/1999/xhtml"><h1 id="vvedenie">Введение</h1><br/>
<pre><code class="plaintext">function getAbsolutelyRandomNumer() {
        return 4; // returns absolutely random number!
}</code></pre><br/>
<p>Как и в случае с концепцией абсолютно стойкого шифра из криптографии, реальные протоколы “Publicly Verifiable Random Beacon” (далее PVRB) лишь пытаются максимально приблизиться к идеальной схеме, т.к. в реальных сетях в чистом виде она неприменима: договариваться надо строго об одном бите, раундов должно быть много, а все сообщения должны быть идеально быстрыми и всегда доставляться. Разумеется, в реальных сетях это не так. Поэтому, при проектировании PVRB под конкретные задачи в современных блокчейнах, помимо невозможности контроля получаемого рандома и криптографической стойкости, возникает еще много чисто архитектурных и технических проблем.</p><a name="habracut"></a><br/>
<p>Сам блокчейн является для PVRB по сути средой для коммуникации, в которой сообщения=транзакции. Это позволяет частично абстрагироваться от сетевых проблем, недоставки сообщений, проблем промежуточного софта — все эти риски принимает на себя децентрализованная сеть, и, главная ее ценность для PVRB — невозможность отозвать или испортить уже отправленную транзакцию — это не позволяет участникам отказаться от участия в протоколе, если только они не провели успешную атаку на консенсус. Такой уровень безопасности приемлем, поэтому PVRB должен быть устойчив к сговорам участникам ровно в той же мере, что и основная цепочка блокчейна. Также, это намекает, что PVRB должен быть частью консенсуса, если сеть договорилась насчет основной цепочки блоков, пускай одновременно она договорится и о единственном честном результирующем рандоме. Либо, PVRB — это просто standalone протокол, реализованный смарт-контрактом, работающий асинхронно по отношению к блокчейну и блокам. У обоих способов есть свои преимущества и недостатки, и выбор между ними крайне нетривиален. </p><br/>
<h2 id="dva-sposoba-implementacii-pvrb">Два способа имплементации PVRB</h2><br/>
<p>Опишем подробнее два варианта имплементации PVRB — standalone версию, работающую с использованием независимого от блокчейна смарт-контракта, и consensus-integrated — встроенную в протокол, согласно которому сеть договаривается о цепочке блоков и включаемых транзакциях. Во всех случаях я буду иметь в виду популярные блокчейн-движки: Ethereum, EOS, и все, похожие на них по способу размещения и процессинга смарт-контрактов. </p><br/>
<h3 id="standalone-contract">Standalone contract</h3><br/>
<p>В этом варианте PVRB представляет собой смарт-контракт, который принимает транзакции random-producer-ов (далее RP), обрабатывает их, комбинирует результаты, и, в результате, приходит к некоторому значению, которое может получить любой пользователь из этого контракта. Это значение может не храниться в контракте напрямую, а быть представлено только данными, из которых можно детерминировано получить одно и только одно значение результирующего рандома. В этой схеме RP — пользователи блокчейна, и участвовать в процессе генерации можно позволить кому угодно.</p><br/>
<p>Вариант со standalone-contract хорош:</p><br/>
<ul>
<li>переносимостью (контракты можно таскать из блокчейна в блокчейн)</li>
<li>простотой в реализации и тестировании (контракты удобно писать и тестировать)</li>
<li>удобством в реализации экономических схем (легко сделать свой токен, чья логика служит целям PVRB)</li>
<li>возможностью запуска в уже работающих блокчейнах</li>
</ul><br/>
<p>Он же имеет и недостатки:</p><br/>
<ul>
<li>сильные ограничения на ресурсы при вычислениях, объем транзакций и storage (проще говоря cpu/mem/io)</li>
<li>ограничения на операции внутри контракта (не все инструкции доступны, сложно подключать внешние библиотеки)</li>
<li>невозможность организовать обмен сообщениями быстрее, чем транзакции включаются в блокчейн</li>
</ul><br/>
<p>Этот вариант годится для реализации PVRB, который необходимо запустить в уже существующей сети, не содержащий сложную криптографию и не требующий большого количества взаимодействий.</p><br/>
<h3 id="consensus-integrated">Consensus-integrated</h3><br/>
<p>В этом варианте PVRB реализован в коде блокчейн-ноды, встроен или работает параллельно с обменом сообщений между нодами блокчейна. Результаты протокола записываются прямо в производимые блоки, а сообщения протокола отправляются по p2p сети между нодами. Так как протокол имеет результатом числа, которые должны быть записаны в блоках, сеть должна прийти к консенсусу относительно них. Значит сообщения PVRB, как и транзакции должны валидироваться нодами, и включаться в блоки, чтобы любой участник сети мог бы провалидировать соблюдение протокола PVRB. Это автоматически ведет нас к очевидному решению — если сеть договаривается в консенсусе насчет блока и транзакций в нем, то PVRB должен быть частью консенсуса, а не отдельно стоящим протоколом. Иначе возможна ситуация, когда блок является валидным с точки зрения консенсуса, но протокол PVRB не соблюден, и с точки зрения PVRB блок не может быть принят. Так что если выбран “consensus-integrated” вариант, PVRB становится важной частью консенсуса.</p><br/>
<p>Описывая имплементации PVRB на уровне консенсуса в сети, ни в коем случае нельзя обойти вопросы финальности. Финальность — это механизм, используемый в детерминированных консенсусах, фиксирующий блок (и цепочку, ведущую к нему), который является финальным, и никогда не будет выброшен, даже если появится параллельный форк. Например, в Bitcoin такого механизма нет — если опубликовать цепочку большей сложности, она заменит любую менее сложную, вне зависимости от длины цепочек. А в EOS, например, финальными являются так называемые Last Irreversible Blocks, которые появляются в среднем каждые 432 блока (12*21 + 12*15, pre-vote + pre-commit). Этот процесс — по сути ожидание 2/3 подписей block-producers (далее BP). При появлении форков, которые старше чем последний LIB они просто отбрасываются. Этот механизм позволяет гарантированно утверждать, что транзакция включена в блокчейн и никогда не будет откачена, какими бы ресурсами не обладал атакующий. Также, финальными блоками являются блоки, подписанные 2/3 BP в Hyperledger, Tendermint и других pBFT-based консенсусах. Также, протокол для обеспечения финальности имеет смысл делать надстройкой над консенсусом, так как он может работать асинхронно с производством и публикацией блоков. Вот хорошая <a href="https://arxiv.org/pdf/1710.09437.pdf">статья</a> про финальность в Ethereum.</p><br/>
<p>Финальность крайне важна для пользователей, которые без нее могут оказаться жертвами атаки “double spend”, когда BP “придерживает” блоки, и публикует их после того, как сеть “увидела” хорошую транзакцию. Если финальности нет, то опубликованный форк заменяет блок с “хорошей” транзакцией на другой, из “плохого” форка, в котором эти же средства переводятся на адрес атакующего. В случае с PVRB требования к финальности еще ужесточаются, так как построение форков для PVRB означает возможность для атакующего готовить несколько вариантов рандома с целью опубликовать наиболее выгодный ему, и ограничить время возможной атаки — хорошее решение.</p><br/>
<p>Поэтому лучший вариант — совместить PVRB и финальность в один протокол — тогда финализированный блок = финализированный рандом, а это именно то, что надо было получить. Теперь игроки получат гарантированный рандом за N секунд, и могут быть уверены, что откатить его или переиграть заново невозможно.</p><br/>
<p>Вариант с consensus-integrated хорош:</p><br/>
<ul>
<li>возможностью асинхронной реализации по отношению к производству блоков — блоки производятся как обычно, но параллельно с этим может работать протокол PVRB, который производит рандомы не каждый блок</li>
<li>возможностью имплементировать даже тяжелую криптографию, без ограничений, накладываемых на смарт-контракты</li>
<li>возможностью организовать обмен сообщениями быстрее, чем транзакции включаются в блокчейн, например часть протокола может работать между нодами без распространения сообщений по сети</li>
</ul><br/>
<p>Он же имеет и недостатки:</p><br/>
<ul>
<li>сложности при тестировании и разработке — придется эмулировать сетевые ошибки, пропадающие ноды, хардфорки сети</li>
<li>ошибки в реализации требуют хардфорка сети</li>
</ul><br/>
<p>Оба способа имплементации PVRB имеют право на жизнь, но реализация на смарт-контрактах в современных блокчейнах все-таки довольно сильно ограничены в вычислительных ресурсах, и любой переход к серьезной криптографии часто попросту невозможен. А серьезная криптография нам понадобится, как будет продемонстрировано далее. Хотя, эта проблема носит явно временный характер, серьезная криптография в контрактах нужна для решения множества задач, и, постепенно она появляется (например, системные контракты для zkSNARKs в Ethereum)</p><br/>
<p>Блокчейн, который обеспечивает прозрачный и надежный канал обмена сообщениями протокола, делает это не бесплатно. Любой децентрализованный протокол должен учитывать возможность Sybil-атаки, любое действие можно сделать согласованными силами множества аккаунтов, поэтому при проектировании необходимо учитывать возможности атакующих по созданию произвольного числа участников протокола действующих в сговоре. </p><br/>
<h2 id="pvrb-i-peremennye-bloka">PVRB и переменные блока.</h2><br/>
<p>Я не врал, когда говорил, что хорошего PVRB, проверенного множеством gambling приложений, в блокчейнах пока никто не имплементировал. Откуда тогда такое количество gambling приложений в Ethereum и EOS? Меня это удивляет также как и вас, ну откуда в полностью детерминированной среде достали столько “стойких” рандомов?</p><br/>
<p>Любимый способ доставать рандом в блокчейне — это брать какую то “непредсказуемую” информацию из блока, и на основе нее делать рандом — просто прохешировав одно или несколько значений. Хорошая статья про проблемы таких схем <a href="https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620">здесь</a>. Можно взять какое нибудь из “непредсказуемых” значений в блоке, например хеш блока, количество транзакций, сложность сети, и другие, неизвестные заранее значения. Затем прохешировать их, одно или несколько, и, по идее должен получиться самый настоящий рандом. Можно даже добавить в wihitepaper, что ваша схема “post-quantum secure”(так как существуют quantum-proof хеш функции :)).</p><br/>
<p>Но даже post-quantum secure хешей недостаточно, увы. Секрет кроется в требованиях к PVRB, напомню их из предыдущей статьи:</p><br/>
<ol>
<li>Результат должен иметь доказуемо равномерное распределение, т.е основан на доказуемо стойкой криптографии.</li>
<li>Невозможно контролировать ни один из битов результата. Как следствие, результат не может быть заранее предсказан.</li>
<li>Нельзя саботировать протокол генерации за счет неучастия в протоколе или путем перегрузки сети атакующими сообщениями</li>
<li>Все вышеперечисленное должно быть стойким к сговорам допустимого числа нечестных участников протокола (например 1/3 участников).</li>
</ol><br/>
<p>В данном случае соблюдается только требование 1, и не соблюдается 2. Хешируя непредсказуемые значения из блока, мы получим равномерное распределение и хорошие рандомы. Но у BP есть как минимум возможность “опубликовать блок, или нет”. Таким образом BP как минимум может выбирать из ДВУХ вариантов рандома: “своего” и того, который получится, если блок сделает кто-то другой. BP может заранее “подсматривать”, что получится, если он опубликует блок, и просто принимает решение делать это или нет. Таким образом, играя например в “чет-нечет” или “красное/черное” в рулетке, он может публиковать блок только, если видит выигрыш. Это также делает нерабочей стратегию использования, например, хеша блока “из будущего”. В этом случае говорят, что “будет использован рандом, который получается хешированием текущих данных и хеша будущего блока высотой, например, N + 42, где N — текущая высота блока. Это немного усиливает схему, но все равно позволяет BP, пусть и в будущем, выбирать, придержать блок или опубликовать.</p><br/>
<p>Софт BP в данном случае усложняется, но не сильно. Просто при валидации и включении транзакции в блок идет быстрая проверка, будет ли выигрыш, и, возможно, подбор одного параметров транзакции, чтобы получить высокую вероятность выигрыша. При этом, поймать умного BP, за подобными манипуляциями практически нереально, каждый раз можно использовать новые адреса, и выигрывать понемногу, не вызывая подозрений.</p><br/>
<p>Так что способы с использованием информации из блока не годятся на роль универсальной имплементации PVRB. В ограниченном варианте, с ограничениями на размеры ставок, ограничениями количества играющих и/или KYC регистрацией (чтобы не давать одному игроку возможность использовать несколько адресов), эти схемы могут работать для небольших игр, но не более того.</p><br/>
<h2 id="pvrb-i-commit-reveal">PVRB и commit-reveal.</h2><br/>
<p>Ладно, спасибо хешированию и хотя-бы относительной непредсказуемости хеша блока и других переменных. Если решить проблему front-running-а майнеров, должно получиться что-то более годное. Давайте добавим в эту схему пользователей — пускай тоже влияют на рандом: любой сотрудник техподдержки скажет вам, что самое рандомное в IT системах — это действия пользователей :)</p><br/>
<p>Наивная схема, когда пользователи просто шлют рандомные числа, а результат вычисляется как, например, хеш от их суммы, не годится. В этом случае последний играющий может выбирая собственный рандом контролировать какой получится результат. Поэтому используется очень широко используемый паттерн commit-reveal. Участники сначала шлют хеши от своих рандомов (commit-ы), а затем открывают сами рандомы (reveal-ы). Фаза “reveal” начинается лишь после того, как были собраны необходимые commit-ы, поэтому участники могут прислать ровно тот рандом, хеш от которого прислали ранее. Теперь слепим все это с параметрами блока, причем лучше взятого из будущего (рандом можно будет узнать только в одном из будущих блоков), и вуаля — рандом готов! Теперь любой игрок влияет на результирующий рандом, и может “победить” зловредного BP, перекрыв его рандом своим, неизвестным заранее, рандомом… Еще можно добавить защиту от саботирования протокола путем невскрытия на этапе reveal — просто потребовав при commit-е прикладывать к транзакции некоторую сумму — страховой депозит, который вернется только при процедуре reveal. В этом случае делать commit и не делать reveal будет невыгодно.</p><br/>
<p>Это была хорошая попытка, и такие схемы тоже есть в игровых DApp-ах, но увы, этого опять недостаточно. Теперь на результат может влиять не только майнер, но и любой участник протокола. Контролировать само значение по прежнему можно, с меньшей степенью вариативности и за деньги, но, как и в случае с майнером, если результаты розыгрыша ценнее, чем плата за участие в протоколе PVRB, то random-producer(RP) может решать, делать ли reveal и по-прежнему может выбирать из минимум двух вариантов рандома.<br/>
Зато появилась возможность наказывать тех, кто делает commit и не делает reveal, и эта схема еще пригодится. Ее простота является серьезным преимуществом — более серьезные протоколы требуют гораздо более мощных вычислений.</p><br/>
<h2 id="pvrb-i-determinirovannye-podpisi">PVRB и детерминированные подписи.</h2><br/>
<p>Есть еще один способ заставить RP предоставить псевдослучайное число, на которое он не сможет повлиять, если ему предоставить “прообраз” — это детерминированная подпись. Такой подписью является, например, RSA, и не является ECS. Если у RP есть пара ключей: RSA и EСС, и он подписывает своим приватным ключом некоторое значение, то в случае RSA у него получится ОДНА И ТОЛЬКО ОДНА подпись, а в случае ECS — он может сгенерировать любое число различных валидных подписей. Это происходит из за того, что при создании ECS подписи используется рандомное число, выбираемое подписывающим, и оно может быть выбрано как угодно, давая подписывающему возможность выбирать одну из нескольких подписей. В случае RSA: “одно входное значение” + “одна пара ключей” = “одна подпись”. Предсказать какая получится подпись у другого RP не получится, поэтому PVRB с детерминированными подписями может быть организован при помощи комбинирования RSA подписей нескольких участников, которые подписали одно и то же значение. Например — предыдущий рандом. В такой схеме экономится немало ресурсов, т.к. подписи являются одновременно и подтверждением корректности поведения по протоколу, и источником рандома.</p><br/>
<p>Тем не менее, даже с детерминированными подписями, схема по прежнему уязвима к проблеме “last actor”. Последний участник по прежнему может решать, публиковать ему подпись или нет, тем самым контролируя результат. Можно дорабатывать схему, добавлять в нее хеши блоков, делать раунды, чтобы заранее результат нельзя было бы предсказать, но все эти приемы, даже с учетом множества доработок, все равно оставляют нерешенной проблему влияния одного участника на коллективный результат в недоверенном окружении и могут работать лишь в условиях экономических и временных ограничений. Кроме того размер ключей RSA (1024 и 2048 бит) довольно большой, а размер для блокчейн транзакций является крайне важным параметром. Видимо по-простому решить проблему не получится, идем дальше.</p><br/>
<h2 id="pvrb-i-secret-sharing-shemy">PVRB и secret sharing схемы</h2><br/>
<p>В криптографии существуют схемы, которые могут позволить сети договориться об одном и только одном значении PVRB, при этом такие схемы устойчивы к любым злонамеренным действиям части участников. Один из полезных протоколов, с которыми стоит познакомиться — схема разделения секрета Шамира. Она служит для того, чтобы разделить секрет (например секретный ключ) на несколько частей, и раздать эти части N участникам. Секрет распределяется таким образом, что для его восстановления достаточно M частей из N, при этом это могут быть любые M частей. Если на пальцах, то имея график неизвестной функции, участники обмениваются точками на графике, и после получения M точек, вся функция может быть восстановлена.<br/>
Хорошее объяснение приведено в <a href="https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing">wiki</a> а поиграться с ним практически, чтобы проиграть протокол в голове полезно на <a href="http://point-at-infinity.org/ssss/demo.html">demo</a> страничке.</p><br/>
<p>Если бы схема FSSS(Fiat-Shamir Secret Sharing) была применима в чистом виде — это был бы неубиваемый PVRB. В простейшем варианте протокол может выглядеть так:</p><br/>
<ul>
<li>Каждый участник генерирует собственный random и раздает shares от него остальным участникам</li>
<li>Каждый участник вскрывает свою часть секретов остальных участников</li>
<li>Если для участника набралось больше M shares, то число этого участника можно вычислить, и оно будет единственным, вне зависимости от набора вскрывшихся участников</li>
<li>Комбинация вскрытых random-ов и есть искомый PVRB</li>
</ul><br/>
<p>Здесь отдельный участник уже не влияет на результаты протокола, за исключением случаев, когда только от него зависит достижение threshold-а раскрытия рандома. Поэтому этот протокол, при наличии необходимой доли работающих по протоколу и доступных RP работает, реализуя требования по криптографической стойкости, и являясь устойчивым к проблеме “last actor”.</p><br/>
<p>Это мог бы быть идеальный вариант, эта схема PVRB на основе secret sharing Фиата-Шамира описана, например, в <a href="https://eprint.iacr.org/2017/216.pdf">этой</a> статье. Но, как и было сказано выше, если попытаться применить ее в лоб в блокчейне, появляются уже технические ограничения. Вот пример тестовой реализации протокола в смарт-контракте EOS и наиболее важная его часть — проверка опубликованного share участника: <a href="https://github.com/mixbytes/eoscraper/blob/master/Proof.hh#L23">код</a>. По коду видно, что валидация proof-а требует нескольких скалярных умножений, а числа используются очень большие. При этом надо понимать, что в блокчейнах verify происходит в момент, когда block-producer процессит транзакцию, и вообще любой участник должен легко проверить корректность протокола, поэтому требования к скорости функции verify очень серьезные. В этом варианте вариант оказался неработоспособным, так как верификация не укладывалась в ограничение на транзакцию(0.5 сек).</p><br/>
<p>Эффективность верификации — одно из важнейших требований к использованию в общем-то любых продвинутых криптографических схем в блокчейне. Создание proof-ов, подготовка сообщений — эти процедуры можно вынести off-chain и выполнять на высокопроизводительных компьютерах, но верификацию обойти не удастся — это еще одно важное требование к PVRB. </p><br/>
<h2 id="pvrb-i-threshold-signatures">PVRB и threshold signatures</h2><br/>
<p>Познакомившись со схемой secret sharing, мы открыли целый класс протоколов, объединенных ключевым словом “threshold”. Когда для раскрытия некоторой информации требуется участие M честных участников из N, и набор честных участников может быть произвольным подмножеством N, говорят о “threshold” схемах. Именно они позволяют разобраться с проблемой “last actor”, теперь если атакующий не открывает свою часть секрета, за него это сделает другой, честный участник. Эти схемы позволяют договориться об одном и только одном значении, даже при саботировании протокола частью участников. </p><br/>
<p>Совмещение детерминированных подписей и threshold-схем позволило разработать очень удобную и многообещающую схему для реализации PVRB — это детерминированные threshold-подписи. Вот <a href="https://eprint.iacr.org/2002/081.pdf">статья</a> о различных применениях threshold-подписей, а вот еще один хороший <a href="https://blog.dash.org/secret-sharing-and-threshold-signatures-with-bls-954d1587b5f">longread</a> от Dash. </p><br/>
<p>В последней статье описываются BLS подписи (BLS расшифровывается как Boneh-Lynn-Shacham, <a href="https://www.iacr.org/archive/asiacrypt2001/22480516.pdf">вот</a> статья ), которые имеют очень важное и крайне удобное для программистов качество — публичные, секретные, публичные ключи и подписи BLS могут комбинироваться друг с другом при помощи простых математических операций, при этом их комбинации остаются валидными ключами и подписями, позволяя легко агрегировать много подписей в одну и много публичных ключей в один. Они обладают также детерминистичностью и на одних и тех же входных данных выдают один и тот же результат. Благодаря этому качеству, комбинации BLS подписей сами являются валидными ключами, что позволяет реализовать вариант, при котором M из N участников производят одну и только одну подпись, которая детерминирована, publicly verifiable, и непредсказуема до тех пор, пока не будет вскрыта M-тым участником.</p><br/>
<p>В схеме с threshold BLS signatures каждый участник подписывает с помощью BLS что-то (например предыдущий рандом), а общая threshold-подпись и есть искомый рандом. Криптографические свойства подписей BLS удовлетворяют требованиям к качеству рандома, threshold-часть защищает от “last-actor”, а уникальная комбинируемость ключей позволяет реализовать еще много интересных алгоритмов, которые позволяют, например, эффективно агрегировать сообщения протокола.</p><br/>
<p>Так что, если вы строите PVRB в своем блокчейне, вы с большой вероятностью придете к схеме BLS threshold signatures, ее уже используют несколько проектов. Например, DFinity (<a href="https://github.com/dfinity/random-beacon">здесь</a> бенчмарк, реализующий схему, а <a href="https://github.com/dfinity/vss/blob/master/docs/index.md">тут</a> пример реализации verifiable secret sharing), или Keep.network (вот их random beacon <a href="https://github.com/keep-network/random-beacon-yellowpaper">yellowpaper</a>, а вот <a href="https://github.com/keep-network/random-beacon-box">пример</a> смарт-контракта, обслуживающего протокол).</p><br/>
<h2 id="implementaciya-pvrb">Имплементация PVRB</h2><br/>
<p>К сожалению, до сих пор мы не видим готового, реализованного в блокчейнах PVRB протокола, доказавшего свою безопасность и устойчивость. Несмотря на то, что сами протоколы готовы, технически применить их к существующим решениям непросто. Для централизованных систем PVRB не имеет смысла, а децентрализованные строго ограничены во всех вычислительных ресурсах: CPU, memory, storage, I/O. Проектирование PVRB — это комбинирование разных протоколов, чтобы все таки слепить то, что подойдет по всем требованиям хотя бы к какому нибудь жизнеспособному блокчейну. Один протокол эффективней вычисляет, но требует больше сообщений между RP, а другой требует крайне мало сообщений, но создание proof-а может быть задачей на десятки минут, а то и часов.</p><br/>
<p>Я перечислю факторы, которые вам придется учитывать при выборе качественного PVRB:</p><br/>
<ul>
<li><em>Криптографическая стойкость</em>. Ваш PVRB должен быть строго unbiasable, без возможности контроля единственного бита. В некоторых схемах это не так, поэтому зовите криптографа</li>
<li><em>Проблема “last actor”</em>. Ваш PVRB должен быть устойчив к атакам, когда атакующий, контролирующий одного или нескольких RP может выбирать один из двух вариантов результата.</li>
<li><em>Проблема саботажа протокола</em>. Ваш PVRB должен быть устойчив к атакам, когда атакующий, контролирующий одного или нескольких RP решает, быть ли рандому или нет и может гарантированно, либо с заданной вероятностью влиять на это</li>
<li><em>Проблема количества сообщений</em>. Ваши RP должны посылать в блокчейн минимум сообщений и максимально избегать синхронных действий типа ситуаций “я отправил некоторую информацию, жду ответа от конкретного участника”. В p2p сетях, особенно разнесенных географически, не стоит расчитывать на быстрый ответ</li>
<li><em>Проблема вычислительной сложности</em>. Верификация любого этапа PVRB on-chain должна быть крайне легкой, так как ее выполняют все полные клиенты сети. Если реализация делается с помощью смарт-контракта, то требования к скорости очень жесткие</li>
<li><em>Проблема доступности и liveness</em>. Ваш PVRB должен стремиться быть устойчивым к ситуациям, когда часть сети стала недоступной на некоторое время и часть RP просто перестала работать</li>
<li><em>Проблема trusted setup и первоначального распределения ключей</em>. Если ваш PVRB использует первичный setup протокола, то это отдельная большая и серьезная история. Вот <a href="https://z.cash/ru/blog/the-design-of-the-ceremony/">пример</a>. Если участники должны перед начало протокола сообщить друг-другу свои ключи — это тоже проблема, если состав участников меняется</li>
<li><em>Проблемы разработки</em>. Наличие библиотек на нужных языках, их безопасность и производительность, публичность, сложные тесты и т.п.</li>
</ul><br/>
<p>К примеру у threshold BLS подписей есть существенная проблема — перед тем как начать работать, участникам обязательно надо раздать друг другу ключи, организовав группу, в рамках которой будет работать threshold. Это означает, что как минимум один раунд обмена в децентрализованной сети придется выждать, а, учитывая, что генерируемый рандом, к примеру, необходим в играх, практически в realtime, это означает, что саботаж протокола возможен на этом этапе, и преимущества threshold схемы теряются. Эта проблема уже проще предыдущих, но все равно требует разработки отдельной процедуры формирования threshold-групп, которую придется защищать экономически, за счет депозитов и отъема средств(slashing) у участников, не следующих протоколу. Также, верификация BLS с приемлемым уровнем безопасности попросту не помещается, например, в стандартную транзакцию EOS или Ethereum — просто не хватает времени на верификацию. Код контрактов — это WebAssembly или EVM, исполняется виртуальной машиной. Криптографические функции не реализованы нативно(пока), и работают в десятки раз медленнее обычных криптографических библиотек. Многие протоколы не подходят по требованиям просто исходя из объема ключей, например это 1024 и 2048 bit для RSA, в 4-8 раз больше, чем стандартная подпись транзакции в Bitcoin и Ethereum.</p><br/>
<p>Играет роль и наличие реализаций на разных языках программирования — которых немного, особенно для новых протоколов. Вариант с интеграцией в консенсус требует писать протокол на языке платформы, поэтому придется искать код на Go для geth, на Rust для Parity, на C++ для EOS. Код на JavaScript придется искать всем, а так как JavaScript и криптография не особо близкие друзья, поможет WebAssembly, который теперь уже точно претендует на роль следующего важного интернет-стандарта.</p><br/>
<h2 id="zaklyuchenie">Заключение</h2><br/>
<p>Надеюсь, в предыдущей <a href="https://habr.com/ru/post/448330/">статье</a> я сумел убедить вас, что генерация случайных чисел на блокчейне критически важна для множества аспектов жизни децентрализованных сетей, а этой статьей показал, что задача эта крайне амбициозная и непростая, но хорошие решения уже существуют. Вообще, окончательный дизайн протокола возможен лишь после проведения массивных тестов, учитывающих все аспекты от setup-а до эмуляции сбоев, поэтому вы вряд ли найдете готовые рецепты в whitepaper-ах команд и в статьях, да и мы в ближайший год-два точно не решимся писать “делайте так, так точно правильно”. </p><br/>
<p>Пока, для нашего PVRB в разрабатываемом блокчейне <a href="https://github.com/mixbytes/haya">Haya</a>, мы остановились на применении threshold BLS signatures, планируем реализовывать PVRB на уровне консенсуса, так как верификация в смарт-контрактах с приемлемым уровнем безопасности пока невозможна. Возможно, что мы используем сразу две схемы: сначала дорогую secret sharing для создания долгосрочного random_seed, а его используем далее в качестве основы для высокочастотной генерации рандома с помощью детерминированных threshold BLS подписей, возможно ограничимся лишь одной из схем. Сказать заранее, каким будет протокол, увы, невозможно, радует лишь то, что как и в науке, в инженерных задачах отрицательный результат — это тоже результат, и каждая новая попытка решить задачу является очередной ступенькой для изысканий всех, занимающихся проблемой. Для обеспечения требований со стороны бизнеса мы решаем конкретную практическую задачу — обеспечение игровых приложений надежным источником энтропии, поэтому нам приходится уделять внимание также самому блокчейну, в частности вопросам финальности цепочки и governance сети. </p><br/>
<p>И пусть мы пока не видим в блокчейнах доказанно стойкого PVRB, который использовался бы уже достаточно времени, чтобы пройти испытания настоящими приложениями, множественными аудитами, нагрузками, и конечно, же, реальными атаками, но число возможных путей подтверждает, что решение существует, и какой-то из этих алгоритмов в конце концов решит проблему. Мы с удовольствием будем делиться результатами и благодарим другие команды, которые тоже занимаются этим вопросом за статьи и код, которые позволяют инженерам не наступать дважды на одни и те же грабли. </p><br/>
<p>Так что, встретив программиста, проектирующего децентрализованный рандом, будьте внимательны и заботливы, при необходимости окажите психологическую помощь :)</p></div></div> <!----> <!----></div> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bblockchain%5D" class="tm-tags-list__link">blockchain</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Brandom%20number%20generator%5D" class="tm-tags-list__link">random number generator</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D1%81%D0%BC%D0%B0%D1%80%D1%82-%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%B0%D0%BA%D1%82%D1%8B%5D" class="tm-tags-list__link">смарт-контракты</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%B4%D0%B5%D1%86%D0%B5%D0%BD%D1%82%D1%80%D0%B0%D0%BB%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%81%D0%B5%D1%82%D0%B8%5D" class="tm-tags-list__link">децентрализованные сети</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/hub/p2p/" class="tm-hubs-list__link">
    Децентрализованные сети
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/infosecurity/" class="tm-hubs-list__link">
    Информационная безопасность
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/crypto/" class="tm-hubs-list__link">
    Криптография
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/algorithms/" class="tm-hubs-list__link">
    Алгоритмы
  </a></li></ul></div></div></article></div> <!----></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_medium"><title>Всего голосов 20: ↑20 и ↓0</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-rating"></use></svg> <span title="Всего голосов 20: ↑20 и ↓0" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_medium">+20</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">2.3K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    40
  </span></button> <!----> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> </div></div> <!----> <!----> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="/ru/users/BoogerWooger/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><img alt="" src="//habrastorage.org/getpro/habr/avatars/100/f80/86a/100f8086a32f1a1e3c582b6b4f9c61d0.png" class="tm-entity-image__pic"></div></a> <div class="tm-user-card__meta"><div title=" 90 голосов " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    60
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">6.5</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title_variant-article"><span class="tm-user-card__name tm-user-card__name_variant-article">Сергей Прилуцкий</span> <a href="/ru/users/BoogerWooger/" class="tm-user-card__nickname tm-user-card__nickname_variant-article">
          @BoogerWooger
        </a> <!----></div> <p class="tm-user-card__short-info tm-user-card__short-info_variant-article">Software Researcher</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-article"><!----> <!----> <!----> <!----> <!----></div></div> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----></section> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="/ru/post/452340/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментарии 4 
    </span></a> <!----></div></div></div> <div class="tm-ad-banner__container tm-page-article__banner"><!----> <div id="articleBottomBanner" class="tm-ad-banner"></div></div> <!----> <!----> <!----> <!----> </div></div></div></div></div> <div class="tm-page__sidebar"><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__ads tm-layout-sidebar__ads_initial"><div class="tm-ad-banner__container tm-layout-sidebar__banner"><!----> <div id="sidebarBanner" class="tm-ad-banner"></div></div></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----> <!----></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/post/452340/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/post/452340/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2021 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"452340":{"id":"452340","timePublished":"2019-05-17T13:47:43+00:00","isCorporative":false,"lang":"ru","titleHtml":"Случайные числа и децентрализованные сети: имплементации","leadData":{"textHtml":"\u003Ch1 id=\"vvedenie\"\u003EВведение\u003C\u002Fh1\u003E\u003Cbr\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Efunction getAbsolutelyRandomNumer() {\n        return 4; \u002F\u002F returns absolutely random number!\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u003E\r\n\u003Cp\u003EКак и в случае с концепцией абсолютно стойкого шифра из криптографии, реальные протоколы “Publicly Verifiable Random Beacon” (далее PVRB) лишь пытаются максимально приблизиться к идеальной схеме, т.к. в реальных сетях в чистом виде она неприменима: договариваться надо строго об одном бите, раундов должно быть много, а все сообщения должны быть идеально быстрыми и всегда доставляться. Разумеется, в реальных сетях это не так. Поэтому, при проектировании PVRB под конкретные задачи в современных блокчейнах, помимо невозможности контроля получаемого рандома и криптографической стойкости, возникает еще много чисто архитектурных и технических проблем.\u003C\u002Fp\u003E","imageUrl":null,"buttonTextHtml":"Читать дальше →","image":null},"editorVersion":"1.0","postType":"article","postLabels":[],"author":{"scoreStats":{"score":60,"votesCount":90},"rating":6.5,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"512116","alias":"BoogerWooger","fullname":"Сергей Прилуцкий","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F100\u002Ff80\u002F86a\u002F100f8086a32f1a1e3c582b6b4f9c61d0.png","speciality":"Software Researcher"},"statistics":{"commentsCount":4,"favoritesCount":40,"readingCount":2323,"score":20,"votesCount":20},"hubs":[{"relatedData":null,"id":"33","alias":"p2p","type":"collective","title":"Децентрализованные сети","titleHtml":"Децентрализованные сети","isProfiled":false},{"relatedData":null,"id":"50","alias":"infosecurity","type":"collective","title":"Информационная безопасность","titleHtml":"Информационная безопасность","isProfiled":true},{"relatedData":null,"id":"118","alias":"crypto","type":"collective","title":"Криптография","titleHtml":"Криптография","isProfiled":true},{"relatedData":null,"id":"8000","alias":"algorithms","type":"collective","title":"Алгоритмы","titleHtml":"Алгоритмы","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"},{"id":"6","alias":"admin","title":"Администрирование"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Ch1 id=\"vvedenie\"\u003EВведение\u003C\u002Fh1\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Efunction getAbsolutelyRandomNumer() {\n        return 4; \u002F\u002F returns absolutely random number!\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКак и в случае с концепцией абсолютно стойкого шифра из криптографии, реальные протоколы “Publicly Verifiable Random Beacon” (далее PVRB) лишь пытаются максимально приблизиться к идеальной схеме, т.к. в реальных сетях в чистом виде она неприменима: договариваться надо строго об одном бите, раундов должно быть много, а все сообщения должны быть идеально быстрыми и всегда доставляться. Разумеется, в реальных сетях это не так. Поэтому, при проектировании PVRB под конкретные задачи в современных блокчейнах, помимо невозможности контроля получаемого рандома и криптографической стойкости, возникает еще много чисто архитектурных и технических проблем.\u003C\u002Fp\u003E\u003Ca name=\"habracut\"\u003E\u003C\u002Fa\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EСам блокчейн является для PVRB по сути средой для коммуникации, в которой сообщения=транзакции. Это позволяет частично абстрагироваться от сетевых проблем, недоставки сообщений, проблем промежуточного софта — все эти риски принимает на себя децентрализованная сеть, и, главная ее ценность для PVRB — невозможность отозвать или испортить уже отправленную транзакцию — это не позволяет участникам отказаться от участия в протоколе, если только они не провели успешную атаку на консенсус. Такой уровень безопасности приемлем, поэтому PVRB должен быть устойчив к сговорам участникам ровно в той же мере, что и основная цепочка блокчейна. Также, это намекает, что PVRB должен быть частью консенсуса, если сеть договорилась насчет основной цепочки блоков, пускай одновременно она договорится и о единственном честном результирующем рандоме. Либо, PVRB — это просто standalone протокол, реализованный смарт-контрактом, работающий асинхронно по отношению к блокчейну и блокам. У обоих способов есть свои преимущества и недостатки, и выбор между ними крайне нетривиален. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"dva-sposoba-implementacii-pvrb\"\u003EДва способа имплементации PVRB\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EОпишем подробнее два варианта имплементации PVRB — standalone версию, работающую с использованием независимого от блокчейна смарт-контракта, и consensus-integrated — встроенную в протокол, согласно которому сеть договаривается о цепочке блоков и включаемых транзакциях. Во всех случаях я буду иметь в виду популярные блокчейн-движки: Ethereum, EOS, и все, похожие на них по способу размещения и процессинга смарт-контрактов. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"standalone-contract\"\u003EStandalone contract\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ этом варианте PVRB представляет собой смарт-контракт, который принимает транзакции random-producer-ов (далее RP), обрабатывает их, комбинирует результаты, и, в результате, приходит к некоторому значению, которое может получить любой пользователь из этого контракта. Это значение может не храниться в контракте напрямую, а быть представлено только данными, из которых можно детерминировано получить одно и только одно значение результирующего рандома. В этой схеме RP — пользователи блокчейна, и участвовать в процессе генерации можно позволить кому угодно.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВариант со standalone-contract хорош:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003Eпереносимостью (контракты можно таскать из блокчейна в блокчейн)\u003C\u002Fli\u003E\r\n\u003Cli\u003Eпростотой в реализации и тестировании (контракты удобно писать и тестировать)\u003C\u002Fli\u003E\r\n\u003Cli\u003Eудобством в реализации экономических схем (легко сделать свой токен, чья логика служит целям PVRB)\u003C\u002Fli\u003E\r\n\u003Cli\u003Eвозможностью запуска в уже работающих блокчейнах\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EОн же имеет и недостатки:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003Eсильные ограничения на ресурсы при вычислениях, объем транзакций и storage (проще говоря cpu\u002Fmem\u002Fio)\u003C\u002Fli\u003E\r\n\u003Cli\u003Eограничения на операции внутри контракта (не все инструкции доступны, сложно подключать внешние библиотеки)\u003C\u002Fli\u003E\r\n\u003Cli\u003Eневозможность организовать обмен сообщениями быстрее, чем транзакции включаются в блокчейн\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЭтот вариант годится для реализации PVRB, который необходимо запустить в уже существующей сети, не содержащий сложную криптографию и не требующий большого количества взаимодействий.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"consensus-integrated\"\u003EConsensus-integrated\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ этом варианте PVRB реализован в коде блокчейн-ноды, встроен или работает параллельно с обменом сообщений между нодами блокчейна. Результаты протокола записываются прямо в производимые блоки, а сообщения протокола отправляются по p2p сети между нодами. Так как протокол имеет результатом числа, которые должны быть записаны в блоках, сеть должна прийти к консенсусу относительно них. Значит сообщения PVRB, как и транзакции должны валидироваться нодами, и включаться в блоки, чтобы любой участник сети мог бы провалидировать соблюдение протокола PVRB. Это автоматически ведет нас к очевидному решению — если сеть договаривается в консенсусе насчет блока и транзакций в нем, то PVRB должен быть частью консенсуса, а не отдельно стоящим протоколом. Иначе возможна ситуация, когда блок является валидным с точки зрения консенсуса, но протокол PVRB не соблюден, и с точки зрения PVRB блок не может быть принят. Так что если выбран “consensus-integrated” вариант, PVRB становится важной частью консенсуса.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EОписывая имплементации PVRB на уровне консенсуса в сети, ни в коем случае нельзя обойти вопросы финальности. Финальность — это механизм, используемый в детерминированных консенсусах, фиксирующий блок (и цепочку, ведущую к нему), который является финальным, и никогда не будет выброшен, даже если появится параллельный форк. Например, в Bitcoin такого механизма нет — если опубликовать цепочку большей сложности, она заменит любую менее сложную, вне зависимости от длины цепочек. А в EOS, например, финальными являются так называемые Last Irreversible Blocks, которые появляются в среднем каждые 432 блока (12*21 + 12*15, pre-vote + pre-commit). Этот процесс — по сути ожидание 2\u002F3 подписей block-producers (далее BP). При появлении форков, которые старше чем последний LIB они просто отбрасываются. Этот механизм позволяет гарантированно утверждать, что транзакция включена в блокчейн и никогда не будет откачена, какими бы ресурсами не обладал атакующий. Также, финальными блоками являются блоки, подписанные 2\u002F3 BP в Hyperledger, Tendermint и других pBFT-based консенсусах. Также, протокол для обеспечения финальности имеет смысл делать надстройкой над консенсусом, так как он может работать асинхронно с производством и публикацией блоков. Вот хорошая \u003Ca href=\"https:\u002F\u002Farxiv.org\u002Fpdf\u002F1710.09437.pdf\"\u003Eстатья\u003C\u002Fa\u003E про финальность в Ethereum.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EФинальность крайне важна для пользователей, которые без нее могут оказаться жертвами атаки “double spend”, когда BP “придерживает” блоки, и публикует их после того, как сеть “увидела” хорошую транзакцию. Если финальности нет, то опубликованный форк заменяет блок с “хорошей” транзакцией на другой, из “плохого” форка, в котором эти же средства переводятся на адрес атакующего. В случае с PVRB требования к финальности еще ужесточаются, так как построение форков для PVRB означает возможность для атакующего готовить несколько вариантов рандома с целью опубликовать наиболее выгодный ему, и ограничить время возможной атаки — хорошее решение.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПоэтому лучший вариант — совместить PVRB и финальность в один протокол — тогда финализированный блок = финализированный рандом, а это именно то, что надо было получить. Теперь игроки получат гарантированный рандом за N секунд, и могут быть уверены, что откатить его или переиграть заново невозможно.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВариант с consensus-integrated хорош:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003Eвозможностью асинхронной реализации по отношению к производству блоков — блоки производятся как обычно, но параллельно с этим может работать протокол PVRB, который производит рандомы не каждый блок\u003C\u002Fli\u003E\r\n\u003Cli\u003Eвозможностью имплементировать даже тяжелую криптографию, без ограничений, накладываемых на смарт-контракты\u003C\u002Fli\u003E\r\n\u003Cli\u003Eвозможностью организовать обмен сообщениями быстрее, чем транзакции включаются в блокчейн, например часть протокола может работать между нодами без распространения сообщений по сети\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EОн же имеет и недостатки:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003Eсложности при тестировании и разработке — придется эмулировать сетевые ошибки, пропадающие ноды, хардфорки сети\u003C\u002Fli\u003E\r\n\u003Cli\u003Eошибки в реализации требуют хардфорка сети\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EОба способа имплементации PVRB имеют право на жизнь, но реализация на смарт-контрактах в современных блокчейнах все-таки довольно сильно ограничены в вычислительных ресурсах, и любой переход к серьезной криптографии часто попросту невозможен. А серьезная криптография нам понадобится, как будет продемонстрировано далее. Хотя, эта проблема носит явно временный характер, серьезная криптография в контрактах нужна для решения множества задач, и, постепенно она появляется (например, системные контракты для zkSNARKs в Ethereum)\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EБлокчейн, который обеспечивает прозрачный и надежный канал обмена сообщениями протокола, делает это не бесплатно. Любой децентрализованный протокол должен учитывать возможность Sybil-атаки, любое действие можно сделать согласованными силами множества аккаунтов, поэтому при проектировании необходимо учитывать возможности атакующих по созданию произвольного числа участников протокола действующих в сговоре. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"pvrb-i-peremennye-bloka\"\u003EPVRB и переменные блока.\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЯ не врал, когда говорил, что хорошего PVRB, проверенного множеством gambling приложений, в блокчейнах пока никто не имплементировал. Откуда тогда такое количество gambling приложений в Ethereum и EOS? Меня это удивляет также как и вас, ну откуда в полностью детерминированной среде достали столько “стойких” рандомов?\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЛюбимый способ доставать рандом в блокчейне — это брать какую то “непредсказуемую” информацию из блока, и на основе нее делать рандом — просто прохешировав одно или несколько значений. Хорошая статья про проблемы таких схем \u003Ca href=\"https:\u002F\u002Fblog.positive.com\u002Fpredicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620\"\u003Eздесь\u003C\u002Fa\u003E. Можно взять какое нибудь из “непредсказуемых” значений в блоке, например хеш блока, количество транзакций, сложность сети, и другие, неизвестные заранее значения. Затем прохешировать их, одно или несколько, и, по идее должен получиться самый настоящий рандом. Можно даже добавить в wihitepaper, что ваша схема “post-quantum secure”(так как существуют quantum-proof хеш функции :)).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНо даже post-quantum secure хешей недостаточно, увы. Секрет кроется в требованиях к PVRB, напомню их из предыдущей статьи:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Col\u003E\r\n\u003Cli\u003EРезультат должен иметь доказуемо равномерное распределение, т.е основан на доказуемо стойкой криптографии.\u003C\u002Fli\u003E\r\n\u003Cli\u003EНевозможно контролировать ни один из битов результата. Как следствие, результат не может быть заранее предсказан.\u003C\u002Fli\u003E\r\n\u003Cli\u003EНельзя саботировать протокол генерации за счет неучастия в протоколе или путем перегрузки сети атакующими сообщениями\u003C\u002Fli\u003E\r\n\u003Cli\u003EВсе вышеперечисленное должно быть стойким к сговорам допустимого числа нечестных участников протокола (например 1\u002F3 участников).\u003C\u002Fli\u003E\r\n\u003C\u002Fol\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ данном случае соблюдается только требование 1, и не соблюдается 2. Хешируя непредсказуемые значения из блока, мы получим равномерное распределение и хорошие рандомы. Но у BP есть как минимум возможность “опубликовать блок, или нет”. Таким образом BP как минимум может выбирать из ДВУХ вариантов рандома: “своего” и того, который получится, если блок сделает кто-то другой. BP может заранее “подсматривать”, что получится, если он опубликует блок, и просто принимает решение делать это или нет. Таким образом, играя например в “чет-нечет” или “красное\u002Fчерное” в рулетке, он может публиковать блок только, если видит выигрыш. Это также делает нерабочей стратегию использования, например, хеша блока “из будущего”. В этом случае говорят, что “будет использован рандом, который получается хешированием текущих данных и хеша будущего блока высотой, например, N + 42, где N — текущая высота блока. Это немного усиливает схему, но все равно позволяет BP, пусть и в будущем, выбирать, придержать блок или опубликовать.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EСофт BP в данном случае усложняется, но не сильно. Просто при валидации и включении транзакции в блок идет быстрая проверка, будет ли выигрыш, и, возможно, подбор одного параметров транзакции, чтобы получить высокую вероятность выигрыша. При этом, поймать умного BP, за подобными манипуляциями практически нереально, каждый раз можно использовать новые адреса, и выигрывать понемногу, не вызывая подозрений.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТак что способы с использованием информации из блока не годятся на роль универсальной имплементации PVRB. В ограниченном варианте, с ограничениями на размеры ставок, ограничениями количества играющих и\u002Fили KYC регистрацией (чтобы не давать одному игроку возможность использовать несколько адресов), эти схемы могут работать для небольших игр, но не более того.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"pvrb-i-commit-reveal\"\u003EPVRB и commit-reveal.\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЛадно, спасибо хешированию и хотя-бы относительной непредсказуемости хеша блока и других переменных. Если решить проблему front-running-а майнеров, должно получиться что-то более годное. Давайте добавим в эту схему пользователей — пускай тоже влияют на рандом: любой сотрудник техподдержки скажет вам, что самое рандомное в IT системах — это действия пользователей :)\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНаивная схема, когда пользователи просто шлют рандомные числа, а результат вычисляется как, например, хеш от их суммы, не годится. В этом случае последний играющий может выбирая собственный рандом контролировать какой получится результат. Поэтому используется очень широко используемый паттерн commit-reveal. Участники сначала шлют хеши от своих рандомов (commit-ы), а затем открывают сами рандомы (reveal-ы). Фаза “reveal” начинается лишь после того, как были собраны необходимые commit-ы, поэтому участники могут прислать ровно тот рандом, хеш от которого прислали ранее. Теперь слепим все это с параметрами блока, причем лучше взятого из будущего (рандом можно будет узнать только в одном из будущих блоков), и вуаля — рандом готов! Теперь любой игрок влияет на результирующий рандом, и может “победить” зловредного BP, перекрыв его рандом своим, неизвестным заранее, рандомом… Еще можно добавить защиту от саботирования протокола путем невскрытия на этапе reveal — просто потребовав при commit-е прикладывать к транзакции некоторую сумму — страховой депозит, который вернется только при процедуре reveal. В этом случае делать commit и не делать reveal будет невыгодно.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЭто была хорошая попытка, и такие схемы тоже есть в игровых DApp-ах, но увы, этого опять недостаточно. Теперь на результат может влиять не только майнер, но и любой участник протокола. Контролировать само значение по прежнему можно, с меньшей степенью вариативности и за деньги, но, как и в случае с майнером, если результаты розыгрыша ценнее, чем плата за участие в протоколе PVRB, то random-producer(RP) может решать, делать ли reveal и по-прежнему может выбирать из минимум двух вариантов рандома.\u003Cbr\u002F\u003E\r\nЗато появилась возможность наказывать тех, кто делает commit и не делает reveal, и эта схема еще пригодится. Ее простота является серьезным преимуществом — более серьезные протоколы требуют гораздо более мощных вычислений.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"pvrb-i-determinirovannye-podpisi\"\u003EPVRB и детерминированные подписи.\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЕсть еще один способ заставить RP предоставить псевдослучайное число, на которое он не сможет повлиять, если ему предоставить “прообраз” — это детерминированная подпись. Такой подписью является, например, RSA, и не является ECS. Если у RP есть пара ключей: RSA и EСС, и он подписывает своим приватным ключом некоторое значение, то в случае RSA у него получится ОДНА И ТОЛЬКО ОДНА подпись, а в случае ECS — он может сгенерировать любое число различных валидных подписей. Это происходит из за того, что при создании ECS подписи используется рандомное число, выбираемое подписывающим, и оно может быть выбрано как угодно, давая подписывающему возможность выбирать одну из нескольких подписей. В случае RSA: “одно входное значение” + “одна пара ключей” = “одна подпись”. Предсказать какая получится подпись у другого RP не получится, поэтому PVRB с детерминированными подписями может быть организован при помощи комбинирования RSA подписей нескольких участников, которые подписали одно и то же значение. Например — предыдущий рандом. В такой схеме экономится немало ресурсов, т.к. подписи являются одновременно и подтверждением корректности поведения по протоколу, и источником рандома.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТем не менее, даже с детерминированными подписями, схема по прежнему уязвима к проблеме “last actor”. Последний участник по прежнему может решать, публиковать ему подпись или нет, тем самым контролируя результат. Можно дорабатывать схему, добавлять в нее хеши блоков, делать раунды, чтобы заранее результат нельзя было бы предсказать, но все эти приемы, даже с учетом множества доработок, все равно оставляют нерешенной проблему влияния одного участника на коллективный результат в недоверенном окружении и могут работать лишь в условиях экономических и временных ограничений. Кроме того размер ключей RSA (1024 и 2048 бит) довольно большой, а размер для блокчейн транзакций является крайне важным параметром. Видимо по-простому решить проблему не получится, идем дальше.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"pvrb-i-secret-sharing-shemy\"\u003EPVRB и secret sharing схемы\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ криптографии существуют схемы, которые могут позволить сети договориться об одном и только одном значении PVRB, при этом такие схемы устойчивы к любым злонамеренным действиям части участников. Один из полезных протоколов, с которыми стоит познакомиться — схема разделения секрета Шамира. Она служит для того, чтобы разделить секрет (например секретный ключ) на несколько частей, и раздать эти части N участникам. Секрет распределяется таким образом, что для его восстановления достаточно M частей из N, при этом это могут быть любые M частей. Если на пальцах, то имея график неизвестной функции, участники обмениваются точками на графике, и после получения M точек, вся функция может быть восстановлена.\u003Cbr\u002F\u003E\r\nХорошее объяснение приведено в \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FShamir%27s_Secret_Sharing\"\u003Ewiki\u003C\u002Fa\u003E а поиграться с ним практически, чтобы проиграть протокол в голове полезно на \u003Ca href=\"http:\u002F\u002Fpoint-at-infinity.org\u002Fssss\u002Fdemo.html\"\u003Edemo\u003C\u002Fa\u003E страничке.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЕсли бы схема FSSS(Fiat-Shamir Secret Sharing) была применима в чистом виде — это был бы неубиваемый PVRB. В простейшем варианте протокол может выглядеть так:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EКаждый участник генерирует собственный random и раздает shares от него остальным участникам\u003C\u002Fli\u003E\r\n\u003Cli\u003EКаждый участник вскрывает свою часть секретов остальных участников\u003C\u002Fli\u003E\r\n\u003Cli\u003EЕсли для участника набралось больше M shares, то число этого участника можно вычислить, и оно будет единственным, вне зависимости от набора вскрывшихся участников\u003C\u002Fli\u003E\r\n\u003Cli\u003EКомбинация вскрытых random-ов и есть искомый PVRB\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЗдесь отдельный участник уже не влияет на результаты протокола, за исключением случаев, когда только от него зависит достижение threshold-а раскрытия рандома. Поэтому этот протокол, при наличии необходимой доли работающих по протоколу и доступных RP работает, реализуя требования по криптографической стойкости, и являясь устойчивым к проблеме “last actor”.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЭто мог бы быть идеальный вариант, эта схема PVRB на основе secret sharing Фиата-Шамира описана, например, в \u003Ca href=\"https:\u002F\u002Feprint.iacr.org\u002F2017\u002F216.pdf\"\u003Eэтой\u003C\u002Fa\u003E статье. Но, как и было сказано выше, если попытаться применить ее в лоб в блокчейне, появляются уже технические ограничения. Вот пример тестовой реализации протокола в смарт-контракте EOS и наиболее важная его часть — проверка опубликованного share участника: \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fmixbytes\u002Feoscraper\u002Fblob\u002Fmaster\u002FProof.hh#L23\"\u003Eкод\u003C\u002Fa\u003E. По коду видно, что валидация proof-а требует нескольких скалярных умножений, а числа используются очень большие. При этом надо понимать, что в блокчейнах verify происходит в момент, когда block-producer процессит транзакцию, и вообще любой участник должен легко проверить корректность протокола, поэтому требования к скорости функции verify очень серьезные. В этом варианте вариант оказался неработоспособным, так как верификация не укладывалась в ограничение на транзакцию(0.5 сек).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЭффективность верификации — одно из важнейших требований к использованию в общем-то любых продвинутых криптографических схем в блокчейне. Создание proof-ов, подготовка сообщений — эти процедуры можно вынести off-chain и выполнять на высокопроизводительных компьютерах, но верификацию обойти не удастся — это еще одно важное требование к PVRB. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"pvrb-i-threshold-signatures\"\u003EPVRB и threshold signatures\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПознакомившись со схемой secret sharing, мы открыли целый класс протоколов, объединенных ключевым словом “threshold”. Когда для раскрытия некоторой информации требуется участие M честных участников из N, и набор честных участников может быть произвольным подмножеством N, говорят о “threshold” схемах. Именно они позволяют разобраться с проблемой “last actor”, теперь если атакующий не открывает свою часть секрета, за него это сделает другой, честный участник. Эти схемы позволяют договориться об одном и только одном значении, даже при саботировании протокола частью участников. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EСовмещение детерминированных подписей и threshold-схем позволило разработать очень удобную и многообещающую схему для реализации PVRB — это детерминированные threshold-подписи. Вот \u003Ca href=\"https:\u002F\u002Feprint.iacr.org\u002F2002\u002F081.pdf\"\u003Eстатья\u003C\u002Fa\u003E о различных применениях threshold-подписей, а вот еще один хороший \u003Ca href=\"https:\u002F\u002Fblog.dash.org\u002Fsecret-sharing-and-threshold-signatures-with-bls-954d1587b5f\"\u003Elongread\u003C\u002Fa\u003E от Dash. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ последней статье описываются BLS подписи (BLS расшифровывается как Boneh-Lynn-Shacham, \u003Ca href=\"https:\u002F\u002Fwww.iacr.org\u002Farchive\u002Fasiacrypt2001\u002F22480516.pdf\"\u003Eвот\u003C\u002Fa\u003E статья ), которые имеют очень важное и крайне удобное для программистов качество — публичные, секретные, публичные ключи и подписи BLS могут комбинироваться друг с другом при помощи простых математических операций, при этом их комбинации остаются валидными ключами и подписями, позволяя легко агрегировать много подписей в одну и много публичных ключей в один. Они обладают также детерминистичностью и на одних и тех же входных данных выдают один и тот же результат. Благодаря этому качеству, комбинации BLS подписей сами являются валидными ключами, что позволяет реализовать вариант, при котором M из N участников производят одну и только одну подпись, которая детерминирована, publicly verifiable, и непредсказуема до тех пор, пока не будет вскрыта M-тым участником.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ схеме с threshold BLS signatures каждый участник подписывает с помощью BLS что-то (например предыдущий рандом), а общая threshold-подпись и есть искомый рандом. Криптографические свойства подписей BLS удовлетворяют требованиям к качеству рандома, threshold-часть защищает от “last-actor”, а уникальная комбинируемость ключей позволяет реализовать еще много интересных алгоритмов, которые позволяют, например, эффективно агрегировать сообщения протокола.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТак что, если вы строите PVRB в своем блокчейне, вы с большой вероятностью придете к схеме BLS threshold signatures, ее уже используют несколько проектов. Например, DFinity (\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fdfinity\u002Frandom-beacon\"\u003Eздесь\u003C\u002Fa\u003E бенчмарк, реализующий схему, а \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fdfinity\u002Fvss\u002Fblob\u002Fmaster\u002Fdocs\u002Findex.md\"\u003Eтут\u003C\u002Fa\u003E пример реализации verifiable secret sharing), или Keep.network (вот их random beacon \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fkeep-network\u002Frandom-beacon-yellowpaper\"\u003Eyellowpaper\u003C\u002Fa\u003E, а вот \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fkeep-network\u002Frandom-beacon-box\"\u003Eпример\u003C\u002Fa\u003E смарт-контракта, обслуживающего протокол).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"implementaciya-pvrb\"\u003EИмплементация PVRB\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EК сожалению, до сих пор мы не видим готового, реализованного в блокчейнах PVRB протокола, доказавшего свою безопасность и устойчивость. Несмотря на то, что сами протоколы готовы, технически применить их к существующим решениям непросто. Для централизованных систем PVRB не имеет смысла, а децентрализованные строго ограничены во всех вычислительных ресурсах: CPU, memory, storage, I\u002FO. Проектирование PVRB — это комбинирование разных протоколов, чтобы все таки слепить то, что подойдет по всем требованиям хотя бы к какому нибудь жизнеспособному блокчейну. Один протокол эффективней вычисляет, но требует больше сообщений между RP, а другой требует крайне мало сообщений, но создание proof-а может быть задачей на десятки минут, а то и часов.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЯ перечислю факторы, которые вам придется учитывать при выборе качественного PVRB:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Cem\u003EКриптографическая стойкость\u003C\u002Fem\u003E. Ваш PVRB должен быть строго unbiasable, без возможности контроля единственного бита. В некоторых схемах это не так, поэтому зовите криптографа\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cem\u003EПроблема “last actor”\u003C\u002Fem\u003E. Ваш PVRB должен быть устойчив к атакам, когда атакующий, контролирующий одного или нескольких RP может выбирать один из двух вариантов результата.\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cem\u003EПроблема саботажа протокола\u003C\u002Fem\u003E. Ваш PVRB должен быть устойчив к атакам, когда атакующий, контролирующий одного или нескольких RP решает, быть ли рандому или нет и может гарантированно, либо с заданной вероятностью влиять на это\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cem\u003EПроблема количества сообщений\u003C\u002Fem\u003E. Ваши RP должны посылать в блокчейн минимум сообщений и максимально избегать синхронных действий типа ситуаций “я отправил некоторую информацию, жду ответа от конкретного участника”. В p2p сетях, особенно разнесенных географически, не стоит расчитывать на быстрый ответ\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cem\u003EПроблема вычислительной сложности\u003C\u002Fem\u003E. Верификация любого этапа PVRB on-chain должна быть крайне легкой, так как ее выполняют все полные клиенты сети. Если реализация делается с помощью смарт-контракта, то требования к скорости очень жесткие\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cem\u003EПроблема доступности и liveness\u003C\u002Fem\u003E. Ваш PVRB должен стремиться быть устойчивым к ситуациям, когда часть сети стала недоступной на некоторое время и часть RP просто перестала работать\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cem\u003EПроблема trusted setup и первоначального распределения ключей\u003C\u002Fem\u003E. Если ваш PVRB использует первичный setup протокола, то это отдельная большая и серьезная история. Вот \u003Ca href=\"https:\u002F\u002Fz.cash\u002Fru\u002Fblog\u002Fthe-design-of-the-ceremony\u002F\"\u003Eпример\u003C\u002Fa\u003E. Если участники должны перед начало протокола сообщить друг-другу свои ключи — это тоже проблема, если состав участников меняется\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cem\u003EПроблемы разработки\u003C\u002Fem\u003E. Наличие библиотек на нужных языках, их безопасность и производительность, публичность, сложные тесты и т.п.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EК примеру у threshold BLS подписей есть существенная проблема — перед тем как начать работать, участникам обязательно надо раздать друг другу ключи, организовав группу, в рамках которой будет работать threshold. Это означает, что как минимум один раунд обмена в децентрализованной сети придется выждать, а, учитывая, что генерируемый рандом, к примеру, необходим в играх, практически в realtime, это означает, что саботаж протокола возможен на этом этапе, и преимущества threshold схемы теряются. Эта проблема уже проще предыдущих, но все равно требует разработки отдельной процедуры формирования threshold-групп, которую придется защищать экономически, за счет депозитов и отъема средств(slashing) у участников, не следующих протоколу. Также, верификация BLS с приемлемым уровнем безопасности попросту не помещается, например, в стандартную транзакцию EOS или Ethereum — просто не хватает времени на верификацию. Код контрактов — это WebAssembly или EVM, исполняется виртуальной машиной. Криптографические функции не реализованы нативно(пока), и работают в десятки раз медленнее обычных криптографических библиотек. Многие протоколы не подходят по требованиям просто исходя из объема ключей, например это 1024 и 2048 bit для RSA, в 4-8 раз больше, чем стандартная подпись транзакции в Bitcoin и Ethereum.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИграет роль и наличие реализаций на разных языках программирования — которых немного, особенно для новых протоколов. Вариант с интеграцией в консенсус требует писать протокол на языке платформы, поэтому придется искать код на Go для geth, на Rust для Parity, на C++ для EOS. Код на JavaScript придется искать всем, а так как JavaScript и криптография не особо близкие друзья, поможет WebAssembly, который теперь уже точно претендует на роль следующего важного интернет-стандарта.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"zaklyuchenie\"\u003EЗаключение\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНадеюсь, в предыдущей \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F448330\u002F\"\u003Eстатье\u003C\u002Fa\u003E я сумел убедить вас, что генерация случайных чисел на блокчейне критически важна для множества аспектов жизни децентрализованных сетей, а этой статьей показал, что задача эта крайне амбициозная и непростая, но хорошие решения уже существуют. Вообще, окончательный дизайн протокола возможен лишь после проведения массивных тестов, учитывающих все аспекты от setup-а до эмуляции сбоев, поэтому вы вряд ли найдете готовые рецепты в whitepaper-ах команд и в статьях, да и мы в ближайший год-два точно не решимся писать “делайте так, так точно правильно”. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПока, для нашего PVRB в разрабатываемом блокчейне \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fmixbytes\u002Fhaya\"\u003EHaya\u003C\u002Fa\u003E, мы остановились на применении threshold BLS signatures, планируем реализовывать PVRB на уровне консенсуса, так как верификация в смарт-контрактах с приемлемым уровнем безопасности пока невозможна. Возможно, что мы используем сразу две схемы: сначала дорогую secret sharing для создания долгосрочного random_seed, а его используем далее в качестве основы для высокочастотной генерации рандома с помощью детерминированных threshold BLS подписей, возможно ограничимся лишь одной из схем. Сказать заранее, каким будет протокол, увы, невозможно, радует лишь то, что как и в науке, в инженерных задачах отрицательный результат — это тоже результат, и каждая новая попытка решить задачу является очередной ступенькой для изысканий всех, занимающихся проблемой. Для обеспечения требований со стороны бизнеса мы решаем конкретную практическую задачу — обеспечение игровых приложений надежным источником энтропии, поэтому нам приходится уделять внимание также самому блокчейну, в частности вопросам финальности цепочки и governance сети. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИ пусть мы пока не видим в блокчейнах доказанно стойкого PVRB, который использовался бы уже достаточно времени, чтобы пройти испытания настоящими приложениями, множественными аудитами, нагрузками, и конечно, же, реальными атаками, но число возможных путей подтверждает, что решение существует, и какой-то из этих алгоритмов в конце концов решит проблему. Мы с удовольствием будем делиться результатами и благодарим другие команды, которые тоже занимаются этим вопросом за статьи и код, которые позволяют инженерам не наступать дважды на одни и те же грабли. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТак что, встретив программиста, проектирующего децентрализованный рандом, будьте внимательны и заботливы, при необходимости окажите психологическую помощь :)\u003C\u002Fp\u003E\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"blockchain"},{"titleHtml":"random number generator"},{"titleHtml":"смарт-контракты"},{"titleHtml":"децентрализованные сети"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F452340\u002F11164206129fceeebb4b1e57f0042a9b\u002F","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F452340\u002F11164206129fceeebb4b1e57f0042a9b\u002F?format=vk","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F452340\\\u002F\"},\"headline\":\"Случайные числа и децентрализованные сети: имплементации\",\"datePublished\":\"2019-05-17T16:47:43+03:00\",\"dateModified\":\"2019-05-17T18:37:59+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"Сергей Прилуцкий\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"Введение function getAbsolutelyRandomNumer() {         return 4; \\\u002F\\\u002F returns absolutely random number! } Как и в случае с концепцией абсолютно стойкого шифра из к...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F452340\\\u002F#post-content-body\",\"about\":[\"h_p2p\",\"h_infosecurity\",\"h_crypto\",\"h_algorithms\",\"f_develop\",\"f_admin\"],\"image\":[\"https:\\\u002F\\\u002Fhabr.com\\\u002Fshare\\\u002Fpublication\\\u002F452340\\\u002F11164206129fceeebb4b1e57f0042a9b\\\u002F\"]}","metaDescription":"Введение\r\nfunction getAbsolutelyRandomNumer() {\n        return 4; \u002F\u002F returns absolutely random number!\n}\r\nКак и в случае с концепцией абсолютно стойкого шифра из криптографии, реальные протоколы...","mainImageUrl":null,"amp":false},"polls":[],"commentsEnabled":true,"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":false}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[],"hubs":"p2p,infosecurity,crypto,algorithms"},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{}},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"dfp":{"slotsDict":{}},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.c0af73e7.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
</body>
</html>
