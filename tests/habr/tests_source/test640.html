<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <title>Джулия в лабиринте / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.c0af73e7.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.85eb77f0b17c8235e7b64b9f81ea5ec2.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" src="/js/ads.js" onload="window['zhY4i4nJ9K'] = true" data-vmid="checkad"></script><script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/post\/451460\/"},"headline":"Джулия в лабиринте","datePublished":"2019-05-17T09:07:00+03:00","dateModified":"2019-05-17T10:20:17+03:00","author":{"@type":"Person","name":"Yermack"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"Разбирая одну олимпиадную задачу мы отправимся по петляющим коридорам генерации лабиринтов и их прохождения, а также увидим, что на языке Julia простота реализа...","url":"https:\/\/habr.com\/ru\/post\/451460\/#post-content-body","about":["h_crazydev","h_sport_programming","h_programming","h_julia","f_develop"],"image":["https:\/\/habrastorage.org\/webt\/u8\/d5\/ql\/u8d5qlyaxgezwbkmz-ybdtbj6r8.png","https:\/\/habrastorage.org\/webt\/q4\/k4\/u3\/q4k4u30s2syto7bpzmxysbrsymi.png","https:\/\/habrastorage.org\/webt\/ua\/xq\/lb\/uaxqlbjtneuolospp0kwc-bujbk.png","https:\/\/habrastorage.org\/webt\/6p\/hc\/pt\/6phcptlpnrfctsa7qmpdvhm5ele.png","https:\/\/habrastorage.org\/webt\/br\/yu\/ut\/bryuutpq3-vfqn0upm3s536lwhe.png","https:\/\/habrastorage.org\/webt\/rj\/9s\/bc\/rj9sbcpu5inbjiqvaphxnwaw10u.png","https:\/\/habrastorage.org\/webt\/c0\/v7\/ss\/c0v7sspjrcruoda7auy6h-rj_9o.gif","https:\/\/habrastorage.org\/webt\/oe\/hg\/ao\/oehgao7ny8sinfbnogcorqdfdsk.png","https:\/\/habrastorage.org\/webt\/kx\/2n\/zl\/kx2nzlhw-bylb1wjdjifjxvmfsq.png","https:\/\/habrastorage.org\/webt\/oy\/uo\/lm\/oyuolmopr9kmvmx07nn3kfdhufi.png","https:\/\/habrastorage.org\/webt\/p_\/dz\/uf\/p_dzufexrrmrvhmzxiwyh_nsfdc.gif","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/bd2\/36a\/859\/bd236a859d121c85d92d1acf80ba3597.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/6d6\/a4f\/78f\/6d6a4f78fbacd6edecc018ce8ad3e364.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/c62\/ff2\/5ef\/c62ff25ef4caeaeaef7122a489ef9d07.svg","https:\/\/habrastorage.org\/webt\/sk\/ok\/v6\/skokv6txgvsowgjewyqaht9ffb4.png","https:\/\/habrastorage.org\/webt\/xf\/ba\/jv\/xfbajvk-jw2iokdrizmq8suncik.gif","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/08c\/84d\/e45\/08c84de45586dceeb0d12296ca14c22f.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/560\/bd9\/7f2\/560bd97f235311a36dff00db005e6ab5.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/b8b\/97c\/656\/b8b97c6567171cc2b6a7f303a0fa8b0a.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/f07\/b1c\/7a4\/f07b1c7a48a22c879ec729e6ea01b4e0.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/bd3\/562\/df4\/bd3562df4007a53a10a6e430cebb3530.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/3a0\/7c2\/e37\/3a07c2e3770a2ee828755498f39fb059.svg","https:\/\/habrastorage.org\/getpro\/habr\/formulas\/96d\/121\/66c\/96d12166c34ab00f79f66055ed99c710.svg"]}</script>
  <script src="//www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.49.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_eng"><meta data-vue-meta="ssr" property="og:title" content="Джулия в лабиринте" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="Джулия в лабиринте" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="Джулия в лабиринте" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="Разбирая одну олимпиадную задачу мы отправимся по петляющим коридорам генерации лабиринтов и их прохождения, а также увидим, что на языке Julia простота реализаций алгоритмов граничит с их..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="Разбирая одну олимпиадную задачу мы отправимся по петляющим коридорам генерации лабиринтов и их прохождения, а также увидим, что на языке Julia простота реализаций алгоритмов граничит с их..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="Разбирая одну олимпиадную задачу мы отправимся по петляющим коридорам генерации лабиринтов и их прохождения, а также увидим, что на языке Julia простота реализаций алгоритмов граничит с их..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="Разбирая одну олимпиадную задачу мы отправимся по петляющим коридорам генерации лабиринтов и их прохождения, а также увидим, что на языке Julia простота реализаций алгоритмов граничит с их..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="Разбирая одну олимпиадную задачу мы отправимся по петляющим коридорам генерации лабиринтов и их прохождения, а также увидим, что на языке Julia простота реализаций алгоритмов граничит с их..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habr.com/share/publication/451460/9a865c2e249c18c0414cab396961e1e6/" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habr.com/share/publication/451460/9a865c2e249c18c0414cab396961e1e6/" data-vmid="og:image"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habr.com/share/publication/451460/9a865c2e249c18c0414cab396961e1e6/" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habr.com/share/publication/451460/9a865c2e249c18c0414cab396961e1e6/" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habr.com/share/publication/451460/9a865c2e249c18c0414cab396961e1e6/" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="451460" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2019-05-17T06:07:00.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/451460/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="https://habr.com/ru/post/451460/" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habr.com/share/publication/451460/9a865c2e249c18c0414cab396961e1e6/" data-vmid="image:href">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="/ru/sandbox/start/" class="tm-header__become-author-btn">
            Как стать автором
          </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="/ru/all/" class="tm-main-menu__item">
        Все потоки
      </a> <a href="/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" data-async-called="true" class="tm-page"><div class="tm-page-width"><!----> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="/ru/users/Yermack/" title="Yermack" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="" height="24" loading="lazy" src="//habrastorage.org/r/w32/getpro/habr/avatars/690/140/823/690140823f555d03574a59d46f648d24.jpg" width="24" class="tm-entity-image__pic"></div></a> <span class="tm-user-info__user"><a href="/ru/users/Yermack/" class="tm-user-info__username">
      Yermack
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2019-05-17T06:07:00.000Z" title="2019-05-17, 09:07">17  мая  2019 в 09:07</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>Джулия в лабиринте</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/crazydev/" class="tm-article-snippet__hubs-item-link"><span>Ненормальное программирование</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/sport_programming/" class="tm-article-snippet__hubs-item-link"><span>Спортивное программирование</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/programming/" class="tm-article-snippet__hubs-item-link"><span>Программирование</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/julia/" class="tm-article-snippet__hubs-item-link"><span>Julia</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span></div> <div class="tm-article-snippet__labels"><div class="tm-article-snippet__label"><span>
        Tutorial
      </span></div></div> <!----> <!----></div></div> <!----> <div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-1"><div xmlns="http://www.w3.org/1999/xhtml"><p><img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/u8/d5/ql/u8d5qlyaxgezwbkmz-ybdtbj6r8.png"/></p><br/>
<p>Разбирая одну олимпиадную задачу мы отправимся по петляющим коридорам генерации лабиринтов и их прохождения, а также увидим, что на языке Julia простота реализаций алгоритмов граничит с их псевдокодом. </p><a name="habracut"></a><br/>
<h1 id="zadacha">Задача</h1><br/>
<p>Лабиринт представляет собой клетчатый квадрат 10 на 10, в некоторых клетках стоят препятствия, а в одной клетке находится выход. Робот находится в таком лабиринте и может выполнять 4 команды: сдвинуться на одну клетку вниз, вверх, вправо или влево. Если робот пытается выйти за границы лабиринта или перейти в клетку с препятствием, то он остается на месте. Если робот попадает в выход, то он выходит из лабиринта и дальнейшие команды игнорирует. Напишите программу для робота, исполняя которую робот в любом случае доберется до выхода вне зависимости от клетки, в которой он находился вначале. Программа должна состоять из не более чем 1000 команд.</p><br/>
<p><img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/q4/k4/u3/q4k4u30s2syto7bpzmxysbrsymi.png"/></p><br/>
<h3 id="format-vvoda">Формат ввода</h3><br/>
<p>Ввода нет. Нужно написать программу для одного конкретного указанного в условии<br/>
лабиринта.<br/>
Версия лабиринта, которую можно скопировать. 0 — свободная клетка, 1 — препятствие, x —<br/>
выход.</p><br/>
<pre><code class="plaintext">0011010011
0100001000
0110x00000
0010000100
0000111000
0000100100
0000010010
0100101010
0011001010
1000011000</code></pre><br/>
<h3 id="format-vyvoda">Формат вывода</h3><br/>
<p>Одна строка, состоящая из символов U,D,R,L длины не более 1000 </p><br/>
<h2 id="podgotovka">Подготовка</h2><br/>
<p>Тем, кто не работал с графикой в Julia нужно докачать пакеты</p><br/>
<pre><code class="julia">using Pkg
Pkg.add("Plots")
Pkg.add("Colors")
Pkg.add("Images")
Pkg.build("Images") # если сам не отбилдится</code></pre><br/>
<p>Удобней всего работать в Jupyter, так как картинки будут отображаться непосредственно по ходу работы. <a href="https://github.com/YermolenkoIgor/Julia_tutorial_rus">Здесь можно найти</a> про установку, а также введение и задания для начинающих.</p><br/>
<p>В условии нашей задачи есть версия лабиринта для копирования</p><br/>
<pre><code class="julia">S0 = "0011010011
0100001000
0110x00000
0010000100
0000111000
0000100100
0000010010
0100101010
0011001010
1000011000"</code></pre><br/>
<p>Чтоб рисовать лабиринт, нужно составить матрицу. Так как не хочется расставлять пробелы вручную, поработаем со строкой:</p><br/>
<pre><code class="julia">S1 = prod(s-> s*' ', '['*S0*']')
# prod(fun, arr) перемножает элементы массива arr 
# прогоняя их через функцию fun
# в julia операция * склеивает строки

"[ 0 0 1 1 0 1 0 0 1 1 \n 0 1 0 0 0 0 1 0 0 0 \n 0 1 1 0 x 0 0 0 0 0 \n 0 0 1 0 0 0 0 1 0 0 \n 0 0 0 0 1 1 1 0 0 0 \n 0 0 0 0 1 0 0 1 0 0 \n 0 0 0 0 0 1 0 0 1 0 \n 0 1 0 0 1 0 1 0 1 0 \n 0 0 1 1 0 0 1 0 1 0 \n 1 0 0 0 0 1 1 0 0 0 ] "</code></pre><br/>
<p>Заменив несуразную букву <em>х</em> на цифру и отпарсив строку, получим целочисленную матрицу задающую наш лабиринт. Затем, для большего удобства, поменяем единички на нули, а нули на единицы, и обнесем лабиринт стеной:</p><br/>
<pre><code class="julia">S2 = replace(S1, 'x'=>'9')
M0 = S2 |> Meta.parse |> eval

m,n = size(M0)
M1 = replace(M0, 1=>0, 0=>1)
M = zeros(Int64,m+2,n+2)
for i in 2:m+1, j in 2:n+1
    M[i,j] = M1[i-1,j-1]
end
M # Maze map matrix 

12×12 Array{Int64,2}:
 0  0  0  0  0  0  0  0  0  0  0  0
 0  1  1  0  0  1  0  1  1  0  0  0
 0  1  0  1  1  1  1  0  1  1  1  0
 0  1  0  0  1  9  1  1  1  1  1  0
 0  1  1  0  1  1  1  1  0  1  1  0
 0  1  1  1  1  0  0  0  1  1  1  0
 0  1  1  1  1  0  1  1  0  1  1  0
 0  1  1  1  1  1  0  1  1  0  1  0
 0  1  0  1  1  0  1  0  1  0  1  0
 0  1  1  0  0  1  1  0  1  0  1  0
 0  0  1  1  1  1  0  0  1  1  1  0
 0  0  0  0  0  0  0  0  0  0  0  0</code></pre><br/>
<p>В матрице</p><br/>
<pre><code class="julia">length(M)
144</code></pre><br/>
<p>клетки, и из них </p><br/>
<pre><code class="julia">sum(M)-9 
70</code></pre><br/>
<p>по которым можно ходить, то есть — потенциальных стартовых позиций. Изобразить результат можно построив двумерную гистограмму</p><br/>
<pre><code class="julia">using Plots
heatmap(M, yaxis = :flip) # flip - инвертирует ось</code></pre><br/>
<p><img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/ua/xq/lb/uaxqlbjtneuolospp0kwc-bujbk.png"/></p><br/>
<h2 id="proverka-resheniya">Проверка решения</h2><br/>
<p>Прежде всего, нужно отработать процедуры, которые будут проверять правильность предложенного решения. Зададим составной тип <code>Point</code>, чтобы пользоваться терминологией точек и координат:</p><br/>
<pre><code class="julia">mutable struct Point
    x::Int64 # vertical
    y::Int64 # horisont
    Point(x, y) = new(x, y)
end</code></pre><br/>
<p>А теперь нужно научиться переводить последовательность команд понятных для робота в код.</p><br/>
<p>Мысль довольно проста: есть стартовая координата, приходит строка с алгоритмом, говорящим как ходить. Берем по одной буковке и смотрим, на какую из соседних клеток наступать. К текущей координате прибавляем значение которое хранится в этой клетке. То есть, если там ноль (стена), мы никуда не сдвинулись, иначе — сделали шажок в требуемом направлении. </p><br/>
<p>Можно воспользовавшись мощью метапрограммирования заменить поступающую последовательность направлений на громоздкий однообразный код и выполнить его</p><br/>
<pre><code class="julia">S = "RRLDUURULDDRDDRRRUUU"

S1 = replace(S , "R"=>"c.y+=M[c.x, c.y+1];")
S1 = replace(S1, "L"=>"c.y-=M[c.x, c.y-1];")
S1 = replace(S1, "U"=>"c.x+=M[c.x+1, c.y];")
S1 = replace(S1, "D"=>"c.x-=M[c.x-1, c.y];")
# с - start point
Sp = eval( Meta.parse(S1) )</code></pre><br/>
<p>Но этот способ несет за собой ряд неудобств, поэтому воспользуемся классическими условными операторами. Кстати, в том что выход обозначен цифрой 9 есть небольшая хитрость: чтоб не проверять каждую клетку, а не выход ли это, мы инициируем передвижение прибавляя значение хранящееся в конкретной клетке. Когда робот наступает на выход к его координате присуммируется заведомо большое число, такое что робот вылетает за границы массива, что можно отловить как ошибку с помощью блока:</p><br/>
<pre><code class="julia">try
    # если здесь произошла ошибка
catch
    # то выполняются действия из этого поля
end</code></pre><br/>
<p>Таким образом реализуем функцию, которая будет проверять, достигает ли робот выхода стартуя из точки <code>c</code> выполняя команды из строки <code>str</code>:</p><br/>
<pre><code class="julia">function isexit(str, c)
    scatter!([c.y],[c.x])
    try
        for s in str
            if s == 'R'
                c.y+=M[c.x, c.y+1];

            elseif s == 'L' 
                c.y-=M[c.x, c.y-1];

            elseif s == 'U'
                c.x+=M[c.x+1, c.y];

            elseif s == 'D'
                c.x-=M[c.x-1, c.y];

            else
                 println("Error! Use only R, L, U, D")
            end

        end
    catch
        return true
    end
    return false
end</code></pre><br/>
<p>Соберем функцию, которая переберет все стартовые позиции</p><br/>
<pre><code class="julia">function test(Str)
    k = 0
    for i in 2:m+1, j in 2:n+1
        if M[i,j] == 1
            c = Point(i, j)
            a = isexit(S,c)
            if a
                k +=1
                #println(a)
            end
        end
    end
    println(k, " test completed from ", sum(M)-9)
end</code></pre><br/>
<p>Проверим команды:</p><br/>
<pre><code class="julia">S = "RRRLDUUURRRUUURRRRLLLRRUULDDDDRRRRDDDRRRUUU"
heatmap(M, yaxis = :flip)
test(S)
# 10 test completed from 70
plot!(legend = false)</code></pre><br/>
<p><img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/6p/hc/pt/6phcptlpnrfctsa7qmpdvhm5ele.png"/><br/>
Опробованы все стартовые точки, и только 10 привели к выходу. Нужно построить маршруты от каждой точки до выхода.</p><br/>
<p>Прежде чем погрузиться в генерацию и прохождение лабиринтов, сохраним наши результаты. Воспользуемся пакетом <a href="https://juliaimages.org/latest/quickstart/">Images.jl</a> предоставляющим множество возможностей в области обработки изображений (<a href="https://github.com/YermolenkoIgor/Julia_tutorial_rus/blob/master/intro/compressing_an_image.ipynb">наглядный пример</a>). Одним из его вспомогательных инструментов является пакет <a href="http://juliagraphics.github.io/Colors.jl/stable/index.html">Colors.jl</a> расширяющий возможности Джулии работой с цветами.</p><br/>
<pre><code class="julia">using Images
clrs(x) = x==9 ? RGB(1.,0.5,0) : RGB(x,x,x)
maze = clrs.(M)
# maze = Gray.(maze)
# save("D:/dat/maze12x12.png", maze)</code></pre><br/>
<p><img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/br/yu/ut/bryuutpq3-vfqn0upm3s536lwhe.png"/></p><br/>
<h2 id="poisk-v-glubinu">Поиск в глубину</h2><br/>
<p>Реализована идея из <a href="https://habr.com/ru/post/262345/">статьи на хабре</a>.<br/>
Идея проста: создаем сетку из стен</p><br/>
<pre><code class="julia">M = 10
N = 10
A = [ i&amp;j&amp;1 for i in 0:N, j in 0:M ] # isodd(i) &amp; isodd(j) &amp; 1
Gray.(A) # from Images.jl</code></pre><br/>
<p><img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/rj/9s/bc/rj9sbcpu5inbjiqvaphxnwaw10u.png"/></p><br/>
<p>затем, петляя пробиваем маршрут и ответвления. Зададим функцию находящую соседние непосещенные области (будем обозначать их, скажем, двойкой) и возвращающую одного из этих соседей (если непосещенных соседей нет — возвращает флаг-точку):</p><br/>
<pre><code class="julia">function neighbours2(A,p, n, m)
    nbrs = [Point(p.x, p.y+2), # up
            Point(p.x, p.y-2), # down
            Point(p.x-2, p.y), # left
            Point(p.x+2, p.y)] # right
    goal = []
    for a in nbrs
        if 0&lt;a.x&lt;=n &amp;&amp; 0&lt;a.y&lt;=m &amp;&amp; A[a.x,a.y]==2
            push!(goal, a)
        end
    end
    length(goal) != 0 ? rand(goal) : Point(-1,-1)
end</code></pre><br/>
<p>Стены будем разбивать так:</p><br/>
<pre><code class="julia">function breakwall(A, newp,oldp)
    # координата стены:
    x = (newp.x + oldp.x) >> 1 # побитовый сдвиг
    y = (newp.y + oldp.y) >> 1
    A[x,y] = 1
end</code></pre><br/>
<h4 id="algoritm">Алгоритм</h4><br/>
<ol>
<li>Сделайте начальную клетку текущей и отметьте ее как посещенную. </li>
<li>Пока есть непосещенные клетки<br/>
  1. Если текущая клетка имеет непосещенных «соседей»<br/>
    1. Протолкните текущую клетку в стек<br/>
    2. Выберите случайную клетку из соседних<br/>
    3. Уберите стенку между текущей клеткой и выбранной<br/>
    4. Сделайте выбранную клетку текущей и отметьте ее как посещенную.<br/>
  2. Иначе если стек не пуст<br/>
    1. Выдерните клетку из стека<br/>
    2. Сделайте ее текущей<br/>
  3. Иначе<br/>
    1. Выберите случайную непосещенную клетку, сделайте ее текущей и отметьте как посещенную.</li>
</ol><br/>
<div class="spoiler"><b class="spoiler_title">Код программы</b><div class="spoiler_text"><pre><code class="julia">function amazeng(n, m)

    M = [ 2(i&amp;j&amp;1) for i in 0:n, j in 0:m ];
    p = Point(2,2) # стартовая точа
    lifo = [] # пустой массив
    push!(lifo, p)
    #i = 0
    while length(lifo) != 0 # пока не опустеет стек
        M[p.x,p.y] = 1 # отметим белым посещенную клетку
        np = neighbours2(M, p, n, m) # new point
        # если нет соседей - идём обратно
        if np.x == np.y == -1
            p = pop!(lifo)
        else
            push!(lifo, p)
            breakwall(M, np, p)
            p = np
            #i+=1
            #maze = Gray.(M/2)
            #save("D:/dat/maze$i.png", maze)
        end
    end

    M[1,2] = 1 # вход
    M[n,m+1] = 1 # выход

    Gray.(M)
end</code></pre></div></div><br/>
<pre><code class="julia">lbrnt = amazeng(36, 48)
# save("D:/dat/maze111.png", lbrnt)</code></pre><br/>
<p><img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/c0/v7/ss/c0v7sspjrcruoda7auy6h-rj_9o.gif"/></p><br/>
<p><img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/oe/hg/ao/oehgao7ny8sinfbnogcorqdfdsk.png"/></p><br/>
<h4 id="algoritm-poiska-puti-bektrekingom">Алгоритм поиска пути бэктрекингом:</h4><br/>
<ol>
<li>Сделайте начальную клетку текущей и отметьте ее как посещенную. </li>
<li>Пока не найден выход<br/>
  1. Если текущая клетка имеет непосещенных «соседей»<br/>
    1. Протолкните текущую клетку в стек<br/>
    2. Выберите случайную клетку из соседних<br/>
    3. Сделайте выбранную клетку текущей и отметьте ее как посещенную.<br/>
  2. Иначе если стек не пуст<br/>
    1. Выдерните клетку из стека<br/>
    2. Сделайте ее текущей<br/>
  3. Иначе выхода нет</li>
</ol><br/>
<p>Соседей ищем наоборот и в радиусе одной клетки, а не через одну:</p><br/>
<pre><code class="julia">function neighbours1(A, p, n, m)
    nbrs = [Point(p.x, p.y+1), # up
            Point(p.x, p.y-1), # down
            Point(p.x-1, p.y), # left
            Point(p.x+1, p.y)] # right
    goal = []
    for a in nbrs
        if 0&lt;a.x&lt;=n &amp;&amp; 0&lt;a.y&lt;=m &amp;&amp; A[a.x,a.y]==1
            push!(goal, a)
        end
    end
    length(goal) != 0 ? rand(goal) : Point(0,0)
end</code></pre><br/>
<p>Зададим алгоритм прохождения лабиринта с отрисовкой маршрута и неудачных попыток</p><br/>
<pre><code class="julia">function amazeng(img, start, exit)
    M = Float64.(channelview(img))
    n, m = size(M)
    p = start
    M[exit.x,exit.y] = 1

    lifo = []
    push!(lifo, p)

    while p.x != exit.x || p.y != exit.y

        M[p.x,p.y] = 0.4
        np = neighbours1(M, p, n, m)
        if np.x == np.y == 0
            M[p.x,p.y] = 0.75
            p = pop!(lifo)
# числа  - оттенки серого, чтоб выделить маршрут
# можно поставить функции задающие цвета
        else
            push!(lifo, p)
            p = np
        end
    end

    Gray.(M)
end</code></pre><br/>
<p>Как некоторые заметили, функция называется также, как и та, что алгоритмы генерирует (Множественная диспетчеризация). При вызове ее с двумя числами, отработает метод конструирования лабиринта, если же вызвать, задав в качестве аргумента изображение и две точки (координаты входа и выхода), то на выходе получим изображение с пройденным лабиринтом</p><br/>
<pre><code class="julia">img0 = load("D:/dat/maze111.png")
amazeng(img0)</code></pre><br/>
<p><img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/kx/2n/zl/kx2nzlhw-bylb1wjdjifjxvmfsq.png"/></p><br/>
<p>Отпробуем на нашем лабиринте:</p><br/>
<pre><code class="julia">img0 = load("D:/dat/maze12x12.png")
n, m = size(img0)
amazeng(img0, Point(11,9), Point(4,6) )</code></pre><br/>
<p><img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/oy/uo/lm/oyuolmopr9kmvmx07nn3kfdhufi.png"/></p><br/>
<p>Даже если модифицировать функцию, чтоб запоминался маршрут, всё равно из-за открытых пространств алгоритм показывает себя неэффективным. Зато лабиринты выходят отличные.</p><br/>
<h3 id="randomizirovannyy-algoritm-prima">Рандомизированный алгоритм Прима</h3><br/>
<p>Уж как начнешь рисовать лабиринты, так и не остановиться. Выполним еще один интересный <a href="https://en.wikipedia.org/wiki/Maze_generation_algorithm">алгоритм</a>:</p><br/>
<ul>
<li>Начать с сетки, полной стен.</li>
<li>Выберите ячейку, отметьте ее как часть лабиринта. Добавьте стены ячейки в список стен.</li>
<li>Пока в списке есть стены:<br/>
<ul>
<li>Выберите случайную стену из списка. Если посещена только одна из двух ячеек, которые разделяет стена, то:<br/>
<ul>
<li>Сделайте стену проходом и отметьте непосещенную клетку как часть лабиринта.</li>
<li>Добавьте соседние стены ячейки в список стен.</li>
</ul></li>
<li>Убрать стену из списка.</li>
</ul></li>
</ul><br/>
<div class="spoiler"><b class="spoiler_title">Код</b><div class="spoiler_text"><pre><code class="julia">neighbors(p::Point) = [Point(p.x, p.y+1), # up
                    Point(p.x, p.y-1), # down
                    Point(p.x-1, p.y), # left
                    Point(p.x+1, p.y)] # right

function newalls!(walls, p, maze, n, m)

    nbrs = neighbors(p)
    for a in nbrs
        if 1&lt;a.x&lt;n-1 &amp;&amp; 1&lt;a.y&lt;m-1 &amp;&amp; !maze[a.x,a.y]
            push!(walls, a) # Добавьте соседние стены ячейки в список стен.
        end
    end
end

function breakwall!(p, maze, n, m)

    nbrs = neighbors(p)
    # если среди соседей есть белая клетка
    if sum( a-> maze[a.x,a.y], nbrs) == 1
        for a in nbrs
            if  maze[a.x,a.y]
                # true =  белая
                p.x == a.x ? nx = p.x : p.x>a.x ? nx = p.x+1 : nx = p.x-1
                p.y == a.y ? ny = p.y : p.y>a.y ? ny = p.y+1 : ny = p.y-1
                maze[p.x,p.y] = true # соединить коридоры
                maze[nx,ny] = true
                p.x = nx
                p.y = ny
                return true
            end
        end
    else
        return false
    end
end

function prim(n, m)

    M = falses(n,m); # всё заполнено стенами
    p = Point(2, 2)
    M[p.x,p.y] = true

    walls = []
    newalls!(walls, p, M, n, m)

    while length(walls) != 0
        p = splice!( walls, rand(1:length(walls)) )

        if breakwall!(p, M, n, m)
            newalls!(walls, p, M, n, m)
        end

    end

    M
end</code></pre></div></div><br/>
<pre><code class="julia">primaze = prim(19,19);
Gray.(primaze)</code></pre><br/>
<p><img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/p_/dz/uf/p_dzufexrrmrvhmzxiwyh_nsfdc.gif"/></p><br/>
<p>Получается более ветвисто и не менее потрясно, особенно процесс сборки.</p><br/>
<p>А теперь имплементируем наиболее распространенный алгоритм нахождения кратчайшего маршрута:</p><br/>
<h3 id="metod-a">Метод A*</h3><br/>
<ul>
<li>Создается 2 списка вершин — ожидающие рассмотрения и уже рассмотренные. В ожидающие добавляется точка старта, список рассмотренных пока пуст.</li>
<li>Для каждой точки рассчитывается <img src="https://habrastorage.org/getpro/habr/formulas/bd2/36a/859/bd236a859d121c85d92d1acf80ba3597.svg" alt="$H$" data-tex="inline"/> — примерное расстояние от точки до цели. </li>
<li>Из списка точек на рассмотрение выбирается точка с наименьшим <img src="https://habrastorage.org/getpro/habr/formulas/bd2/36a/859/bd236a859d121c85d92d1acf80ba3597.svg" alt="$H$" data-tex="inline"/>. Обозначим ее <img src="https://habrastorage.org/getpro/habr/formulas/6d6/a4f/78f/6d6a4f78fbacd6edecc018ce8ad3e364.svg" alt="$X$" data-tex="inline"/>.</li>
<li>Если <img src="https://habrastorage.org/getpro/habr/formulas/6d6/a4f/78f/6d6a4f78fbacd6edecc018ce8ad3e364.svg" alt="$X$" data-tex="inline"/> — цель, то мы нашли маршрут.</li>
<li>Переносим <img src="https://habrastorage.org/getpro/habr/formulas/6d6/a4f/78f/6d6a4f78fbacd6edecc018ce8ad3e364.svg" alt="$X$" data-tex="inline"/> из списка ожидающих рассмотрения в список уже рассмотренных.</li>
<li>Для каждой из точек, соседних для <img src="https://habrastorage.org/getpro/habr/formulas/6d6/a4f/78f/6d6a4f78fbacd6edecc018ce8ad3e364.svg" alt="$X$" data-tex="inline"/> (обозначим эту соседнюю точку <img src="https://habrastorage.org/getpro/habr/formulas/c62/ff2/5ef/c62ff25ef4caeaeaef7122a489ef9d07.svg" alt="$Y$" data-tex="inline"/>), делаем следующее:<br/>
<ul>
<li>Если <img src="https://habrastorage.org/getpro/habr/formulas/c62/ff2/5ef/c62ff25ef4caeaeaef7122a489ef9d07.svg" alt="$Y$" data-tex="inline"/> уже находится в рассмотренных — пропускаем ее.</li>
<li>Если <img src="https://habrastorage.org/getpro/habr/formulas/c62/ff2/5ef/c62ff25ef4caeaeaef7122a489ef9d07.svg" alt="$Y$" data-tex="inline"/> еще нет в списке на ожидание — добавляем ее туда.</li>
</ul></li>
<li>Если список точек на рассмотрение пуст, а до цели мы так и не дошли — значит маршрут не существует.</li>
</ul><br/>
<p>Для начала зададим класс "точка" которая будет знать, как далеко она от цели:</p><br/>
<pre><code class="julia">mutable struct Point_h
    x::Int64 # horisont
    y::Int64 # vertical
    h::Float64

    Point_h(x, y) = new(x, y, 0.)
end</code></pre><br/>
<p>Теперь доопределим для структуры операцию сравнения, метод для установления наличия элемента в массиве, а также функции изъятия элемента, нахождения расстояния между точками и перечисления соседей:</p><br/>
<div class="spoiler"><b class="spoiler_title">Упрятано</b><div class="spoiler_text"><pre><code class="julia">import Base: in, ==

==(a::Point_h, b::Point_h) = a.x==b.x &amp;&amp; a.y==b.y

function in(p::Point_h, Arr::Array{Point_h,1})
    for a in Arr
        if a == p
            return true
        end
    end
    return false
end

function splicemin!(Arr)#::Array{Point_h,1}
    i = argmin( [a.h for a in Arr] )
    splice!(Arr, i)
end

dista(u,v) = hypot(v.x-u.x, v.y-u.y) # &lt;=> sqrt( (v.x-u.x)^2 + (v.y-u.y)^2 )

neighbors(p::Point_h) = [Point_h(p.x, p.y+1), # up
                    Point_h(p.x, p.y-1), # down
                    Point_h(p.x-1, p.y), # left
                    Point_h(p.x+1, p.y)] # right</code></pre></div></div><br/>
<p>Как всегда, непонятные операторы можно разъяснить с помощью команды <code>?</code>, например <code>?splice</code>, <code>?argmin</code>.</p><br/>
<p>И, собственно, сам метод A*</p><br/>
<div class="spoiler"><b class="spoiler_title">Код</b><div class="spoiler_text"><pre><code class="julia">function astar(M, start, final)
    # хорошая точка - не стена и не за границами
    isgood(p) = 1&lt;p.x&lt;n &amp;&amp; 1&lt;p.y&lt;m &amp;&amp; M[p.x,p.y] != 0

    n, m = size(M)
# как далеко от старта до цели
    start.h = dista(start,final)

    closed = []
    opened = []
    push!(opened, start)

    while length(opened) != 0

        X = splicemin!(opened)

        if X in closed
            continue
        end
        if X == final
            break
        end
        push!(closed, X)

        nbrs = neighbors(X)
        ygrex = filter(isgood, nbrs)

        for Y in ygrex

            if Y in closed
                continue
            else
                Y.h = dista(Y, final)
                push!(opened, Y)
            end
        end
    end
# возвращаем все посещенные
    closed # return
end</code></pre></div></div><br/>
<p>Загружаем картинку с лабиринтом и представляем ее в виде матрицы:</p><br/>
<pre><code class="julia">img0 = load("D:/dat/maze0.png") 
mazematrix = Float64.(channelview(img0))</code></pre><br/>
<p>И строим маршрут до выхода из произвольной точки:</p><br/>
<pre><code class="julia">s = Point_h(11,9) # start
f = Point_h(4,6) # finish

M = copy(mazematrix)
route = astar(M, s, f)

i = 1
for c in route
    # рисует маршрут
    M[c.x,c.y] = 0.7
    #save("D:/dat/Astar$i.png", M)
    i+=1
end
Gray.(M)</code></pre><br/>
<p><img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/sk/ok/v6/skokv6txgvsowgjewyqaht9ffb4.png"/></p><br/>
<p>А поиск из всех позиций выглядит так:</p><br/>
<p><img src="/img/image-loader.svg" data-src="https://habrastorage.org/webt/xf/ba/jv/xfbajvk-jw2iokdrizmq8suncik.gif"/></p><br/>
<p>Видно, что агент <del>прёт</del> всегда стремится в сторону выхода и частенько заворачивает в тупики, что порождает лишние шаги, а запоминается-то весь маршрут. Это избегается чуть более сложным вариантом алгоритма А*</p><br/>
<ul>
<li>Создается 2 списка вершин — ожидающие рассмотрения и уже рассмотренные. В ожидающие добавляется точка старта, список рассмотренных пока пуст. </li>
<li>Для каждой точки рассчитывается <img src="https://habrastorage.org/getpro/habr/formulas/08c/84d/e45/08c84de45586dceeb0d12296ca14c22f.svg" alt="$F = G + H$" data-tex="inline"/>. <img src="https://habrastorage.org/getpro/habr/formulas/560/bd9/7f2/560bd97f235311a36dff00db005e6ab5.svg" alt="$G$" data-tex="inline"/> — расстояние от старта до точки, <img src="https://habrastorage.org/getpro/habr/formulas/bd2/36a/859/bd236a859d121c85d92d1acf80ba3597.svg" alt="$H$" data-tex="inline"/> — примерное расстояние от точки до цели. Так же каждая точка хранит ссылку на точку, из которой в нее пришли. </li>
<li>Из списка точек на рассмотрение выбирается точка с наименьшим <img src="https://habrastorage.org/getpro/habr/formulas/b8b/97c/656/b8b97c6567171cc2b6a7f303a0fa8b0a.svg" alt="$F$" data-tex="inline"/>. Обозначим ее <img src="https://habrastorage.org/getpro/habr/formulas/6d6/a4f/78f/6d6a4f78fbacd6edecc018ce8ad3e364.svg" alt="$X$" data-tex="inline"/>. </li>
<li>Если <img src="https://habrastorage.org/getpro/habr/formulas/6d6/a4f/78f/6d6a4f78fbacd6edecc018ce8ad3e364.svg" alt="$X$" data-tex="inline"/> — цель, то мы нашли маршрут.</li>
<li>Переносим <img src="https://habrastorage.org/getpro/habr/formulas/6d6/a4f/78f/6d6a4f78fbacd6edecc018ce8ad3e364.svg" alt="$X$" data-tex="inline"/> из списка ожидающих рассмотрения в список уже рассмотренных.</li>
<li>Для каждой из точек, соседних для <img src="https://habrastorage.org/getpro/habr/formulas/6d6/a4f/78f/6d6a4f78fbacd6edecc018ce8ad3e364.svg" alt="$X$" data-tex="inline"/> (обозначим эту соседнюю точку <img src="https://habrastorage.org/getpro/habr/formulas/c62/ff2/5ef/c62ff25ef4caeaeaef7122a489ef9d07.svg" alt="$Y$" data-tex="inline"/>), делаем следующее:<br/>
<ul>
<li>Если <img src="https://habrastorage.org/getpro/habr/formulas/c62/ff2/5ef/c62ff25ef4caeaeaef7122a489ef9d07.svg" alt="$Y$" data-tex="inline"/> уже находится в рассмотренных — пропускаем ее.</li>
<li>Если <img src="https://habrastorage.org/getpro/habr/formulas/c62/ff2/5ef/c62ff25ef4caeaeaef7122a489ef9d07.svg" alt="$Y$" data-tex="inline"/> еще нет в списке на ожидание — добавляем ее туда, запомнив ссылку на <img src="https://habrastorage.org/getpro/habr/formulas/6d6/a4f/78f/6d6a4f78fbacd6edecc018ce8ad3e364.svg" alt="$X$" data-tex="inline"/> и рассчитав <img src="https://habrastorage.org/getpro/habr/formulas/f07/b1c/7a4/f07b1c7a48a22c879ec729e6ea01b4e0.svg" alt="$Y.G$" data-tex="inline"/> (это <img src="https://habrastorage.org/getpro/habr/formulas/bd3/562/df4/bd3562df4007a53a10a6e430cebb3530.svg" alt="$X.G$" data-tex="inline"/> + расстояние от <img src="https://habrastorage.org/getpro/habr/formulas/6d6/a4f/78f/6d6a4f78fbacd6edecc018ce8ad3e364.svg" alt="$X$" data-tex="inline"/> до <img src="https://habrastorage.org/getpro/habr/formulas/c62/ff2/5ef/c62ff25ef4caeaeaef7122a489ef9d07.svg" alt="$Y$" data-tex="inline"/>) и <img src="https://habrastorage.org/getpro/habr/formulas/3a0/7c2/e37/3a07c2e3770a2ee828755498f39fb059.svg" alt="$Y.H$" data-tex="inline"/>.</li>
<li>Если же <img src="https://habrastorage.org/getpro/habr/formulas/c62/ff2/5ef/c62ff25ef4caeaeaef7122a489ef9d07.svg" alt="$Y$" data-tex="inline"/> в списке на рассмотрение — проверяем, если <img src="https://habrastorage.org/getpro/habr/formulas/bd3/562/df4/bd3562df4007a53a10a6e430cebb3530.svg" alt="$X.G$" data-tex="inline"/> + расстояние от <img src="https://habrastorage.org/getpro/habr/formulas/6d6/a4f/78f/6d6a4f78fbacd6edecc018ce8ad3e364.svg" alt="$X$" data-tex="inline"/> до <img src="https://habrastorage.org/getpro/habr/formulas/c62/ff2/5ef/c62ff25ef4caeaeaef7122a489ef9d07.svg" alt="$Y$" data-tex="inline"/> <img src="https://habrastorage.org/getpro/habr/formulas/96d/121/66c/96d12166c34ab00f79f66055ed99c710.svg" alt="$&lt; Y.G$" data-tex="inline"/>, значит мы пришли в точку <img src="https://habrastorage.org/getpro/habr/formulas/c62/ff2/5ef/c62ff25ef4caeaeaef7122a489ef9d07.svg" alt="$Y$" data-tex="inline"/> более коротким путем, заменяем <img src="https://habrastorage.org/getpro/habr/formulas/f07/b1c/7a4/f07b1c7a48a22c879ec729e6ea01b4e0.svg" alt="$Y.G$" data-tex="inline"/> на <img src="https://habrastorage.org/getpro/habr/formulas/bd3/562/df4/bd3562df4007a53a10a6e430cebb3530.svg" alt="$X.G$" data-tex="inline"/> + расстояние от <img src="https://habrastorage.org/getpro/habr/formulas/6d6/a4f/78f/6d6a4f78fbacd6edecc018ce8ad3e364.svg" alt="$X$" data-tex="inline"/> до <img src="https://habrastorage.org/getpro/habr/formulas/c62/ff2/5ef/c62ff25ef4caeaeaef7122a489ef9d07.svg" alt="$Y$" data-tex="inline"/>, а точку, из которой пришли в <img src="https://habrastorage.org/getpro/habr/formulas/c62/ff2/5ef/c62ff25ef4caeaeaef7122a489ef9d07.svg" alt="$Y$" data-tex="inline"/> на <img src="https://habrastorage.org/getpro/habr/formulas/6d6/a4f/78f/6d6a4f78fbacd6edecc018ce8ad3e364.svg" alt="$X$" data-tex="inline"/>.</li>
</ul></li>
<li>Если список точек на рассмотрение пуст, а до цели мы так и не дошли — значит маршрут не существует.</li>
</ul><br/>
<p>Но даже с лишними шагами наш вариант вполне укладывается в ограничение задачи, так что модификации программ будет вашим домашним заданием. </p><br/>
<p>До конца олимпиады осталось всего-ничего, а нам нужно еще научиться переводить результаты работы наших алгоритмов в команды вида <code>"RRLUUDL..."</code></p><br/>
<p>И вот после всех этих хождений по лабиринтам, можно предположить, что решение гораздо проще. <em>На самом деле простой вариант напрашивается сразу, но уж очень хотелось наделать красивых штук</em>.</p><br/>
<p>Если расположить нашего исполнителя в открытой местности и инициировать случайные блуждания, то он будет колебаться вблизи своей стартовой позиции. Но вот с введением стенок, часть направлений начнет гаситься, степеней свободы станет меньше, и с такими же входными данными агент переместится на большее расстояние.</p><br/>
<p>Вот наш вариант проверки команд на пригодность к вызволению робота из лабиринта:</p><br/>
<div class="spoiler"><b class="spoiler_title">Код</b><div class="spoiler_text"><pre><code class="julia">M = [ 0  0  0  0  0  0  0  0  0  0  0  0
 0  1  1  0  0  1  0  1  1  0  0  0
 0  1  0  1  1  1  1  0  1  1  1  0
 0  1  0  0  1  9  1  1  1  1  1  0
 0  1  1  0  1  1  1  1  0  1  1  0
 0  1  1  1  1  0  0  0  1  1  1  0
 0  1  1  1  1  0  1  1  0  1  1  0
 0  1  1  1  1  1  0  1  1  0  1  0
 0  1  0  1  1  0  1  0  1  0  1  0
 0  1  1  0  0  1  1  0  1  0  1  0
 0  0  1  1  1  1  0  0  1  1  1  0
 0  0  0  0  0  0  0  0  0  0  0  0]

mutable struct Point # point
    x::Int64 # vertical
    y::Int64 # horisont
    Point(x, y) = new(x, y)
end

function isexit(str, c)

    try
        for s in str
            if s == 'R'
                c.y+=M[c.x, c.y+1];

            elseif s == 'L' 
                c.y-=M[c.x, c.y-1];

            elseif s == 'U'
                c.x+=M[c.x+1, c.y];

            elseif s == 'D'
                c.x-=M[c.x-1, c.y];

            else
                 println("Error! Use only R, L, U, D")
            end

        end
    catch
        return true
    end
    return false
end

function test(Str)
    k = 0
    n, m = 10,10
    for i in 2:m+1, j in 2:n+1
        if M[i,j] == 1
            c = Point(i, j)
            a = isexit(S,c)
            if a
                k +=1
                #println(a)
            end
        end
    end
    println(k, " test completed from ", sum(M)-9)
end</code></pre></div></div><br/>
<p>Теперь достаточно генерировать случайные строки, пока не получится та, что сработает для всех стартовых позиций:</p><br/>
<pre><code class="julia">using Random
S = randstring("RLUD",200)

"RDRRRDLRLUULURUDUUDLLLLLULLUDRRURDLDLULLRLUUUDURUUUULRUDUURUUDLRLLULRLUDRRLRRULLDULRRRRULRLLDULRLDRUDURDRUUDUUDDDDDLURRRRDRDURRRDDLLDUURRRLDRUDLRLLRDDRLRRRDDLLLRUURDRLURDLLUULLLLUURLLULUDULDDLDLLRLDUD"

test(S)
41 test completed from 70</code></pre><br/>
<p>К тому же, можно было и не заморачиваться на счет теста. Достаточно было прочитать задание и сгенерировать рандомную максимально допустимую условием строку:</p><br/>
<pre><code class="julia">for i in 1:20
    S = randstring("RLUD",1000)
    test(S)
end

70 test completed from 70
70 test completed from 70
70 test completed from 70
70 test completed from 70
55 test completed from 70#
65 test completed from 70#
70 test completed from 70
70 test completed from 70
38 test completed from 70#
70 test completed from 70
70 test completed from 70
56 test completed from 70#
70 test completed from 70
70 test completed from 70
70 test completed from 70
16 test completed from 70#
70 test completed from 70
24 test completed from 70#
70 test completed from 70
70 test completed from 70</code></pre><br/>
<p>То есть с вероятностью в 70% строка прошла бы тесты.</p><br/>
<p>На этом всё. Желаю читателю удачного рандома, терпения и интуиции на очевидные решения.</p><br/>
<p>Для любознательных — ссылки для углубления в тему:</p><br/>
<ul>
<li><a href="http://www.astrolog.org/labyrnth/algrithm.htm">Полнейший экскурс в лабиринтогенерацию</a></li>
<li><a href="https://habr.com/ru/post/445378/">Русская версия</a></li>
<li><a href="https://habr.com/ru/post/320140/">Методы раз</a></li>
<li><a href="https://habr.com/ru/post/321210/">Методы два</a></li>
<li><a href="https://habr.com/ru/post/176671/">Алгоритм Эллера</a></li>
<li><a href="http://aivanov.com/maze-generator/">Онлайн генератор</a></li>
<li><a href="http://qiao.github.io/PathFinding.js/visual/">Методы нахождения пути между точками онлайн</a></li>
<li><a href="https://gcup.ru/publ/gamedev/algoritm_poiska_puti_jump_point_search/1-1-0-530">Алгоритм поиска пути Jump Point Search</a></li>
<li><a href="https://ru.wikipedia.org/wiki/A*">А* на Википедии</a></li>
<li><a href="http://theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html">Introduction to A*</a></li>
<li><a href="https://habr.com/ru/post/331192/">Введение в алгоритм A*</a></li>
<li><a href="https://habr.com/ru/post/444828/">Объяснение алгоритмов поиска пути</a></li>
<li><a href="https://www.behance.net/soonsang">Источник артов</a></li>
</ul></div></div> <!----> <!----></div> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bjulia%5D" class="tm-tags-list__link">julia</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%BB%D0%B0%D0%B1%D0%B8%D1%80%D0%B8%D0%BD%D1%82%D1%8B%5D" class="tm-tags-list__link">лабиринты</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%BE%D0%BB%D0%B8%D0%BC%D0%BF%D0%B8%D0%B0%D0%B4%D0%BD%D1%8B%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8%5D" class="tm-tags-list__link">олимпиадные задачи</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bastar%5D" class="tm-tags-list__link">astar</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%20%D0%B2%20%D0%B3%D0%BB%D1%83%D0%B1%D0%B8%D0%BD%D1%83%5D" class="tm-tags-list__link">поиск в глубину</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%20%D0%BF%D1%80%D0%B8%D0%BC%D0%B0%5D" class="tm-tags-list__link">алгоритм прима</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/hub/crazydev/" class="tm-hubs-list__link">
    Ненормальное программирование
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/sport_programming/" class="tm-hubs-list__link">
    Спортивное программирование
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/programming/" class="tm-hubs-list__link">
    Программирование
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/julia/" class="tm-hubs-list__link">
    Julia
  </a></li></ul></div></div></article></div> <!----></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_medium"><title>Всего голосов 28: ↑28 и ↓0</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-rating"></use></svg> <span title="Всего голосов 28: ↑28 и ↓0" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_medium">+28</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">7.8K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    69
  </span></button> <!----> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> </div></div> <!----> <!----> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="/ru/users/Yermack/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><img alt="" src="//habrastorage.org/getpro/habr/avatars/690/140/823/690140823f555d03574a59d46f648d24.jpg" class="tm-entity-image__pic"></div></a> <div class="tm-user-card__meta"><div title=" 159 голосов " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    137
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">170.1</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title_variant-article"><!----> <a href="/ru/users/Yermack/" class="tm-user-card__nickname tm-user-card__nickname_variant-article">
          @Yermack
        </a> <!----></div> <p class="tm-user-card__short-info tm-user-card__short-info_variant-article">Пользователь</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-article"><!----> <!----> <button type="submit" class="tm-user-card__button btn btn_transparent btn_small">
      Задонатить
    </button> <!----> <!----></div></div> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----></section> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="/ru/post/451460/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментарии 12 
    </span></a> <!----></div></div></div> <div class="tm-ad-banner__container tm-page-article__banner"><!----> <div id="articleBottomBanner" class="tm-ad-banner"></div></div> <!----> <!----> <!----> <!----> </div></div></div></div></div> <div class="tm-page__sidebar"><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__ads tm-layout-sidebar__ads_initial"><div class="tm-ad-banner__container tm-layout-sidebar__banner"><!----> <div id="sidebarBanner" class="tm-ad-banner"></div></div></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----> <!----></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/post/451460/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/post/451460/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2021 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"451460":{"id":"451460","timePublished":"2019-05-17T06:07:00+00:00","isCorporative":false,"lang":"ru","titleHtml":"Джулия в лабиринте","leadData":{"textHtml":"\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fu8\u002Fd5\u002Fql\u002Fu8d5qlyaxgezwbkmz-ybdtbj6r8.png\"\u003E\u003C\u002Fp\u003E\u003Cbr\u003E\r\n\u003Cp\u003EРазбирая одну олимпиадную задачу мы отправимся по петляющим коридорам генерации лабиринтов и их прохождения, а также увидим, что на языке Julia простота реализаций алгоритмов граничит с их псевдокодом. \u003C\u002Fp\u003E","imageUrl":null,"buttonTextHtml":"Читать дальше →","image":null},"editorVersion":"1.0","postType":"article","postLabels":[{"type":"tutorial","data":null}],"author":{"scoreStats":{"score":137,"votesCount":159},"rating":170.1,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":"410012874761117","paymentPayPalMe":null,"paymentWebmoney":null},"id":"1832999","alias":"Yermack","fullname":null,"avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F690\u002F140\u002F823\u002F690140823f555d03574a59d46f648d24.jpg","speciality":"Пользователь"},"statistics":{"commentsCount":12,"favoritesCount":69,"readingCount":7766,"score":28,"votesCount":28},"hubs":[{"relatedData":null,"id":"84","alias":"crazydev","type":"collective","title":"Ненормальное программирование","titleHtml":"Ненормальное программирование","isProfiled":true},{"relatedData":null,"id":"89","alias":"sport_programming","type":"collective","title":"Спортивное программирование","titleHtml":"Спортивное программирование","isProfiled":true},{"relatedData":null,"id":"359","alias":"programming","type":"collective","title":"Программирование","titleHtml":"Программирование","isProfiled":true},{"relatedData":null,"id":"18840","alias":"julia","type":"collective","title":"Julia","titleHtml":"Julia","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Cp\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fu8\u002Fd5\u002Fql\u002Fu8d5qlyaxgezwbkmz-ybdtbj6r8.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EРазбирая одну олимпиадную задачу мы отправимся по петляющим коридорам генерации лабиринтов и их прохождения, а также увидим, что на языке Julia простота реализаций алгоритмов граничит с их псевдокодом. \u003C\u002Fp\u003E\u003Ca name=\"habracut\"\u003E\u003C\u002Fa\u003E\u003Cbr\u002F\u003E\r\n\u003Ch1 id=\"zadacha\"\u003EЗадача\u003C\u002Fh1\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЛабиринт представляет собой клетчатый квадрат 10 на 10, в некоторых клетках стоят препятствия, а в одной клетке находится выход. Робот находится в таком лабиринте и может выполнять 4 команды: сдвинуться на одну клетку вниз, вверх, вправо или влево. Если робот пытается выйти за границы лабиринта или перейти в клетку с препятствием, то он остается на месте. Если робот попадает в выход, то он выходит из лабиринта и дальнейшие команды игнорирует. Напишите программу для робота, исполняя которую робот в любом случае доберется до выхода вне зависимости от клетки, в которой он находился вначале. Программа должна состоять из не более чем 1000 команд.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fq4\u002Fk4\u002Fu3\u002Fq4k4u30s2syto7bpzmxysbrsymi.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"format-vvoda\"\u003EФормат ввода\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВвода нет. Нужно написать программу для одного конкретного указанного в условии\u003Cbr\u002F\u003E\r\nлабиринта.\u003Cbr\u002F\u003E\r\nВерсия лабиринта, которую можно скопировать. 0 — свободная клетка, 1 — препятствие, x —\u003Cbr\u002F\u003E\r\nвыход.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003E0011010011\n0100001000\n0110x00000\n0010000100\n0000111000\n0000100100\n0000010010\n0100101010\n0011001010\n1000011000\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"format-vyvoda\"\u003EФормат вывода\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EОдна строка, состоящая из символов U,D,R,L длины не более 1000 \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"podgotovka\"\u003EПодготовка\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТем, кто не работал с графикой в Julia нужно докачать пакеты\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"julia\"\u003Eusing Pkg\nPkg.add(\"Plots\")\nPkg.add(\"Colors\")\nPkg.add(\"Images\")\nPkg.build(\"Images\") # если сам не отбилдится\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EУдобней всего работать в Jupyter, так как картинки будут отображаться непосредственно по ходу работы. \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FYermolenkoIgor\u002FJulia_tutorial_rus\"\u003EЗдесь можно найти\u003C\u002Fa\u003E про установку, а также введение и задания для начинающих.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ условии нашей задачи есть версия лабиринта для копирования\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"julia\"\u003ES0 = \"0011010011\n0100001000\n0110x00000\n0010000100\n0000111000\n0000100100\n0000010010\n0100101010\n0011001010\n1000011000\"\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЧтоб рисовать лабиринт, нужно составить матрицу. Так как не хочется расставлять пробелы вручную, поработаем со строкой:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"julia\"\u003ES1 = prod(s-\u003E s*' ', '['*S0*']')\n# prod(fun, arr) перемножает элементы массива arr \n# прогоняя их через функцию fun\n# в julia операция * склеивает строки\n\n\"[ 0 0 1 1 0 1 0 0 1 1 \\n 0 1 0 0 0 0 1 0 0 0 \\n 0 1 1 0 x 0 0 0 0 0 \\n 0 0 1 0 0 0 0 1 0 0 \\n 0 0 0 0 1 1 1 0 0 0 \\n 0 0 0 0 1 0 0 1 0 0 \\n 0 0 0 0 0 1 0 0 1 0 \\n 0 1 0 0 1 0 1 0 1 0 \\n 0 0 1 1 0 0 1 0 1 0 \\n 1 0 0 0 0 1 1 0 0 0 ] \"\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЗаменив несуразную букву \u003Cem\u003Eх\u003C\u002Fem\u003E на цифру и отпарсив строку, получим целочисленную матрицу задающую наш лабиринт. Затем, для большего удобства, поменяем единички на нули, а нули на единицы, и обнесем лабиринт стеной:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"julia\"\u003ES2 = replace(S1, 'x'=\u003E'9')\nM0 = S2 |\u003E Meta.parse |\u003E eval\n\nm,n = size(M0)\nM1 = replace(M0, 1=\u003E0, 0=\u003E1)\nM = zeros(Int64,m+2,n+2)\nfor i in 2:m+1, j in 2:n+1\n    M[i,j] = M1[i-1,j-1]\nend\nM # Maze map matrix \n\n12×12 Array{Int64,2}:\n 0  0  0  0  0  0  0  0  0  0  0  0\n 0  1  1  0  0  1  0  1  1  0  0  0\n 0  1  0  1  1  1  1  0  1  1  1  0\n 0  1  0  0  1  9  1  1  1  1  1  0\n 0  1  1  0  1  1  1  1  0  1  1  0\n 0  1  1  1  1  0  0  0  1  1  1  0\n 0  1  1  1  1  0  1  1  0  1  1  0\n 0  1  1  1  1  1  0  1  1  0  1  0\n 0  1  0  1  1  0  1  0  1  0  1  0\n 0  1  1  0  0  1  1  0  1  0  1  0\n 0  0  1  1  1  1  0  0  1  1  1  0\n 0  0  0  0  0  0  0  0  0  0  0  0\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ матрице\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"julia\"\u003Elength(M)\n144\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003Eклетки, и из них \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"julia\"\u003Esum(M)-9 \n70\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003Eпо которым можно ходить, то есть — потенциальных стартовых позиций. Изобразить результат можно построив двумерную гистограмму\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"julia\"\u003Eusing Plots\nheatmap(M, yaxis = :flip) # flip - инвертирует ось\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fua\u002Fxq\u002Flb\u002Fuaxqlbjtneuolospp0kwc-bujbk.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"proverka-resheniya\"\u003EПроверка решения\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПрежде всего, нужно отработать процедуры, которые будут проверять правильность предложенного решения. Зададим составной тип \u003Ccode\u003EPoint\u003C\u002Fcode\u003E, чтобы пользоваться терминологией точек и координат:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"julia\"\u003Emutable struct Point\n    x::Int64 # vertical\n    y::Int64 # horisont\n    Point(x, y) = new(x, y)\nend\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EА теперь нужно научиться переводить последовательность команд понятных для робота в код.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EМысль довольно проста: есть стартовая координата, приходит строка с алгоритмом, говорящим как ходить. Берем по одной буковке и смотрим, на какую из соседних клеток наступать. К текущей координате прибавляем значение которое хранится в этой клетке. То есть, если там ноль (стена), мы никуда не сдвинулись, иначе — сделали шажок в требуемом направлении. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EМожно воспользовавшись мощью метапрограммирования заменить поступающую последовательность направлений на громоздкий однообразный код и выполнить его\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"julia\"\u003ES = \"RRLDUURULDDRDDRRRUUU\"\n\nS1 = replace(S , \"R\"=\u003E\"c.y+=M[c.x, c.y+1];\")\nS1 = replace(S1, \"L\"=\u003E\"c.y-=M[c.x, c.y-1];\")\nS1 = replace(S1, \"U\"=\u003E\"c.x+=M[c.x+1, c.y];\")\nS1 = replace(S1, \"D\"=\u003E\"c.x-=M[c.x-1, c.y];\")\n# с - start point\nSp = eval( Meta.parse(S1) )\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНо этот способ несет за собой ряд неудобств, поэтому воспользуемся классическими условными операторами. Кстати, в том что выход обозначен цифрой 9 есть небольшая хитрость: чтоб не проверять каждую клетку, а не выход ли это, мы инициируем передвижение прибавляя значение хранящееся в конкретной клетке. Когда робот наступает на выход к его координате присуммируется заведомо большое число, такое что робот вылетает за границы массива, что можно отловить как ошибку с помощью блока:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"julia\"\u003Etry\n    # если здесь произошла ошибка\ncatch\n    # то выполняются действия из этого поля\nend\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТаким образом реализуем функцию, которая будет проверять, достигает ли робот выхода стартуя из точки \u003Ccode\u003Ec\u003C\u002Fcode\u003E выполняя команды из строки \u003Ccode\u003Estr\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"julia\"\u003Efunction isexit(str, c)\n    scatter!([c.y],[c.x])\n    try\n        for s in str\n            if s == 'R'\n                c.y+=M[c.x, c.y+1];\n\n            elseif s == 'L' \n                c.y-=M[c.x, c.y-1];\n\n            elseif s == 'U'\n                c.x+=M[c.x+1, c.y];\n\n            elseif s == 'D'\n                c.x-=M[c.x-1, c.y];\n\n            else\n                 println(\"Error! Use only R, L, U, D\")\n            end\n\n        end\n    catch\n        return true\n    end\n    return false\nend\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EСоберем функцию, которая переберет все стартовые позиции\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"julia\"\u003Efunction test(Str)\n    k = 0\n    for i in 2:m+1, j in 2:n+1\n        if M[i,j] == 1\n            c = Point(i, j)\n            a = isexit(S,c)\n            if a\n                k +=1\n                #println(a)\n            end\n        end\n    end\n    println(k, \" test completed from \", sum(M)-9)\nend\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПроверим команды:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"julia\"\u003ES = \"RRRLDUUURRRUUURRRRLLLRRUULDDDDRRRRDDDRRRUUU\"\nheatmap(M, yaxis = :flip)\ntest(S)\n# 10 test completed from 70\nplot!(legend = false)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002F6p\u002Fhc\u002Fpt\u002F6phcptlpnrfctsa7qmpdvhm5ele.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nОпробованы все стартовые точки, и только 10 привели к выходу. Нужно построить маршруты от каждой точки до выхода.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПрежде чем погрузиться в генерацию и прохождение лабиринтов, сохраним наши результаты. Воспользуемся пакетом \u003Ca href=\"https:\u002F\u002Fjuliaimages.org\u002Flatest\u002Fquickstart\u002F\"\u003EImages.jl\u003C\u002Fa\u003E предоставляющим множество возможностей в области обработки изображений (\u003Ca href=\"https:\u002F\u002Fgithub.com\u002FYermolenkoIgor\u002FJulia_tutorial_rus\u002Fblob\u002Fmaster\u002Fintro\u002Fcompressing_an_image.ipynb\"\u003Eнаглядный пример\u003C\u002Fa\u003E). Одним из его вспомогательных инструментов является пакет \u003Ca href=\"http:\u002F\u002Fjuliagraphics.github.io\u002FColors.jl\u002Fstable\u002Findex.html\"\u003EColors.jl\u003C\u002Fa\u003E расширяющий возможности Джулии работой с цветами.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"julia\"\u003Eusing Images\nclrs(x) = x==9 ? RGB(1.,0.5,0) : RGB(x,x,x)\nmaze = clrs.(M)\n# maze = Gray.(maze)\n# save(\"D:\u002Fdat\u002Fmaze12x12.png\", maze)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fbr\u002Fyu\u002Fut\u002Fbryuutpq3-vfqn0upm3s536lwhe.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"poisk-v-glubinu\"\u003EПоиск в глубину\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EРеализована идея из \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F262345\u002F\"\u003Eстатьи на хабре\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\nИдея проста: создаем сетку из стен\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"julia\"\u003EM = 10\nN = 10\nA = [ i&amp;j&amp;1 for i in 0:N, j in 0:M ] # isodd(i) &amp; isodd(j) &amp; 1\nGray.(A) # from Images.jl\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Frj\u002F9s\u002Fbc\u002Frj9sbcpu5inbjiqvaphxnwaw10u.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003Eзатем, петляя пробиваем маршрут и ответвления. Зададим функцию находящую соседние непосещенные области (будем обозначать их, скажем, двойкой) и возвращающую одного из этих соседей (если непосещенных соседей нет — возвращает флаг-точку):\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"julia\"\u003Efunction neighbours2(A,p, n, m)\n    nbrs = [Point(p.x, p.y+2), # up\n            Point(p.x, p.y-2), # down\n            Point(p.x-2, p.y), # left\n            Point(p.x+2, p.y)] # right\n    goal = []\n    for a in nbrs\n        if 0&lt;a.x&lt;=n &amp;&amp; 0&lt;a.y&lt;=m &amp;&amp; A[a.x,a.y]==2\n            push!(goal, a)\n        end\n    end\n    length(goal) != 0 ? rand(goal) : Point(-1,-1)\nend\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EСтены будем разбивать так:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"julia\"\u003Efunction breakwall(A, newp,oldp)\n    # координата стены:\n    x = (newp.x + oldp.x) \u003E\u003E 1 # побитовый сдвиг\n    y = (newp.y + oldp.y) \u003E\u003E 1\n    A[x,y] = 1\nend\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ch4 id=\"algoritm\"\u003EАлгоритм\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\n\u003Col\u003E\r\n\u003Cli\u003EСделайте начальную клетку текущей и отметьте ее как посещенную. \u003C\u002Fli\u003E\r\n\u003Cli\u003EПока есть непосещенные клетки\u003Cbr\u002F\u003E\r\n  1. Если текущая клетка имеет непосещенных «соседей»\u003Cbr\u002F\u003E\r\n    1. Протолкните текущую клетку в стек\u003Cbr\u002F\u003E\r\n    2. Выберите случайную клетку из соседних\u003Cbr\u002F\u003E\r\n    3. Уберите стенку между текущей клеткой и выбранной\u003Cbr\u002F\u003E\r\n    4. Сделайте выбранную клетку текущей и отметьте ее как посещенную.\u003Cbr\u002F\u003E\r\n  2. Иначе если стек не пуст\u003Cbr\u002F\u003E\r\n    1. Выдерните клетку из стека\u003Cbr\u002F\u003E\r\n    2. Сделайте ее текущей\u003Cbr\u002F\u003E\r\n  3. Иначе\u003Cbr\u002F\u003E\r\n    1. Выберите случайную непосещенную клетку, сделайте ее текущей и отметьте как посещенную.\u003C\u002Fli\u003E\r\n\u003C\u002Fol\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\"\u003E\u003Cb class=\"spoiler_title\"\u003EКод программы\u003C\u002Fb\u003E\u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"julia\"\u003Efunction amazeng(n, m)\n\n    M = [ 2(i&amp;j&amp;1) for i in 0:n, j in 0:m ];\n    p = Point(2,2) # стартовая точа\n    lifo = [] # пустой массив\n    push!(lifo, p)\n    #i = 0\n    while length(lifo) != 0 # пока не опустеет стек\n        M[p.x,p.y] = 1 # отметим белым посещенную клетку\n        np = neighbours2(M, p, n, m) # new point\n        # если нет соседей - идём обратно\n        if np.x == np.y == -1\n            p = pop!(lifo)\n        else\n            push!(lifo, p)\n            breakwall(M, np, p)\n            p = np\n            #i+=1\n            #maze = Gray.(M\u002F2)\n            #save(\"D:\u002Fdat\u002Fmaze$i.png\", maze)\n        end\n    end\n\n    M[1,2] = 1 # вход\n    M[n,m+1] = 1 # выход\n\n    Gray.(M)\nend\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"julia\"\u003Elbrnt = amazeng(36, 48)\n# save(\"D:\u002Fdat\u002Fmaze111.png\", lbrnt)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fc0\u002Fv7\u002Fss\u002Fc0v7sspjrcruoda7auy6h-rj_9o.gif\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Foe\u002Fhg\u002Fao\u002Foehgao7ny8sinfbnogcorqdfdsk.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch4 id=\"algoritm-poiska-puti-bektrekingom\"\u003EАлгоритм поиска пути бэктрекингом:\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\n\u003Col\u003E\r\n\u003Cli\u003EСделайте начальную клетку текущей и отметьте ее как посещенную. \u003C\u002Fli\u003E\r\n\u003Cli\u003EПока не найден выход\u003Cbr\u002F\u003E\r\n  1. Если текущая клетка имеет непосещенных «соседей»\u003Cbr\u002F\u003E\r\n    1. Протолкните текущую клетку в стек\u003Cbr\u002F\u003E\r\n    2. Выберите случайную клетку из соседних\u003Cbr\u002F\u003E\r\n    3. Сделайте выбранную клетку текущей и отметьте ее как посещенную.\u003Cbr\u002F\u003E\r\n  2. Иначе если стек не пуст\u003Cbr\u002F\u003E\r\n    1. Выдерните клетку из стека\u003Cbr\u002F\u003E\r\n    2. Сделайте ее текущей\u003Cbr\u002F\u003E\r\n  3. Иначе выхода нет\u003C\u002Fli\u003E\r\n\u003C\u002Fol\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EСоседей ищем наоборот и в радиусе одной клетки, а не через одну:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"julia\"\u003Efunction neighbours1(A, p, n, m)\n    nbrs = [Point(p.x, p.y+1), # up\n            Point(p.x, p.y-1), # down\n            Point(p.x-1, p.y), # left\n            Point(p.x+1, p.y)] # right\n    goal = []\n    for a in nbrs\n        if 0&lt;a.x&lt;=n &amp;&amp; 0&lt;a.y&lt;=m &amp;&amp; A[a.x,a.y]==1\n            push!(goal, a)\n        end\n    end\n    length(goal) != 0 ? rand(goal) : Point(0,0)\nend\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЗададим алгоритм прохождения лабиринта с отрисовкой маршрута и неудачных попыток\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"julia\"\u003Efunction amazeng(img, start, exit)\n    M = Float64.(channelview(img))\n    n, m = size(M)\n    p = start\n    M[exit.x,exit.y] = 1\n\n    lifo = []\n    push!(lifo, p)\n\n    while p.x != exit.x || p.y != exit.y\n\n        M[p.x,p.y] = 0.4\n        np = neighbours1(M, p, n, m)\n        if np.x == np.y == 0\n            M[p.x,p.y] = 0.75\n            p = pop!(lifo)\n# числа  - оттенки серого, чтоб выделить маршрут\n# можно поставить функции задающие цвета\n        else\n            push!(lifo, p)\n            p = np\n        end\n    end\n\n    Gray.(M)\nend\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКак некоторые заметили, функция называется также, как и та, что алгоритмы генерирует (Множественная диспетчеризация). При вызове ее с двумя числами, отработает метод конструирования лабиринта, если же вызвать, задав в качестве аргумента изображение и две точки (координаты входа и выхода), то на выходе получим изображение с пройденным лабиринтом\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"julia\"\u003Eimg0 = load(\"D:\u002Fdat\u002Fmaze111.png\")\namazeng(img0)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fkx\u002F2n\u002Fzl\u002Fkx2nzlhw-bylb1wjdjifjxvmfsq.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EОтпробуем на нашем лабиринте:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"julia\"\u003Eimg0 = load(\"D:\u002Fdat\u002Fmaze12x12.png\")\nn, m = size(img0)\namazeng(img0, Point(11,9), Point(4,6) )\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Foy\u002Fuo\u002Flm\u002Foyuolmopr9kmvmx07nn3kfdhufi.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДаже если модифицировать функцию, чтоб запоминался маршрут, всё равно из-за открытых пространств алгоритм показывает себя неэффективным. Зато лабиринты выходят отличные.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"randomizirovannyy-algoritm-prima\"\u003EРандомизированный алгоритм Прима\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EУж как начнешь рисовать лабиринты, так и не остановиться. Выполним еще один интересный \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FMaze_generation_algorithm\"\u003Eалгоритм\u003C\u002Fa\u003E:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EНачать с сетки, полной стен.\u003C\u002Fli\u003E\r\n\u003Cli\u003EВыберите ячейку, отметьте ее как часть лабиринта. Добавьте стены ячейки в список стен.\u003C\u002Fli\u003E\r\n\u003Cli\u003EПока в списке есть стены:\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EВыберите случайную стену из списка. Если посещена только одна из двух ячеек, которые разделяет стена, то:\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EСделайте стену проходом и отметьте непосещенную клетку как часть лабиринта.\u003C\u002Fli\u003E\r\n\u003Cli\u003EДобавьте соседние стены ячейки в список стен.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003EУбрать стену из списка.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\"\u003E\u003Cb class=\"spoiler_title\"\u003EКод\u003C\u002Fb\u003E\u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"julia\"\u003Eneighbors(p::Point) = [Point(p.x, p.y+1), # up\n                    Point(p.x, p.y-1), # down\n                    Point(p.x-1, p.y), # left\n                    Point(p.x+1, p.y)] # right\n\nfunction newalls!(walls, p, maze, n, m)\n\n    nbrs = neighbors(p)\n    for a in nbrs\n        if 1&lt;a.x&lt;n-1 &amp;&amp; 1&lt;a.y&lt;m-1 &amp;&amp; !maze[a.x,a.y]\n            push!(walls, a) # Добавьте соседние стены ячейки в список стен.\n        end\n    end\nend\n\nfunction breakwall!(p, maze, n, m)\n\n    nbrs = neighbors(p)\n    # если среди соседей есть белая клетка\n    if sum( a-\u003E maze[a.x,a.y], nbrs) == 1\n        for a in nbrs\n            if  maze[a.x,a.y]\n                # true =  белая\n                p.x == a.x ? nx = p.x : p.x\u003Ea.x ? nx = p.x+1 : nx = p.x-1\n                p.y == a.y ? ny = p.y : p.y\u003Ea.y ? ny = p.y+1 : ny = p.y-1\n                maze[p.x,p.y] = true # соединить коридоры\n                maze[nx,ny] = true\n                p.x = nx\n                p.y = ny\n                return true\n            end\n        end\n    else\n        return false\n    end\nend\n\nfunction prim(n, m)\n\n    M = falses(n,m); # всё заполнено стенами\n    p = Point(2, 2)\n    M[p.x,p.y] = true\n\n    walls = []\n    newalls!(walls, p, M, n, m)\n\n    while length(walls) != 0\n        p = splice!( walls, rand(1:length(walls)) )\n\n        if breakwall!(p, M, n, m)\n            newalls!(walls, p, M, n, m)\n        end\n\n    end\n\n    M\nend\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"julia\"\u003Eprimaze = prim(19,19);\nGray.(primaze)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fp_\u002Fdz\u002Fuf\u002Fp_dzufexrrmrvhmzxiwyh_nsfdc.gif\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПолучается более ветвисто и не менее потрясно, особенно процесс сборки.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EА теперь имплементируем наиболее распространенный алгоритм нахождения кратчайшего маршрута:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3 id=\"metod-a\"\u003EМетод A*\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EСоздается 2 списка вершин — ожидающие рассмотрения и уже рассмотренные. В ожидающие добавляется точка старта, список рассмотренных пока пуст.\u003C\u002Fli\u003E\r\n\u003Cli\u003EДля каждой точки рассчитывается \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fbd2\u002F36a\u002F859\u002Fbd236a859d121c85d92d1acf80ba3597.svg\" alt=\"$H$\" data-tex=\"inline\"\u002F\u003E — примерное расстояние от точки до цели. \u003C\u002Fli\u003E\r\n\u003Cli\u003EИз списка точек на рассмотрение выбирается точка с наименьшим \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fbd2\u002F36a\u002F859\u002Fbd236a859d121c85d92d1acf80ba3597.svg\" alt=\"$H$\" data-tex=\"inline\"\u002F\u003E. Обозначим ее \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F6d6\u002Fa4f\u002F78f\u002F6d6a4f78fbacd6edecc018ce8ad3e364.svg\" alt=\"$X$\" data-tex=\"inline\"\u002F\u003E.\u003C\u002Fli\u003E\r\n\u003Cli\u003EЕсли \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F6d6\u002Fa4f\u002F78f\u002F6d6a4f78fbacd6edecc018ce8ad3e364.svg\" alt=\"$X$\" data-tex=\"inline\"\u002F\u003E — цель, то мы нашли маршрут.\u003C\u002Fli\u003E\r\n\u003Cli\u003EПереносим \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F6d6\u002Fa4f\u002F78f\u002F6d6a4f78fbacd6edecc018ce8ad3e364.svg\" alt=\"$X$\" data-tex=\"inline\"\u002F\u003E из списка ожидающих рассмотрения в список уже рассмотренных.\u003C\u002Fli\u003E\r\n\u003Cli\u003EДля каждой из точек, соседних для \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F6d6\u002Fa4f\u002F78f\u002F6d6a4f78fbacd6edecc018ce8ad3e364.svg\" alt=\"$X$\" data-tex=\"inline\"\u002F\u003E (обозначим эту соседнюю точку \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fc62\u002Fff2\u002F5ef\u002Fc62ff25ef4caeaeaef7122a489ef9d07.svg\" alt=\"$Y$\" data-tex=\"inline\"\u002F\u003E), делаем следующее:\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EЕсли \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fc62\u002Fff2\u002F5ef\u002Fc62ff25ef4caeaeaef7122a489ef9d07.svg\" alt=\"$Y$\" data-tex=\"inline\"\u002F\u003E уже находится в рассмотренных — пропускаем ее.\u003C\u002Fli\u003E\r\n\u003Cli\u003EЕсли \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fc62\u002Fff2\u002F5ef\u002Fc62ff25ef4caeaeaef7122a489ef9d07.svg\" alt=\"$Y$\" data-tex=\"inline\"\u002F\u003E еще нет в списке на ожидание — добавляем ее туда.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003EЕсли список точек на рассмотрение пуст, а до цели мы так и не дошли — значит маршрут не существует.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДля начала зададим класс \"точка\" которая будет знать, как далеко она от цели:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"julia\"\u003Emutable struct Point_h\n    x::Int64 # horisont\n    y::Int64 # vertical\n    h::Float64\n\n    Point_h(x, y) = new(x, y, 0.)\nend\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТеперь доопределим для структуры операцию сравнения, метод для установления наличия элемента в массиве, а также функции изъятия элемента, нахождения расстояния между точками и перечисления соседей:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\"\u003E\u003Cb class=\"spoiler_title\"\u003EУпрятано\u003C\u002Fb\u003E\u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"julia\"\u003Eimport Base: in, ==\n\n==(a::Point_h, b::Point_h) = a.x==b.x &amp;&amp; a.y==b.y\n\nfunction in(p::Point_h, Arr::Array{Point_h,1})\n    for a in Arr\n        if a == p\n            return true\n        end\n    end\n    return false\nend\n\nfunction splicemin!(Arr)#::Array{Point_h,1}\n    i = argmin( [a.h for a in Arr] )\n    splice!(Arr, i)\nend\n\ndista(u,v) = hypot(v.x-u.x, v.y-u.y) # &lt;=\u003E sqrt( (v.x-u.x)^2 + (v.y-u.y)^2 )\n\nneighbors(p::Point_h) = [Point_h(p.x, p.y+1), # up\n                    Point_h(p.x, p.y-1), # down\n                    Point_h(p.x-1, p.y), # left\n                    Point_h(p.x+1, p.y)] # right\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКак всегда, непонятные операторы можно разъяснить с помощью команды \u003Ccode\u003E?\u003C\u002Fcode\u003E, например \u003Ccode\u003E?splice\u003C\u002Fcode\u003E, \u003Ccode\u003E?argmin\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИ, собственно, сам метод A*\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\"\u003E\u003Cb class=\"spoiler_title\"\u003EКод\u003C\u002Fb\u003E\u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"julia\"\u003Efunction astar(M, start, final)\n    # хорошая точка - не стена и не за границами\n    isgood(p) = 1&lt;p.x&lt;n &amp;&amp; 1&lt;p.y&lt;m &amp;&amp; M[p.x,p.y] != 0\n\n    n, m = size(M)\n# как далеко от старта до цели\n    start.h = dista(start,final)\n\n    closed = []\n    opened = []\n    push!(opened, start)\n\n    while length(opened) != 0\n\n        X = splicemin!(opened)\n\n        if X in closed\n            continue\n        end\n        if X == final\n            break\n        end\n        push!(closed, X)\n\n        nbrs = neighbors(X)\n        ygrex = filter(isgood, nbrs)\n\n        for Y in ygrex\n\n            if Y in closed\n                continue\n            else\n                Y.h = dista(Y, final)\n                push!(opened, Y)\n            end\n        end\n    end\n# возвращаем все посещенные\n    closed # return\nend\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЗагружаем картинку с лабиринтом и представляем ее в виде матрицы:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"julia\"\u003Eimg0 = load(\"D:\u002Fdat\u002Fmaze0.png\") \nmazematrix = Float64.(channelview(img0))\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИ строим маршрут до выхода из произвольной точки:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"julia\"\u003Es = Point_h(11,9) # start\nf = Point_h(4,6) # finish\n\nM = copy(mazematrix)\nroute = astar(M, s, f)\n\ni = 1\nfor c in route\n    # рисует маршрут\n    M[c.x,c.y] = 0.7\n    #save(\"D:\u002Fdat\u002FAstar$i.png\", M)\n    i+=1\nend\nGray.(M)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fsk\u002Fok\u002Fv6\u002Fskokv6txgvsowgjewyqaht9ffb4.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EА поиск из всех позиций выглядит так:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Fxf\u002Fba\u002Fjv\u002Fxfbajvk-jw2iokdrizmq8suncik.gif\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВидно, что агент \u003Cdel\u003Eпрёт\u003C\u002Fdel\u003E всегда стремится в сторону выхода и частенько заворачивает в тупики, что порождает лишние шаги, а запоминается-то весь маршрут. Это избегается чуть более сложным вариантом алгоритма А*\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EСоздается 2 списка вершин — ожидающие рассмотрения и уже рассмотренные. В ожидающие добавляется точка старта, список рассмотренных пока пуст. \u003C\u002Fli\u003E\r\n\u003Cli\u003EДля каждой точки рассчитывается \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F08c\u002F84d\u002Fe45\u002F08c84de45586dceeb0d12296ca14c22f.svg\" alt=\"$F = G + H$\" data-tex=\"inline\"\u002F\u003E. \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F560\u002Fbd9\u002F7f2\u002F560bd97f235311a36dff00db005e6ab5.svg\" alt=\"$G$\" data-tex=\"inline\"\u002F\u003E — расстояние от старта до точки, \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fbd2\u002F36a\u002F859\u002Fbd236a859d121c85d92d1acf80ba3597.svg\" alt=\"$H$\" data-tex=\"inline\"\u002F\u003E — примерное расстояние от точки до цели. Так же каждая точка хранит ссылку на точку, из которой в нее пришли. \u003C\u002Fli\u003E\r\n\u003Cli\u003EИз списка точек на рассмотрение выбирается точка с наименьшим \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fb8b\u002F97c\u002F656\u002Fb8b97c6567171cc2b6a7f303a0fa8b0a.svg\" alt=\"$F$\" data-tex=\"inline\"\u002F\u003E. Обозначим ее \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F6d6\u002Fa4f\u002F78f\u002F6d6a4f78fbacd6edecc018ce8ad3e364.svg\" alt=\"$X$\" data-tex=\"inline\"\u002F\u003E. \u003C\u002Fli\u003E\r\n\u003Cli\u003EЕсли \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F6d6\u002Fa4f\u002F78f\u002F6d6a4f78fbacd6edecc018ce8ad3e364.svg\" alt=\"$X$\" data-tex=\"inline\"\u002F\u003E — цель, то мы нашли маршрут.\u003C\u002Fli\u003E\r\n\u003Cli\u003EПереносим \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F6d6\u002Fa4f\u002F78f\u002F6d6a4f78fbacd6edecc018ce8ad3e364.svg\" alt=\"$X$\" data-tex=\"inline\"\u002F\u003E из списка ожидающих рассмотрения в список уже рассмотренных.\u003C\u002Fli\u003E\r\n\u003Cli\u003EДля каждой из точек, соседних для \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F6d6\u002Fa4f\u002F78f\u002F6d6a4f78fbacd6edecc018ce8ad3e364.svg\" alt=\"$X$\" data-tex=\"inline\"\u002F\u003E (обозначим эту соседнюю точку \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fc62\u002Fff2\u002F5ef\u002Fc62ff25ef4caeaeaef7122a489ef9d07.svg\" alt=\"$Y$\" data-tex=\"inline\"\u002F\u003E), делаем следующее:\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EЕсли \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fc62\u002Fff2\u002F5ef\u002Fc62ff25ef4caeaeaef7122a489ef9d07.svg\" alt=\"$Y$\" data-tex=\"inline\"\u002F\u003E уже находится в рассмотренных — пропускаем ее.\u003C\u002Fli\u003E\r\n\u003Cli\u003EЕсли \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fc62\u002Fff2\u002F5ef\u002Fc62ff25ef4caeaeaef7122a489ef9d07.svg\" alt=\"$Y$\" data-tex=\"inline\"\u002F\u003E еще нет в списке на ожидание — добавляем ее туда, запомнив ссылку на \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F6d6\u002Fa4f\u002F78f\u002F6d6a4f78fbacd6edecc018ce8ad3e364.svg\" alt=\"$X$\" data-tex=\"inline\"\u002F\u003E и рассчитав \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Ff07\u002Fb1c\u002F7a4\u002Ff07b1c7a48a22c879ec729e6ea01b4e0.svg\" alt=\"$Y.G$\" data-tex=\"inline\"\u002F\u003E (это \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fbd3\u002F562\u002Fdf4\u002Fbd3562df4007a53a10a6e430cebb3530.svg\" alt=\"$X.G$\" data-tex=\"inline\"\u002F\u003E + расстояние от \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F6d6\u002Fa4f\u002F78f\u002F6d6a4f78fbacd6edecc018ce8ad3e364.svg\" alt=\"$X$\" data-tex=\"inline\"\u002F\u003E до \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fc62\u002Fff2\u002F5ef\u002Fc62ff25ef4caeaeaef7122a489ef9d07.svg\" alt=\"$Y$\" data-tex=\"inline\"\u002F\u003E) и \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F3a0\u002F7c2\u002Fe37\u002F3a07c2e3770a2ee828755498f39fb059.svg\" alt=\"$Y.H$\" data-tex=\"inline\"\u002F\u003E.\u003C\u002Fli\u003E\r\n\u003Cli\u003EЕсли же \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fc62\u002Fff2\u002F5ef\u002Fc62ff25ef4caeaeaef7122a489ef9d07.svg\" alt=\"$Y$\" data-tex=\"inline\"\u002F\u003E в списке на рассмотрение — проверяем, если \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fbd3\u002F562\u002Fdf4\u002Fbd3562df4007a53a10a6e430cebb3530.svg\" alt=\"$X.G$\" data-tex=\"inline\"\u002F\u003E + расстояние от \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F6d6\u002Fa4f\u002F78f\u002F6d6a4f78fbacd6edecc018ce8ad3e364.svg\" alt=\"$X$\" data-tex=\"inline\"\u002F\u003E до \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fc62\u002Fff2\u002F5ef\u002Fc62ff25ef4caeaeaef7122a489ef9d07.svg\" alt=\"$Y$\" data-tex=\"inline\"\u002F\u003E \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F96d\u002F121\u002F66c\u002F96d12166c34ab00f79f66055ed99c710.svg\" alt=\"$&lt; Y.G$\" data-tex=\"inline\"\u002F\u003E, значит мы пришли в точку \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fc62\u002Fff2\u002F5ef\u002Fc62ff25ef4caeaeaef7122a489ef9d07.svg\" alt=\"$Y$\" data-tex=\"inline\"\u002F\u003E более коротким путем, заменяем \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Ff07\u002Fb1c\u002F7a4\u002Ff07b1c7a48a22c879ec729e6ea01b4e0.svg\" alt=\"$Y.G$\" data-tex=\"inline\"\u002F\u003E на \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fbd3\u002F562\u002Fdf4\u002Fbd3562df4007a53a10a6e430cebb3530.svg\" alt=\"$X.G$\" data-tex=\"inline\"\u002F\u003E + расстояние от \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F6d6\u002Fa4f\u002F78f\u002F6d6a4f78fbacd6edecc018ce8ad3e364.svg\" alt=\"$X$\" data-tex=\"inline\"\u002F\u003E до \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fc62\u002Fff2\u002F5ef\u002Fc62ff25ef4caeaeaef7122a489ef9d07.svg\" alt=\"$Y$\" data-tex=\"inline\"\u002F\u003E, а точку, из которой пришли в \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002Fc62\u002Fff2\u002F5ef\u002Fc62ff25ef4caeaeaef7122a489ef9d07.svg\" alt=\"$Y$\" data-tex=\"inline\"\u002F\u003E на \u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fformulas\u002F6d6\u002Fa4f\u002F78f\u002F6d6a4f78fbacd6edecc018ce8ad3e364.svg\" alt=\"$X$\" data-tex=\"inline\"\u002F\u003E.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003EЕсли список точек на рассмотрение пуст, а до цели мы так и не дошли — значит маршрут не существует.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНо даже с лишними шагами наш вариант вполне укладывается в ограничение задачи, так что модификации программ будет вашим домашним заданием. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДо конца олимпиады осталось всего-ничего, а нам нужно еще научиться переводить результаты работы наших алгоритмов в команды вида \u003Ccode\u003E\"RRLUUDL...\"\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИ вот после всех этих хождений по лабиринтам, можно предположить, что решение гораздо проще. \u003Cem\u003EНа самом деле простой вариант напрашивается сразу, но уж очень хотелось наделать красивых штук\u003C\u002Fem\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЕсли расположить нашего исполнителя в открытой местности и инициировать случайные блуждания, то он будет колебаться вблизи своей стартовой позиции. Но вот с введением стенок, часть направлений начнет гаситься, степеней свободы станет меньше, и с такими же входными данными агент переместится на большее расстояние.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВот наш вариант проверки команд на пригодность к вызволению робота из лабиринта:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\"\u003E\u003Cb class=\"spoiler_title\"\u003EКод\u003C\u002Fb\u003E\u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"julia\"\u003EM = [ 0  0  0  0  0  0  0  0  0  0  0  0\n 0  1  1  0  0  1  0  1  1  0  0  0\n 0  1  0  1  1  1  1  0  1  1  1  0\n 0  1  0  0  1  9  1  1  1  1  1  0\n 0  1  1  0  1  1  1  1  0  1  1  0\n 0  1  1  1  1  0  0  0  1  1  1  0\n 0  1  1  1  1  0  1  1  0  1  1  0\n 0  1  1  1  1  1  0  1  1  0  1  0\n 0  1  0  1  1  0  1  0  1  0  1  0\n 0  1  1  0  0  1  1  0  1  0  1  0\n 0  0  1  1  1  1  0  0  1  1  1  0\n 0  0  0  0  0  0  0  0  0  0  0  0]\n\nmutable struct Point # point\n    x::Int64 # vertical\n    y::Int64 # horisont\n    Point(x, y) = new(x, y)\nend\n\nfunction isexit(str, c)\n\n    try\n        for s in str\n            if s == 'R'\n                c.y+=M[c.x, c.y+1];\n\n            elseif s == 'L' \n                c.y-=M[c.x, c.y-1];\n\n            elseif s == 'U'\n                c.x+=M[c.x+1, c.y];\n\n            elseif s == 'D'\n                c.x-=M[c.x-1, c.y];\n\n            else\n                 println(\"Error! Use only R, L, U, D\")\n            end\n\n        end\n    catch\n        return true\n    end\n    return false\nend\n\nfunction test(Str)\n    k = 0\n    n, m = 10,10\n    for i in 2:m+1, j in 2:n+1\n        if M[i,j] == 1\n            c = Point(i, j)\n            a = isexit(S,c)\n            if a\n                k +=1\n                #println(a)\n            end\n        end\n    end\n    println(k, \" test completed from \", sum(M)-9)\nend\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТеперь достаточно генерировать случайные строки, пока не получится та, что сработает для всех стартовых позиций:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"julia\"\u003Eusing Random\nS = randstring(\"RLUD\",200)\n\n\"RDRRRDLRLUULURUDUUDLLLLLULLUDRRURDLDLULLRLUUUDURUUUULRUDUURUUDLRLLULRLUDRRLRRULLDULRRRRULRLLDULRLDRUDURDRUUDUUDDDDDLURRRRDRDURRRDDLLDUURRRLDRUDLRLLRDDRLRRRDDLLLRUURDRLURDLLUULLLLUURLLULUDULDDLDLLRLDUD\"\n\ntest(S)\n41 test completed from 70\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EК тому же, можно было и не заморачиваться на счет теста. Достаточно было прочитать задание и сгенерировать рандомную максимально допустимую условием строку:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"julia\"\u003Efor i in 1:20\n    S = randstring(\"RLUD\",1000)\n    test(S)\nend\n\n70 test completed from 70\n70 test completed from 70\n70 test completed from 70\n70 test completed from 70\n55 test completed from 70#\n65 test completed from 70#\n70 test completed from 70\n70 test completed from 70\n38 test completed from 70#\n70 test completed from 70\n70 test completed from 70\n56 test completed from 70#\n70 test completed from 70\n70 test completed from 70\n70 test completed from 70\n16 test completed from 70#\n70 test completed from 70\n24 test completed from 70#\n70 test completed from 70\n70 test completed from 70\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТо есть с вероятностью в 70% строка прошла бы тесты.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНа этом всё. Желаю читателю удачного рандома, терпения и интуиции на очевидные решения.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДля любознательных — ссылки для углубления в тему:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fwww.astrolog.org\u002Flabyrnth\u002Falgrithm.htm\"\u003EПолнейший экскурс в лабиринтогенерацию\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F445378\u002F\"\u003EРусская версия\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F320140\u002F\"\u003EМетоды раз\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F321210\u002F\"\u003EМетоды два\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F176671\u002F\"\u003EАлгоритм Эллера\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Faivanov.com\u002Fmaze-generator\u002F\"\u003EОнлайн генератор\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fqiao.github.io\u002FPathFinding.js\u002Fvisual\u002F\"\u003EМетоды нахождения пути между точками онлайн\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fgcup.ru\u002Fpubl\u002Fgamedev\u002Falgoritm_poiska_puti_jump_point_search\u002F1-1-0-530\"\u003EАлгоритм поиска пути Jump Point Search\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002FA*\"\u003EА* на Википедии\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Ftheory.stanford.edu\u002F~amitp\u002FGameProgramming\u002FAStarComparison.html\"\u003EIntroduction to A*\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F331192\u002F\"\u003EВведение в алгоритм A*\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F444828\u002F\"\u003EОбъяснение алгоритмов поиска пути\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fwww.behance.net\u002Fsoonsang\"\u003EИсточник артов\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"julia"},{"titleHtml":"лабиринты"},{"titleHtml":"олимпиадные задачи"},{"titleHtml":"astar"},{"titleHtml":"поиск в глубину"},{"titleHtml":"алгоритм прима"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F451460\u002F9a865c2e249c18c0414cab396961e1e6\u002F","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F451460\u002F9a865c2e249c18c0414cab396961e1e6\u002F?format=vk","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F451460\\\u002F\"},\"headline\":\"Джулия в лабиринте\",\"datePublished\":\"2019-05-17T09:07:00+03:00\",\"dateModified\":\"2019-05-17T10:20:17+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"Yermack\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"Разбирая одну олимпиадную задачу мы отправимся по петляющим коридорам генерации лабиринтов и их прохождения, а также увидим, что на языке Julia простота реализа...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F451460\\\u002F#post-content-body\",\"about\":[\"h_crazydev\",\"h_sport_programming\",\"h_programming\",\"h_julia\",\"f_develop\"],\"image\":[\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fu8\\\u002Fd5\\\u002Fql\\\u002Fu8d5qlyaxgezwbkmz-ybdtbj6r8.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fq4\\\u002Fk4\\\u002Fu3\\\u002Fq4k4u30s2syto7bpzmxysbrsymi.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fua\\\u002Fxq\\\u002Flb\\\u002Fuaxqlbjtneuolospp0kwc-bujbk.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002F6p\\\u002Fhc\\\u002Fpt\\\u002F6phcptlpnrfctsa7qmpdvhm5ele.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fbr\\\u002Fyu\\\u002Fut\\\u002Fbryuutpq3-vfqn0upm3s536lwhe.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Frj\\\u002F9s\\\u002Fbc\\\u002Frj9sbcpu5inbjiqvaphxnwaw10u.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fc0\\\u002Fv7\\\u002Fss\\\u002Fc0v7sspjrcruoda7auy6h-rj_9o.gif\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Foe\\\u002Fhg\\\u002Fao\\\u002Foehgao7ny8sinfbnogcorqdfdsk.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fkx\\\u002F2n\\\u002Fzl\\\u002Fkx2nzlhw-bylb1wjdjifjxvmfsq.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Foy\\\u002Fuo\\\u002Flm\\\u002Foyuolmopr9kmvmx07nn3kfdhufi.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fp_\\\u002Fdz\\\u002Fuf\\\u002Fp_dzufexrrmrvhmzxiwyh_nsfdc.gif\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Fbd2\\\u002F36a\\\u002F859\\\u002Fbd236a859d121c85d92d1acf80ba3597.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F6d6\\\u002Fa4f\\\u002F78f\\\u002F6d6a4f78fbacd6edecc018ce8ad3e364.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Fc62\\\u002Fff2\\\u002F5ef\\\u002Fc62ff25ef4caeaeaef7122a489ef9d07.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fsk\\\u002Fok\\\u002Fv6\\\u002Fskokv6txgvsowgjewyqaht9ffb4.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fxf\\\u002Fba\\\u002Fjv\\\u002Fxfbajvk-jw2iokdrizmq8suncik.gif\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F08c\\\u002F84d\\\u002Fe45\\\u002F08c84de45586dceeb0d12296ca14c22f.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F560\\\u002Fbd9\\\u002F7f2\\\u002F560bd97f235311a36dff00db005e6ab5.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Fb8b\\\u002F97c\\\u002F656\\\u002Fb8b97c6567171cc2b6a7f303a0fa8b0a.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Ff07\\\u002Fb1c\\\u002F7a4\\\u002Ff07b1c7a48a22c879ec729e6ea01b4e0.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002Fbd3\\\u002F562\\\u002Fdf4\\\u002Fbd3562df4007a53a10a6e430cebb3530.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F3a0\\\u002F7c2\\\u002Fe37\\\u002F3a07c2e3770a2ee828755498f39fb059.svg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fformulas\\\u002F96d\\\u002F121\\\u002F66c\\\u002F96d12166c34ab00f79f66055ed99c710.svg\"]}","metaDescription":"Разбирая одну олимпиадную задачу мы отправимся по петляющим коридорам генерации лабиринтов и их прохождения, а также увидим, что на языке Julia простота реализаций алгоритмов граничит с их...","mainImageUrl":null,"amp":false},"polls":[],"commentsEnabled":true,"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":false}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[],"hubs":"crazydev,sport_programming,programming,julia"},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{}},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"dfp":{"slotsDict":{}},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.c0af73e7.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
</body>
</html>
