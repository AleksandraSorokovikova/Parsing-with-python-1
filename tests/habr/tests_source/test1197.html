<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <title>Создание игры Tower Defense в Unity: враги / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.c0af73e7.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.02ee25a4.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.85eb77f0b17c8235e7b64b9f81ea5ec2.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" src="/js/ads.js" onload="window['zhY4i4nJ9K'] = true" data-vmid="checkad"></script><script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/post\/452756\/"},"headline":"Создание игры Tower Defense в Unity: враги","datePublished":"2019-05-22T12:53:45+03:00","dateModified":"2019-05-22T13:10:01+03:00","author":{"@type":"Person","name":"PatientZero"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"[Первая часть: тайлы и поиск пути]   Размещение точек создания врагов. Появление врагов и их движение по полю. Создание плавного движения с постоянной скоростью.","url":"https:\/\/habr.com\/ru\/post\/452756\/#post-content-body","about":["h_gamedev","h_unity","f_develop"],"image":["https:\/\/habrastorage.org\/getpro\/habr\/post_images\/2db\/cf3\/311\/2dbcf331117740aa403cb12a757ae6fd.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/e39\/522\/28d\/e3952228dacd6801a6f5d2fb53826cc2.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/10f\/036\/a17\/10f036a17ae271cf7b7f7c9694e01782.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/2f9\/cd6\/22b\/2f9cd622bf1aa41023e5204e1f4caa9a.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/7c6\/348\/428\/7c6348428b50732e0a13efcdadfc9fff.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/ce7\/691\/330\/ce7691330dd6c6813d2a64398c582c2a.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/65b\/7a3\/808\/65b7a3808f469e2723b344afccd94f8f.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/62a\/0c9\/abb\/62a0c9abb59605150235ba6cec73eeb2.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/ae3\/ee2\/345\/ae3ee23456931ac6f989a763deb8b7b1.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/201\/56b\/338\/20156b3384b45ab95d7aef5ed5397480.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/8b5\/74a\/ce9\/8b574ace93bd2c7f7829d41f9208a138.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/25f\/eb8\/dc6\/25feb8dc6f0d3a5a66be43f311cd7818.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/1d7\/8a6\/3a5\/1d78a63a58d34a1d8cc9ff56a0b23cc3.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/72b\/13c\/28e\/72b13c28ed9d6a8d34f3e17536e964cd.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/1a7\/cc3\/f08\/1a7cc3f082406d5c8672125ceb94913c.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/ffe\/396\/7cf\/ffe3967cfcfb6391269a5a7691317c60.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/1db\/8b2\/b16\/1db8b2b164cba05ff6f8fe7ffa0eed71.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/0b8\/e55\/eeb\/0b8e55eeb25d36349f606f0da60d3720.png"]}</script>
  <script src="//www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.49.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_eng"><meta data-vue-meta="ssr" property="og:title" content="Создание игры Tower Defense в Unity: враги" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="Создание игры Tower Defense в Unity: враги" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="Создание игры Tower Defense в Unity: враги" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="[Первая часть: тайлы и поиск пути]


Размещение точек создания врагов.
Появление врагов и их движение по полю.
Создание плавного движения с постоянной скоростью.
Изменение размера, скорости и..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="[Первая часть: тайлы и поиск пути]


Размещение точек создания врагов.
Появление врагов и их движение по полю.
Создание плавного движения с постоянной скоростью.
Изменение размера, скорости и..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="[Первая часть: тайлы и поиск пути]


Размещение точек создания врагов.
Появление врагов и их движение по полю.
Создание плавного движения с постоянной скоростью.
Изменение размера, скорости и..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="[Первая часть: тайлы и поиск пути]


Размещение точек создания врагов.
Появление врагов и их движение по полю.
Создание плавного движения с постоянной скоростью.
Изменение размера, скорости и..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="[Первая часть: тайлы и поиск пути]


Размещение точек создания врагов.
Появление врагов и их движение по полю.
Создание плавного движения с постоянной скоростью.
Изменение размера, скорости и..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habr.com/share/publication/452756/dc75c668a64bb1bc684a819296df6091/" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habr.com/share/publication/452756/dc75c668a64bb1bc684a819296df6091/" data-vmid="og:image"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habr.com/share/publication/452756/dc75c668a64bb1bc684a819296df6091/" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habr.com/share/publication/452756/dc75c668a64bb1bc684a819296df6091/" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habr.com/share/publication/452756/dc75c668a64bb1bc684a819296df6091/" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="452756" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2019-05-22T09:53:45.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/452756/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="https://habr.com/ru/post/452756/" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habr.com/share/publication/452756/dc75c668a64bb1bc684a819296df6091/" data-vmid="image:href">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="/ru/sandbox/start/" class="tm-header__become-author-btn">
            Как стать автором
          </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="/ru/all/" class="tm-main-menu__item">
        Все потоки
      </a> <a href="/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" data-async-called="true" class="tm-page"><div class="tm-page-width"><!----> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="/ru/users/PatientZero/" title="PatientZero" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="" height="24" loading="lazy" src="//habrastorage.org/r/w32/getpro/habr/avatars/8de/9c5/34a/8de9c534a18a6cb8693270a2b528d4c0.png" width="24" class="tm-entity-image__pic"></div></a> <span class="tm-user-info__user"><a href="/ru/users/PatientZero/" class="tm-user-info__username">
      PatientZero
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2019-05-22T09:53:45.000Z" title="2019-05-22, 12:53">22  мая  2019 в 12:53</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>Создание игры Tower Defense в Unity: враги</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/gamedev/" class="tm-article-snippet__hubs-item-link"><span>Разработка игр</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="/ru/hub/unity/" class="tm-article-snippet__hubs-item-link"><span>Unity</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span></div> <div class="tm-article-snippet__labels"><div class="tm-article-snippet__label"><span>
        Перевод
      </span></div></div> <!----> <!----></div></div> <div class="tm-article-presenter__origin"><a href="https://catlikecoding.com/unity/tutorials/tower-defense/enemies/" target="_blank" class="tm-article-presenter__origin-link">
                Автор оригинала:
                <span>
                  Jasper Flick
                </span></a></div> <div data-gallery-root="" lang="ru" class="tm-article-body"><div id="post-content-body" class="article-formatted-body article-formatted-body_version-1"><div xmlns="http://www.w3.org/1999/xhtml"><i>[<a href="https://habr.com/ru/post/449798/">Первая часть: тайлы и поиск пути</a>]</i><br/>
<br/>
<ul>
<li>Размещение точек создания врагов.</li>
<li>Появление врагов и их движение по полю.</li>
<li>Создание плавного движения с постоянной скоростью.</li>
<li>Изменение размера, скорости и размещения врагов.</li>
</ul><br/>
Это вторая часть туториала, посвящённого простой игре в жанре <a href="https://catlikecoding.com/unity/tutorials/tower-defense/">tower defense</a>. В ней рассматривается процесс создания врагов и их движения к ближайшей конечной точке.<br/>
<br/>
Данный туториал выполнен в Unity 2018.3.0f2.<br/>
<br/>
<div style="text-align:center;"><img src="https://catlikecoding.com/unity/tutorials/tower-defense/enemies/tutorial-image.jpg" width="512" height="256" data-src="https://catlikecoding.com/unity/tutorials/tower-defense/enemies/tutorial-image.jpg" data-blurred="true"/></div><br/>
<i>Враги на пути к конечной точке.</i><br/>
<a name="habracut"></a><br/>
<h2>Точки создания (спауна) врагов</h2><br/>
Прежде чем начать создавать врагов, нам нужно решить, где разместить их на поле. Для этого мы создадим точки спауна.<br/>
<br/>
<h3>Содержимое тайлов</h3><br/>
Точка спауна — это ещё один тип содержимого тайлов, поэтому добавим запись для него в <code>GameTileContentType</code>.<br/>
<br/>
<pre><code class="cs">public enum GameTileContentType {
	Empty, Destination, Wall, SpawnPoint
}</code></pre><br/>
А затем создадим префаб, чтобы визуализировать его. Нам вполне подойдёт дубликат префаба начальной точки, просто изменим его тип содержимого и дадим ему другой материал. Я сделал его оранжевым.<br/>
<br/>
<div style="text-align:center;"><img src="/img/image-loader.svg" height="104" data-src="https://catlikecoding.com/unity/tutorials/tower-defense/enemies/spawn-points/spawn-point-inspector.png" data-width="320"/></div><br/>
<i>Конфигурация точек спауна.</i><br/>
<br/>
Добавим поддержку точек спауна в фабрику содержимого и дадим ему ссылку на префаб.<br/>
<br/>
<pre><code class="cs">	[SerializeField]
	GameTileContent spawnPointPrefab = default;

	…

	public GameTileContent Get (GameTileContentType type) {
		switch (type) {
			case GameTileContentType.Destination: return Get(destinationPrefab);
			case GameTileContentType.Empty: return Get(emptyPrefab);
			case GameTileContentType.Wall: return Get(wallPrefab);
			case GameTileContentType.SpawnPoint: return Get(spawnPointPrefab);
		}
		Debug.Assert(false, "Unsupported type: " + type);
		return null;
	}</code></pre><br/>
<div style="text-align:center;"><img src="/img/image-loader.svg" height="142" data-src="https://catlikecoding.com/unity/tutorials/tower-defense/enemies/spawn-points/factory.png" data-width="320"/></div><br/>
<i>Фабрика с поддержкой точек спауна.</i><br/>
<br/>
<h3>Включение и отключение точек спауна</h3><br/>
Метод для переключения состояния точки спауна, как и другие методы переключения, мы добавим в <code>GameBoard</code>. Но точки спауна не влияют на поиск пути, поэтому после изменения нам не нужно искать новые пути.<br/>
<br/>
<pre><code class="cs">	public void ToggleSpawnPoint (GameTile tile) {
		if (tile.Content.Type == GameTileContentType.SpawnPoint) {
			tile.Content = contentFactory.Get(GameTileContentType.Empty);
		}
		else if (tile.Content.Type == GameTileContentType.Empty) {
			tile.Content = contentFactory.Get(GameTileContentType.SpawnPoint);
		}
	}</code></pre><br/>
Игра имеет смысл только если у нас есть враги, а для них необходимы точки спауна. Поэтому поле игры должно содержать хотя бы одну точку спауна. Также нам потребуется доступ к точкам спауна в дальнейшем, когда мы будем добавлять врагов, поэтому давайте воспользуемся списком, чтобы отслеживать все тайлы с этими точками. Будем обновлять список при переключении состояния точки спауна и предотвращать удаление последней точки спауна.<br/>
<br/>
<pre><code class="cs">	List&lt;GameTile> spawnPoints = new List&lt;GameTile>();

	…

	public void ToggleSpawnPoint (GameTile tile) {
		if (tile.Content.Type == GameTileContentType.SpawnPoint) {
			if (spawnPoints.Count > 1) {
				spawnPoints.Remove(tile);
				tile.Content = contentFactory.Get(GameTileContentType.Empty);
			}
		}
		else if (tile.Content.Type == GameTileContentType.Empty) {
			tile.Content = contentFactory.Get(GameTileContentType.SpawnPoint);
			spawnPoints.Add(tile);
		}
	}</code></pre><br/>
Метод <code>Initialize</code> теперь должен задать точку спауна, чтобы создать исходное правильное состояние поля. Давайте просто включим первый тайл, который находится в левом нижнем углу.<br/>
<br/>
<pre><code class="cs">	public void Initialize (
		Vector2Int size, GameTileContentFactory contentFactory
	) {
		…

		ToggleDestination(tiles[tiles.Length / 2]);
		ToggleSpawnPoint(tiles[0]);
	}</code></pre><br/>
Мы сделаем так, чтобы теперь альтернативное касание переключало состояние точек спауна, но при зажатом левом Shift (нажатие клавиши проверяется методом <code>Input.GetKey</code>) будет переключаться состояние конечной точки<br/>
<br/>
<pre><code class="cs">	void HandleAlternativeTouch () {
		GameTile tile = board.GetTile(TouchRay);
		if (tile != null) {
			if (Input.GetKey(KeyCode.LeftShift)) {
				board.ToggleDestination(tile);
			}
			else {
				board.ToggleSpawnPoint(tile);
			}
		}
	}</code></pre><br/>
<div style="text-align:center;"><img src="/img/image-loader.svg" height="230" data-src="https://catlikecoding.com/unity/tutorials/tower-defense/enemies/spawn-points/board-with-spawn-points.png" data-width="230"/></div><br/>
<i>Поле с точками спауна.</i><br/>
<br/>
<h3>Получение доступа к точкам спауна</h3><br/>
Поле занимается всеми своими тайлами, но враги — это не его ответственность. Мы сделаем так, чтобы можно было получать доступ к его точкам спауна через общий метод <code>GetSpawnPoint</code> с параметром-индексом.<br/>
<br/>
<pre><code class="cs">	public GameTile GetSpawnPoint (int index) {
		return spawnPoints[index];
	}</code></pre><br/>
Чтобы знать, какие индексы верны, необходима информация о количестве точек спауна, поэтому сделаем её общей с помощью общего свойства-геттера.<br/>
<br/>
<pre><code class="cs">	public int SpawnPointCount => spawnPoints.Count;</code></pre><br/>
<h2>Спаунинг врагов</h2><br/>
Спаунинг врага чем-то похож на создание содержимого тайла. Мы создаём через фабрику экземпляр префаба, который затем помещаем на поле.<br/>
<br/>
<h3>Фабрики</h3><br/>
Мы создадим для врагов фабрику, которая будет помещать всё создаваемое ею на собственную сцену. Этот функционал является общим с той фабрикой, которая у нас уже есть, поэтому давайте поместим код для него в общий базовый класс <code>GameObjectFactory</code>. Нам будет достаточно одного метода <code>CreateGameObjectInstance</code> с общим параметром префаба, который создаёт и возвращает экземпляр, а также занимается управлением всей сценой. Сделаем метод <code>protected</code>, то есть он будет доступен только классу и всем типам, которые от него наследуют. Это всё, что делает класс, он не предназначен для использования в качестве полнофункциональной фабрики. Поэтому пометим его как <code>abstract</code>, что не позволит создавать экземпляры его объектов.<br/>
<br/>
<pre><code class="cs">using UnityEngine;
using UnityEngine.SceneManagement;

public abstract class GameObjectFactory : ScriptableObject {

	Scene scene;

	protected T CreateGameObjectInstance&lt;T> (T prefab) where T : MonoBehaviour {
		if (!scene.isLoaded) {
			if (Application.isEditor) {
				scene = SceneManager.GetSceneByName(name);
				if (!scene.isLoaded) {
					scene = SceneManager.CreateScene(name);
				}
			}
			else {
				scene = SceneManager.CreateScene(name);
			}
		}
		T instance = Instantiate(prefab);
		SceneManager.MoveGameObjectToScene(instance.gameObject, scene);
		return instance;
	}
}</code></pre><br/>
Изменим <code>GameTileContentFactory</code> так, чтобы он наследовал этот тип фабрики и использовал <code>CreateGameObjectInstance</code> в своём методе <code>Get</code>, а затем уберём из него код управления сценой.<br/>
<br/>
<pre><code class="cs">using UnityEngine;

[CreateAssetMenu]
public class GameTileContentFactory : GameObjectFactory {

	…

	//Scene contentScene;

	…

	GameTileContent Get (GameTileContent prefab) {
		GameTileContent instance = CreateGameObjectInstance(prefab);
		instance.OriginFactory = this;
		//MoveToFactoryScene(instance.gameObject);
		return instance;
	}

	//void MoveToFactoryScene (GameObject o) {
	//	…
        //}
}</code></pre><br/>
После этого создадим новый тип <code>EnemyFactory</code>, который создаёт экземпляр одного префаба <code>Enemy</code> с помощью метода <code>Get</code> вместе с сопровождающим методом <code>Reclaim</code>.<br/>
<br/>
<pre><code class="cs">using UnityEngine;

[CreateAssetMenu]
public class EnemyFactory : GameObjectFactory {
	
	[SerializeField]
	Enemy prefab = default;

	public Enemy Get () {
		Enemy instance = CreateGameObjectInstance(prefab);
		instance.OriginFactory = this;
		return instance;
	}

	public void Reclaim (Enemy enemy) {
		Debug.Assert(enemy.OriginFactory == this, "Wrong factory reclaimed!");
		Destroy(enemy.gameObject);
	}
}</code></pre><br/>
Новый тип <code>Enemy</code> изначально должен только отслеживать свою исходную фабрику.<br/>
<br/>
<pre><code class="cs">using UnityEngine;

public class Enemy : MonoBehaviour {

	EnemyFactory originFactory;

	public EnemyFactory OriginFactory {
		get => originFactory;
		set {
			Debug.Assert(originFactory == null, "Redefined origin factory!");
			originFactory = value;
		}
	}
}</code></pre><br/>
<h3>Префаб</h3><br/>
Врагам нужна визуализация, которая может быть любой — робот, паук, призрак, что-то более простое, например, куб, который мы и используем. Но в общем случае враг имеет 3D-модель любой сложности. Чтобы обеспечить её удобную поддержку, мы воспользуемся для иерархии префаба врага корневым объектом, к которому прикреплён только компонент <code>Enemy</code>.<br/>
<br/>
<div style="text-align:center;"><img src="/img/image-loader.svg" height="160" data-src="https://catlikecoding.com/unity/tutorials/tower-defense/enemies/spawning-enemies/prefab-root.png" data-width="320"/></div><br/>
<i>Корень префаба.</i><br/>
<br/>
Создадим этому объекту единственный дочерний элемент, который будет корнем модели. Он должен иметь единичные значения Transform.<br/>
<br/>
<div style="text-align:center;"><img src="/img/image-loader.svg" height="120" data-src="https://catlikecoding.com/unity/tutorials/tower-defense/enemies/spawning-enemies/model-root.png" data-width="320"/></div><br/>
<i>Корень модели.</i><br/>
<br/>
Задача этого корня модели — расположить 3D-модель относительно локальной точки начала координат врага, чтобы он считал её опорной точкой, над которой враг стоит или висит. В нашем случае модель будет стандартным кубом половинного размера, которому я придам тёмно-синий цвет. Сделаем его дочерним элементом корня модели и присвоим позиции по Y значение 0.25, чтобы он стоял на земле.<br/>
<br/>
<div style="text-align:center;"><img src="/img/image-loader.svg" height="206" data-src="https://catlikecoding.com/unity/tutorials/tower-defense/enemies/spawning-enemies/cube.png" data-width="320"/></div><br/>
<i>Модель куба.</i><br/>
<br/>
Таким образом, префаб врага состоит из трёх вложенных объектов: корня префаба, корня модели и куба. Может показаться, что для простого куба это перебор, но такая система позволяет перемещать и анимировать любого врага, не беспокоясь о его особенностях.<br/>
<br/>
<div style="text-align:center;"><img src="/img/image-loader.svg" height="74" data-src="https://catlikecoding.com/unity/tutorials/tower-defense/enemies/spawning-enemies/prefab-hierarchy.png" data-width="225"/></div><br/>
<i>Иерархия префаба врага.</i><br/>
<br/>
Создадим фабрику врагов и назначим ей префаб.<br/>
<br/>
<div style="text-align:center;"><img src="/img/image-loader.svg" height="88" data-src="https://catlikecoding.com/unity/tutorials/tower-defense/enemies/spawning-enemies/factory.png" data-width="320"/></div><br/>
<i>Ассет фабрики.</i><br/>
<br/>
<h3>Размещение врагов на поле</h3><br/>
Чтобы поместить врагов на поле, <code>Game</code> должен получит ссылку на фабрику врагов. Так как нам нужно много врагов, добавим опцию конфигурации для настройки скорости спаунинга, выражаемую в количестве врагов за секунду. Приемлемым кажется интервал 0.1–10 со значением 1 по умолчанию.<br/>
<br/>
<pre><code class="cs">	[SerializeField]
	EnemyFactory enemyFactory = default;

	[SerializeField, Range(0.1f, 10f)]
	float spawnSpeed = 1f;</code></pre><br/>
<div style="text-align:center;"><img src="/img/image-loader.svg" height="144" data-src="https://catlikecoding.com/unity/tutorials/tower-defense/enemies/spawning-enemies/game.png" data-width="320"/></div><br/>
<i>Game с фабрикой врагов и скоростью спаунинга 4.</i><br/>
<br/>
Progress спаунинга будем отслеживать в <code>Update</code>, увеличивая его на скорость, умноженную на дельту времени. Если величина prggress превышает 1, то выполняем его декремент и спауним врага с помощью нового метода <code>SpawnEnemy</code>. Продолжаем это делать, пока progress превышает 1 на случай, если скорость слишком высока и время кадра оказалось очень длинным, чтобы одновременно не создалось несколько врагов.<br/>
<br/>
<pre><code class="cs">	float spawnProgress;

	…

	void Update () {
		…

		spawnProgress += spawnSpeed * Time.deltaTime;
		while (spawnProgress >= 1f) {
			spawnProgress -= 1f;
			SpawnEnemy();
		}
	}</code></pre><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Разве не нужно обновлять progress в FixedUpdate?</b>
                        <div class="spoiler_text">Да, это возможно, но для игры жанра tower defense такие точные тайминги не нужны. Мы просто будем обновлять состояние игры каждый кадр и сделаем так, чтобы она работала достаточно хорошо при любой дельте времени.</div>
                    </div><br/>
Пусть <code>SpawnEnemy</code> получит случайную точку спауна с поля и создаст в этом тайле врага. Мы дадим <code>Enemy</code> метод <code>SpawnOn</code>, чтобы он правильно себя спозицинировал.<br/>
<br/>
<pre><code class="cs">	void SpawnEnemy () {
		GameTile spawnPoint =
			board.GetSpawnPoint(Random.Range(0, board.SpawnPointCount));
		Enemy enemy = enemyFactory.Get();
		enemy.SpawnOn(spawnPoint);
	}</code></pre><br/>
Пока всё, что должен делать <code>SpawnOn</code> — это задавать собственную позицию равной центру тайла. Так как модель префаба расположена правильно, куб-враг окажется поверх этого тайла.<br/>
<br/>
<pre><code class="cs">	public void SpawnOn (GameTile tile) {
		transform.localPosition = tile.transform.localPosition;
	}</code></pre><br/>
<div style="text-align:center;"><img src="/img/image-loader.svg" height="230" data-src="https://catlikecoding.com/unity/tutorials/tower-defense/enemies/spawning-enemies/spawned-enemies.png" data-width="230"/></div><br/>
<i>Враги появляются в точках спауна.</i><br/>
<br/>
<h2>Перемещение врагов</h2><br/>
После появления врага он должен начать двигаться по пути к ближайшей конечной точке. Чтобы добиться этого, нужно анимировать врагов. Мы начнём с простого плавного скольжения от тайла к тайлу, а затем сделаем их движение более сложным.<br/>
<br/>
<h3>Коллекция врагов</h3><br/>
Для обновления состояния врагов мы воспользуемся тем же подходом, который исоплзовали в серии туториалов <a href="https://catlikecoding.com/unity/tutorials/object-management/">Object Management</a>. Добавим <code>Enemy</code> общий метод <code>GameUpdate</code>, возвращающий информацию о том, жив ли он, что на данном этапе всегда будет истиной. Пока просто заставим его двигаться вперёд согласно дельте времени.<br/>
<br/>
<pre><code class="cs">	public bool GameUpdate () {
		transform.localPosition += Vector3.forward * Time.deltaTime;
		return true;
	}</code></pre><br/>
Кроме того, нам нужно вести список живых врагов и всех их обновлять, удаляя из списка мёртвых врагов. Мы можем поместить весь этот код в <code>Game</code>, но давайте вместо этого изолируем его и создадим тип <code>EnemyCollection</code>. Это сериализуемый класс, который ни от чего не наследует. Дадим ему общий метод для добавления врага и ещё один метод для обновления всей коллекции.<br/>
<br/>
<pre><code class="cs">using System.Collections.Generic;

[System.Serializable]
public class EnemyCollection {

	List&lt;Enemy> enemies = new List&lt;Enemy>();

	public void Add (Enemy enemy) {
		enemies.Add(enemy);
	}

	public void GameUpdate () {
		for (int i = 0; i &lt; enemies.Count; i++) {
			if (!enemies[i].GameUpdate()) {
				int lastIndex = enemies.Count - 1;
				enemies[i] = enemies[lastIndex];
				enemies.RemoveAt(lastIndex);
				i -= 1;
			}
		}
	}
}</code></pre><br/>
Теперь <code>Game</code> будет достаточно создать всего одну такую коллекцию, в каждом кадре обновлять её и добавлять в неё созданных врагов. Врагов будем обновлять сразу же после возможного спаунинга нового врага, чтобы обновление происходило мгновенно.<br/>
<br/>
<pre><code class="cs">	EnemyCollection enemies = new EnemyCollection();

	…

	void Update () {
		…
		enemies.GameUpdate();
	}

	…

	void SpawnEnemy () {
		…
		enemies.Add(enemy);
	}</code></pre><br/>
<div style="text-align:center;"><img src="/img/image-loader.svg" height="230" data-src="https://catlikecoding.com/unity/tutorials/tower-defense/enemies/moving-enemies/moving-forward.png" data-width="230"/></div><br/>
<i>Враги движутся вперёд.</i><br/>
<br/>
<h3>Движение по пути</h3><br/>
Враги уже перемещаются, но пока не следуют по пути. Для этого им нужно знать, куда двигаться дальше. Поэтому дадим <code>GameTile</code> общее свойство-геттер для получения следующего тайла на пути.<br/>
<br/>
<pre><code class="cs">	public GameTile NextTileOnPath => nextOnPath;</code></pre><br/>
Зная тайл, из которого нужно выйти, и тайл, в который нужно попасть, враги могут определить начальную и конечную точки для перемещения на один тайл. Враг может интерполировать положение между этими двумя точками, отслеживая своё перемещение. После завершения перемещения этот процесс повторяется для следующего тайла. Но пути могут в любой момент измениться. Вместо того, чтобы определять, куда двигаться дальше в процессе движения, мы просто продолжает двигаться вдоль запланированного маршрута и проверяем его, достигнув следующего тайла.<br/>
<br/>
Пусть <code>Enemy</code> отслеживает оба тайла, чтобы на него не влияло изменение пути. Также он будет отслеживать позиции, чтобы нам не приходилось получать их в каждом кадре, и отслеживать процесс перемещения.<br/>
<br/>
<pre><code class="cs">	GameTile tileFrom, tileTo;
	Vector3 positionFrom, positionTo;
	float progress;</code></pre><br/>
Инициализируем эти поля в <code>SpawnOn</code>. Первая точка — это тайл, из которого движется враг, а конечная точка — следующий тайл на пути. Это предполагает, что существует следующий тайл, если только враг не был создан в конечной точке, что должно быть невозможным. Тогда мы кэшируем позиции тайлов и обнулим progress. Позицию врага нам задавать здесь не нужно, потому что его метод <code>GameUpdate</code> вызывается в том же кадре.<br/>
<br/>
<pre><code class="cs">	public void SpawnOn (GameTile tile) {
		//transform.localPosition = tile.transform.localPosition;
		Debug.Assert(tile.NextTileOnPath != null, "Nowhere to go!", this);
		tileFrom = tile;
		tileTo = tile.NextTileOnPath;
		positionFrom = tileFrom.transform.localPosition;
		positionTo = tileTo.transform.localPosition;
		progress = 0f;
	}</code></pre><br/>
Инкремент progress будем выполнять в <code>GameUpdate</code>. Прибавим неизменную дельту времени, чтобы враги двигались со скоростью один тайл в секунду. Когда движение (progress) завершено, смещаем данные так, чтобы <code>To</code> становилось значение <code>From</code>, а новым <code>To</code> — следующий тайл на пути. Затем выполняем декремент progress. Когда данные становятся актуальными, интерполируем позицию врага между <code>From</code> и <code>To</code>. Так как интерполятором является progress, его значение обязательно находится в интервале от 0 и 1, моэтому мы можем использовать s<code>Vector3.LerpUnclamped</code>.<br/>
<br/>
<pre><code class="cs">	public bool GameUpdate () {
		progress += Time.deltaTime;
		while (progress >= 1f) {
			tileFrom = tileTo;
			tileTo = tileTo.NextTileOnPath;
			positionFrom = positionTo;
			positionTo = tileTo.transform.localPosition;
			progress -= 1f;
		}
		transform.localPosition =
			Vector3.LerpUnclamped(positionFrom, positionTo, progress);
		return true;
	}</code></pre><br/>
Это заставляет врагов следовать по пути, но не будет действовать при достижении конечной точки. Поэтому прежде чем изменять позиции <code>From</code> и <code>To</code>, нужно сравнивать следующий тайл на пути с <code>null</code>. Если это так, то мы достигли конечной точки и враг закончил движение. Выполняем для него Reclaim и возвращаем <code>false</code>.<br/>
<br/>
<pre><code class="cs">		while (progress >= 1f) {
			tileFrom = tileTo;
			tileTo = tileTo.NextTileOnPath;
			if (tileTo == null) {
				OriginFactory.Reclaim(this);
				return false;
			}
			positionFrom = positionTo;
			positionTo = tileTo.transform.localPosition;
			progress -= 1f;
		}</code></pre><br/>
<br/>
<div class="oembed"><div style="max-width: 100vh;"><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 100%;"><div class="tm-iframe_temp" data-src="https://gfycat.com/ifr/faroffhandyenglishpointer" data-style="border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;" id="" width=""></div></div></div></div><br/>
<i>Враги следуют по кратчайшему пути.</i><br/>
<br/>
Враги теперь движутся от центра одного тайла к другому. Стоит учесть, что они меняют своё состояние движения только в центрах тайлов, поэтому не могут мгновенно реагировать на изменения на поле. Это означает, что иногда враги будут двигаться сквозь только что поставленные стены. Как только они начали двигаться в сторону ячейки, их ничто не остановит. Именно поэтому стенам тоже нужны действительные пути.<br/>
<br/>
<div class="oembed"><div style="max-width: 100vh;"><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 100%;"><div class="tm-iframe_temp" data-src="https://gfycat.com/ifr/poorsimplistickillerwhale" data-style="border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;" id="" width=""></div></div></div></div><br/>
<i>Враги реагируют на изменение пути.</i><br/>
<br/>
<h3>Движение от края к краю</h3><br/>
Движение между центрами тайлов и резкая смена направлений выглядит нормально для абстрактной игры, в которой врагами являются подвижные кубики, но обычно красивее выглядит плавное движение. Первый шаг к его реализации — движение не по центрам, а по краям тайлов.<br/>
<br/>
Точку края между соседними тайлами можно найти усреднением их позиций. Вместо того, чтобы вычислять её на каждом шагу для каждого врага, мы будем вычислять её только при изменении пути в <code>GameTile.GrowPathTo</code>. Сделаем её доступной с помощью свойства <code>ExitPoint</code>.<br/>
<br/>
<pre><code class="cs">	public Vector3 ExitPoint { get; private set; }

	…
	
	GameTile GrowPathTo (GameTile neighbor) {
		…
		neighbor.ExitPoint =
			(neighbor.transform.localPosition + transform.localPosition) * 0.5f;
		return
			neighbor.Content.Type != GameTileContentType.Wall ? neighbor : null;
	}</code></pre><br/>
Единственным особым случаем является конечная ячейка, точкой выхода которой будет её центр.<br/>
<br/>
<pre><code class="cs">	public void BecomeDestination () {
		distance = 0;
		nextOnPath = null;
		ExitPoint = transform.localPosition;
	}</code></pre><br/>
Изменим <code>Enemy</code> таким образом, чтобы он использовал точки выхода, а не центры тайлов.<br/>
<br/>
<pre><code class="cs">	public bool GameUpdate () {
		progress += Time.deltaTime;
		while (progress >= 1f) {
			…
			positionTo = tileFrom.ExitPoint;
			progress -= 1f;
		}
		transform.localPosition = Vector3.Lerp(positionFrom, positionTo, progress);
		return true;
	}
	
	public void SpawnOn (GameTile tile) {
		…
		positionTo = tileFrom.ExitPoint;
		progress = 0f;
	}</code></pre><br/>
<div class="oembed"><div style="max-width: 100vh;"><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 100%;"><div class="tm-iframe_temp" data-src="https://gfycat.com/ifr/bigheartedenviousduckbillplatypus" data-style="border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;" id="" width=""></div></div></div></div><br/>
<i>Враги движутся между краями.</i><br/>
<br/>
Побочный эффект этого изменения заключается в том, что когда враги поворачивают вследствие изменения пути, то они на секунду остаются неподвижными.<br/>
<br/>
<div class="oembed"><div style="max-width: 100vh;"><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 100%;"><div class="tm-iframe_temp" data-src="https://gfycat.com/ifr/sophisticatedamusinggreatdane" data-style="border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;" id="" width=""></div></div></div></div><br/>
<i>При повороте враги останавливаются.</i><br/>
<br/>
<h3>Ориентация</h3><br/>
Хотя враги движутся по путям, пока они не меняют своей ориентации. Чтобы они могли смотреть в сторону движения, им необходимо знать направление пути, по которому они следуют. Это мы тоже будем определять во время поиска путей, чтобы этого не приходилось делать врагам.<br/>
<br/>
У нас есть четыре направления: север, восток, юг и запад. Зададим для них перечисление.<br/>
<br/>
<pre><code class="cs">public enum Direction {
	North, East, South, West
}</code></pre><br/>
Затем дадим <code>GameTile</code> свойство, чтобы хранить направление его пути.<br/>
<br/>
<pre><code class="cs">	public Direction PathDirection { get; private set; }</code></pre><br/>
Добавим параметр направления к <code>GrowTo</code>, который задаёт свойство. Так как мы выращиваем путь с конца в начало, направление будет противоположным к тому, откуда мы выращиваем путь.<br/>
<br/>
<pre><code class="cs">	public GameTile GrowPathNorth () => GrowPathTo(north, Direction.South);

	public GameTile GrowPathEast () => GrowPathTo(east, Direction.West);

	public GameTile GrowPathSouth () => GrowPathTo(south, Direction.North);

	public GameTile GrowPathWest () => GrowPathTo(west, Direction.East);

	GameTile GrowPathTo (GameTile neighbor, Direction direction) {
		…
		neighbor.PathDirection = direction;
		return
			neighbor.Content.Type != GameTileContentType.Wall ? neighbor : null;
	}</code></pre><br/>
Нам нужно преобразовать направления в повороты, выраженные в виде кватернионов. Было бы удобно, если бы мы просто могли вызывать <code>GetRotation</code> для направления, поэтому давайте сделаем это, создав расширяющий метод. Добавим общий статический метод <code>DirectionExtensions</code>, дадим ему массив для кэширования необходимых кватернионов, а также метод <code>GetRotation</code> для возврата соответствующего значения направления. В данном случае имеет смысл поместить расширяющий класс в тот же файл, что и тип перечисления.<br/>
<br/>
<pre><code class="cs">using UnityEngine;

public enum Direction {
	North, East, South, West
}

public static class DirectionExtensions {

	static Quaternion[] rotations = {
		Quaternion.identity,
		Quaternion.Euler(0f, 90f, 0f),
		Quaternion.Euler(0f, 180f, 0f),
		Quaternion.Euler(0f, 270f, 0f)
	};

	public static Quaternion GetRotation (this Direction direction) {
		return rotations[(int)direction];
	}
}</code></pre><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Что такое расширяющий метод (extension method)?</b>
                        <div class="spoiler_text">Расширяющий метод — это статический метод внутри статического класса, ведущий себя как метод экземпляра какого-то типа. Этот тип может быть классом, интерфейсом, структурой, примитивным значением или перечислением. Первый аргумент расширяющего метода должен иметь ключевое слово <code>this</code>. Он определяет значение типа и экземпляра, с которым будет работать метод. Такой подход обозначает, что расширяющие свойства невозможны.<br/>
<br/>
Позволяет ли это добавлять методы к чему угодно? Да, так же, как вы можете написать любой статический метод, параметром которого является любой тип.</div>
                    </div><br/>
Теперь мы можем поворачивать <code>Enemy</code> при спаунинге и каждый раз, когда мы входим в новый тайл. После обновления данных тайл <code>From</code> даёт нам направление.<br/>
<br/>
<pre><code class="cs">	public bool GameUpdate () {
		progress += Time.deltaTime;
		while (progress >= 1f) {
			…
			transform.localRotation = tileFrom.PathDirection.GetRotation();
			progress -= 1f;
		}
		transform.localPosition =
			Vector3.LerpUnclamped(positionFrom, positionTo, progress);
		return true;
	}

	public void SpawnOn (GameTile tile) {
		…
		transform.localRotation = tileFrom.PathDirection.GetRotation();
		progress = 0f;
	}</code></pre><br/>
<h3>Смена направления</h3><br/>
Вместо того, чтобы мгновенно менять направление, лучше интерполировать значения между поворотами, аналогично тому, как мы интерполировали между позициями. Чтобы перейти от одной ориентации к другой, нам нужно знать смену направления, которую необходимо выполнить: без поворота, поворот вправо, поворот влево или поворот назад. Добавим для этого перечисление, которое опять же можно разместить в том же файле, что и <code>Direction</code>, потому что они малы и тесно связаны.<br/>
<br/>
<pre><code class="cs">public enum Direction {
	North, East, South, West
}

public enum DirectionChange {
	None, TurnRight, TurnLeft, TurnAround
}</code></pre><br/>
Добавим ещё один расширяющий метод, на этот раз <code>GetDirectionChangeTo</code>, который возвращает смену направления от текущего направления к следующему. Если направления совпадают, то смены нет. Если следующее на один больше текущего, то это поворот направо. Но так как направления повторяются такая же ситуация будет, когда следующее на три меньше текущего. С поворотом налево будет то же самое, только сложение и вычитание поменяются местами. Единственный оставшийся случай — это поворот назад.<br/>
<br/>
<pre><code class="cs">	public static DirectionChange GetDirectionChangeTo (
		this Direction current, Direction next
	) {
		if (current == next) {
			return DirectionChange.None;
		}
		else if (current + 1 == next || current - 3 == next) {
			return DirectionChange.TurnRight;
		}
		else if (current - 1 == next || current + 3 == next) {
			return DirectionChange.TurnLeft;
		}
		return DirectionChange.TurnAround;
	}</code></pre><br/>
Мы совершаем поворот только в одном измерении, поэтому нам достаточно будет линейной интерполяции углов. Добавим ещё один расширяющий метод, который получает угол направления в градусах.<br/>
<br/>
<pre><code class="cs">	public static float GetAngle (this Direction direction) {
		return (float)direction * 90f;
	}</code></pre><br/>
Теперь <code>Enemy</code> придётся отслеживать направление, смену направления и углы, между которыми нужно выполнять интерполяцию.<br/>
<br/>
<pre><code class="cs">	Direction direction;
	DirectionChange directionChange;
	float directionAngleFrom, directionAngleTo;</code></pre><br/>
<code>SpawnOn</code> становится сложнее, поэтому давайте переместим код подготовки состояния в другой метод. Мы назначим исходное состояние врага как вводное состояние, поэтому назовём его <code>PrepareIntro</code>. В этом состоянии враг перемещается от центра к краю своего начального тайла, поэтому смена направления не происходит. Углы <code>From</code> и <code>To</code> одинаковы.<br/>
<br/>
<pre><code class="cs">	public void SpawnOn (GameTile tile) {
		Debug.Assert(tile.NextTileOnPath != null, "Nowhere to go!", this);
		tileFrom = tile;
		tileTo = tile.NextTileOnPath;
		//positionFrom = tileFrom.transform.localPosition;
		//positionTo = tileFrom.ExitPoint;
		//transform.localRotation = tileFrom.PathDirection.GetRotation();
		progress = 0f;
		PrepareIntro();
	}

	void PrepareIntro () {
		positionFrom = tileFrom.transform.localPosition;
		positionTo = tileFrom.ExitPoint;
		direction = tileFrom.PathDirection;
		directionChange = DirectionChange.None;
		directionAngleFrom = directionAngleTo = direction.GetAngle();
		transform.localRotation = direction.GetRotation();
	}</code></pre><br/>
На этом этапе мы создаём нечто наподобие небольшого конечного автомата. Чтобы не усложнять <code>GameUpdate</code>, переместим код изменения состояния в новый метод <code>PrepareNextState</code>. Оставим только изменения тайлов <code>From</code> и <code>To</code>, потому что мы используем их здесь для проверки того, закончил ли враг путь.<br/>
<br/>
<pre><code class="cs">	public bool GameUpdate () {
		progress += Time.deltaTime;
		while (progress >= 1f) {
			…
			//positionFrom = positionTo;
			//positionTo = tileFrom.ExitPoint;
			//transform.localRotation = tileFrom.PathDirection.GetRotation();
			progress -= 1f;
			PrepareNextState();
		}
		…
	}</code></pre><br/>
При переходе в новое состояние всегда нужно изменять позиции, находить смену направления, обновлять текущее направление и смещать угол <code>To</code> к <code>From</code>. Поворот мы больше не задаём.<br/>
<br/>
<pre><code class="cs">	void PrepareNextState () {
		positionFrom = positionTo;
		positionTo = tileFrom.ExitPoint;
		directionChange = direction.GetDirectionChangeTo(tileFrom.PathDirection);
		direction = tileFrom.PathDirection;
		directionAngleFrom = directionAngleTo;
	}</code></pre><br/>
Другие действия зависят от смены направления. Давайте добавим метод для каждого варианта. В случае, если мы движемся вперёд, то угол <code>To</code> совпадает с направлением пути текущей ячейки. Кроме того, нам нужно задать поворот, чтобы враг смотрел прямо вперёд.<br/>
<br/>
<pre><code class="cs">	void PrepareForward () {
		transform.localRotation = direction.GetRotation();
		directionAngleTo = direction.GetAngle();
	}</code></pre><br/>
В случае поворота мы не поворачиваемся мгновенно. Нам нужно интерполировать к другому углу: на 90° больше для поворота вправо, на 90° меньше для поворота влево, и на 180° больше для поворота назад. Чтобы избежать поворота не в том направлении из-за смены значений углов от 359° к 0°, угол <code>To</code> должен указываться относительно текущего направления. Нам не нужно волноваться, что угол станет меньше 0° или больше 360°, потому что <code>Quaternion.Euler</code> может справиться с этим.<br/>
<br/>
<pre><code class="cs">	void PrepareTurnRight () {
		directionAngleTo = directionAngleFrom + 90f;
	}

	void PrepareTurnLeft () {
		directionAngleTo = directionAngleFrom - 90f;
	}

	void PrepareTurnAround () {
		directionAngleTo = directionAngleFrom + 180f;
	}</code></pre><br/>
В конце <code>PrepareNextState</code> мы можем использовать <code>switch</code> для смены направления, чтобы решить, какой из четырёх методов вызывать.<br/>
<br/>
<pre><code class="cs">	void PrepareNextState () {
		…
		switch (directionChange) {
			case DirectionChange.None: PrepareForward(); break;
			case DirectionChange.TurnRight: PrepareTurnRight(); break;
			case DirectionChange.TurnLeft: PrepareTurnLeft(); break;
			default: PrepareTurnAround(); break;
		}
	}</code></pre><br/>
Теперь в конце <code>GameUpdate</code> нам нужно проверять, произошла ли смена направления. Если да, то выполнить интерполяцию между двумя углами и задать поворот.<br/>
<br/>
<pre><code class="cs">	public bool GameUpdate () {
		…
		transform.localPosition =
			Vector3.LerpUnclamped(positionFrom, positionTo, progress);
		if (directionChange != DirectionChange.None) {
			float angle = Mathf.LerpUnclamped(
				directionAngleFrom, directionAngleTo, progress
			);
			transform.localRotation = Quaternion.Euler(0f, angle, 0f);
		}
		return true;
	}</code></pre><br/>
<div class="oembed"><div style="max-width: 100vh;"><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 100%;"><div class="tm-iframe_temp" data-src="https://gfycat.com/ifr/hilariouselectricduckbillplatypus" data-style="border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;" id="" width=""></div></div></div></div><br/>
<i>Враги поворачиваются.</i><br/>
<br/>
<h3>Движение по кривой</h3><br/>
Мы можем улучшить движение, заставив врагов при повороте двигаться по кривой. Вместо того, чтобы ходить от края к краю тайлов, пусть ходят по четверти окружности. Центр этой окружности лежит в углу, общем для тайлов <code>From</code> и <code>To</code>, на том же самом краю, по которому враг вошёл на тайл <code>From</code>.<br/>
<br/>
<div style="text-align:center;"><img src="/img/image-loader.svg" height="256" data-src="https://catlikecoding.com/unity/tutorials/tower-defense/enemies/moving-enemies/rotating.png" data-width="256"/></div><br/>
<i>Вращение на четверть круга для поворота вправо.</i><br/>
<br/>
Мы можем реализовать это, двигая врага по дуге с помощью тригонометрии, в то же время поворачивая его. Но это можно и упростить, использовав только поворот, временно переместив локальное начало координат врага в центр круга. Чтобы сделать это, нам нужно изменить позицию модели врага, поэтому дадим <code>Enemy</code> ссылку на эту модель, доступную через поле конфигурации.<br/>
<br/>
<pre><code class="cs">	[SerializeField]
	Transform model = default;</code></pre><br/>
<div style="text-align:center;"><img src="/img/image-loader.svg" height="56" data-src="https://catlikecoding.com/unity/tutorials/tower-defense/enemies/moving-enemies/model-reference.png" data-width="320"/></div><br/>
<i>Enemy со ссылкой на модель.</i><br/>
<br/>
При подготовке к движению вперёд или повороту назад модель должна перемещаться в стандартное положение, в локальное начало координат врага. В противном случае модель нужно смещать на половину единицы измерения — радиус окружности поворота, вдаль от точки поворота.<br/>
<br/>
<pre><code class="cs">	void PrepareForward () {
		transform.localRotation = direction.GetRotation();
		directionAngleTo = direction.GetAngle();
		model.localPosition = Vector3.zero;
	}

	void PrepareTurnRight () {
		directionAngleTo = directionAngleFrom + 90f;
		model.localPosition = new Vector3(-0.5f, 0f);
	}

	void PrepareTurnLeft () {
		directionAngleTo = directionAngleFrom - 90f;
		model.localPosition = new Vector3(0.5f, 0f);
	}

	void PrepareTurnAround () {
		directionAngleTo = directionAngleFrom + 180f;
		model.localPosition = Vector3.zero;
	}</code></pre><br/>
Теперь самого врага нужно переместить в точку поворота. Для этого его нужно тоже переместить на половину единицы измерения, но точное смещение зависит от направления. Давайте добавим в <code>Direction</code> для этого вспомогательный расширяющий метод <code>GetHalfVector</code>.<br/>
<br/>
<pre><code class="cs">	static Vector3[] halfVectors = {
		Vector3.forward * 0.5f,
		Vector3.right * 0.5f,
		Vector3.back * 0.5f,
		Vector3.left * 0.5f
	};

	…

	public static Vector3 GetHalfVector (this Direction direction) {
		return halfVectors[(int)direction];
	}</code></pre><br/>
Прибавляем соответствующий вектор при повороте вправо или влево.<br/>
<br/>
<pre><code class="cs">	void PrepareTurnRight () {
		directionAngleTo = directionAngleFrom + 90f;
		model.localPosition = new Vector3(-0.5f, 0f);
		transform.localPosition = positionFrom + direction.GetHalfVector();
	}

	void PrepareTurnLeft () {
		directionAngleTo = directionAngleFrom - 90f;
		model.localPosition = new Vector3(0.5f, 0f);
		transform.localPosition = positionFrom + direction.GetHalfVector();
	}</code></pre><br/>
А при повороте назад позиция должна быть обычной начальной точкой.<br/>
<br/>
<pre><code class="cs">	void PrepareTurnAround () {
		directionAngleTo = directionAngleFrom + 180f;
		model.localPosition = Vector3.zero;
		transform.localPosition = positionFrom;
	}</code></pre><br/>
Кроме того, мы можем при вычислении точки выхода использовать в <code>GameTile.GrowPathTo</code> половину вектора, чтобы нам не нужен был доступ к двум позициям тайлов.<br/>
<br/>
<pre><code class="cs">		neighbor.ExitPoint =
			neighbor.transform.localPosition + direction.GetHalfVector();</code></pre><br/>
Теперь при смене направления мы не должны интерполировать позицию в <code>Enemy.GameUpdate</code>, потому что движением занимается поворот.<br/>
<br/>
<pre><code class="cs">	public bool GameUpdate () {
		…
		if (directionChange == DirectionChange.None) {
			transform.localPosition =
				Vector3.LerpUnclamped(positionFrom, positionTo, progress);
		}
		//if (directionChange != DirectionChange.None) {
		else {
			float angle = Mathf.LerpUnclamped(
				directionAngleFrom, directionAngleTo, progress
			);
			transform.localRotation = Quaternion.Euler(0f, angle, 0f);
		}
		return true;
	}</code></pre><br/>
<div class="oembed"><div style="max-width: 100vh;"><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 100%;"><div class="tm-iframe_temp" data-src="https://gfycat.com/ifr/oldteemingleafwing" data-style="border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;" id="" width=""></div></div></div></div><br/>
<i>Враги плавно огибают углы.</i><br/>
<br/>
<h3>Постоянная скорость</h3><br/>
До этого момента скорость врагов всегда была равна одному тайлу в секунду, вне зависимости от того, как они движутся внутри тайла. Но покрываемое ими расстояние зависит от их состояния, поэтому их скорость, выражаемая в единицах в секунду, изменяется. Чтобы эта скорость была постоянной, нам нужно изменять скорость progress в зависимости от состояния. Поэтому добавим поле множителя progress и используем его для масштабирования дельты в <code>GameUpdate</code>.<br/>
<br/>
<pre><code class="cs">	float progress, progressFactor;

	…

	public bool GameUpdate () {
		progress += Time.deltaTime * progressFactor;
		…
	}</code></pre><br/>
Но если progress меняется в зависимости от состояния, оставшееся значение progress невозможно напрямую использовать для следующего состояния. Поэтому перед подготовкой к новому состоянию нам нужно нормализовать progress и применить новый множитель уже в новом состоянии.<br/>
<br/>
<pre><code class="cs">	public bool GameUpdate () {
		progress += Time.deltaTime * progressFactor;
		while (progress >= 1f) {
			…
			//progress -= 1f;
			progress = (progress - 1f) / progressFactor;
			PrepareNextState();
			progress *= progressFactor;
		}
		…
	}</code></pre><br/>
Движение вперёд не требует изменений, поэтому использует множитель 1. При повороте вправо или влево враг проходит четверть окружности с радиусом ½, поэтому покрываемое расстояние равно ¼π. <code>progress</code> равен единице, разделённой на эту величину. Поворот назад не должен занимать слишком много времени, поэтому удвоим progress, чтобы он занимал полсекунды. Наконец, вводное движение покрывает только половину тайла, поэтому для сохранения постоянной скорости его progress тоже нужно удвоить.<br/>
<br/>
<pre><code class="cs">	void PrepareForward () {
		…
		progressFactor = 1f;
	}

	void PrepareTurnRight () {
		…
		progressFactor = 1f / (Mathf.PI * 0.25f);
	}

	void PrepareTurnLeft () {
		…
		progressFactor = 1f / (Mathf.PI * 0.25f);
	}

	void PrepareTurnAround () {
		…
		progressFactor = 2f;
	}

	void PrepareIntro () {
		…
		progressFactor = 2f;
	}</code></pre><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Почему расстояние равно 1/4*pi?</b>
                        <div class="spoiler_text">Длина окружности равна 2π, умноженному на радиус. Поворот вправо или влево покрывает всего четверть этой длины, а радиус равен ½, поэтому расстояние равно ½π × ½.</div>
                    </div><br/>
<h3>Завершающее состояние</h3><br/>
Так как у нас есть вводное состояние, давайте добавим и завершающее. В данный момент враги исчезают сразу после достижения конечной точки, но давайте отложим их исчезновение, пока они не достигнут центра конечного тайла. Создадим для этого метод <code>PrepareOutro</code>, зададим движение вперёд, но только до центра тайла с удвоенным progress для сохранения постоянной скорости.<br/>
<br/>
<pre><code class="cs">	void PrepareOutro () {
		positionTo = tileFrom.transform.localPosition;
		directionChange = DirectionChange.None;
		directionAngleTo = direction.GetAngle();
		model.localPosition = Vector3.zero;
		transform.localRotation = direction.GetRotation();
		progressFactor = 2f;
	}</code></pre><br/>
Чтобы <code>GameUpdate</code> не уничтожал врага слишком рано, удалим из него сдвиг тайлов. Им теперь займётся <code>PrepareNextState</code>. Таким образом, проверка на <code>null</code> вернёт <code>true</code> только после конца завершающего состояния.<br/>
<br/>
<pre><code class="cs">	public bool GameUpdate () {
		progress += Time.deltaTime * progressFactor;
		while (progress >= 1f) {
			//tileFrom = tileTo;
			//tileTo = tileTo.NextTileOnPath;
			if (tileTo == null) {
				OriginFactory.Reclaim(this);
				return false;
			}
			…
		}
		…
	}</code></pre><br/>
В <code>PrepareNextState</code> мы начнём со сдвига тайлов. Затем после задания позиции <code>From</code>, но перед заданием позиции <code>To</code> будем проверять, равен ли тайл <code>To</code> значению <code>null</code>. Если да, то подготавливаем завершающее состояние и пропускаем остальную часть метода.<br/>
<br/>
<pre><code class="cs">	void PrepareNextState () {
		tileFrom = tileTo;
		tileTo = tileTo.NextTileOnPath;
		positionFrom = positionTo;
		if (tileTo == null) {
			PrepareOutro();
			return;
		}
		positionTo = tileFrom.ExitPoint;
		…
	}</code></pre><br/>
<div class="oembed"><div style="max-width: 100vh;"><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 100%;"><div class="tm-iframe_temp" data-src="https://gfycat.com/ifr/agileimpolitegnat" data-style="border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;" id="" width=""></div></div></div></div><br/>
<i>Враги с постоянной скоростью и завершающим состоянием.</i><br/>
<br/>
<h2>Вариативность врагов</h2><br/>
У нас есть поток врагов, и все они являются одинаковым кубом, движущимся с одинаковой скоростью. Получившийся результат больше походит на длинную змею, чем на отдельных врагов. Давайте сделаем их более отличающимися, рандомизировав их размер, смещение и скорость.<br/>
<br/>
<h3>Интервал значений Float</h3><br/>
Мы будем изменять параметры врагов, случайным образом выбирая их характеристики из интервала значений. Здесь будет полезна структура <code>FloatRange</code>, которую мы создали в статье <a href="https://catlikecoding.com/unity/tutorials/object-management/configuring-shapes/">Object Management, Configuring Shapes</a>, поэтому давайте её скопируем. Единственными изменениями стали добавление конструктора с одним параметром и открытие доступа к минимуму и максимуму с помощью readonly-свойств, чтобы интервал был неизменяемым.<br/>
<br/>
<pre><code class="cs">using UnityEngine;

[System.Serializable]
public struct FloatRange {

	[SerializeField]
	float min, max;

	public float Min => min;

	public float Max => max;
	
	public float RandomValueInRange {
		get {
			return Random.Range(min, max);
		}
	}
	
	public FloatRange(float value) {
		min = max = value;
	}

	public FloatRange (float min, float max) {
		this.min = min;
		this.max = max &lt; min ? min : max;
	}
}</code></pre><br/>
Также скопируем заданный ему атрибут, чтобы ограничить его интервал.<br/>
<br/>
<pre><code class="cs">using UnityEngine;

public class FloatRangeSliderAttribute : PropertyAttribute {

	public float Min { get; private set; }

	public float Max { get; private set; }

	public FloatRangeSliderAttribute (float min, float max) {
		Min = min;
		Max = max &lt; min ? min : max;
	}
}</code></pre><br/>
Нам нужна только визуализация ползунка, поэтому скопируем <code>FloatRangeSliderDrawer</code> в папку <em>Editor</em>.<br/>
<br/>
<pre><code class="cs">using UnityEditor;
using UnityEngine;

[CustomPropertyDrawer(typeof(FloatRangeSliderAttribute))]
public class FloatRangeSliderDrawer : PropertyDrawer {

	public override void OnGUI (
		Rect position, SerializedProperty property, GUIContent label
	) {
		int originalIndentLevel = EditorGUI.indentLevel;
		EditorGUI.BeginProperty(position, label, property);

		position = EditorGUI.PrefixLabel(
			position, GUIUtility.GetControlID(FocusType.Passive), label
		);
		EditorGUI.indentLevel = 0;
		SerializedProperty minProperty = property.FindPropertyRelative("min");
		SerializedProperty maxProperty = property.FindPropertyRelative("max");
		float minValue = minProperty.floatValue;
		float maxValue = maxProperty.floatValue;
		float fieldWidth = position.width / 4f - 4f;
		float sliderWidth = position.width / 2f;
		position.width = fieldWidth;
		minValue = EditorGUI.FloatField(position, minValue);
		position.x += fieldWidth + 4f;
		position.width = sliderWidth;
		FloatRangeSliderAttribute limit = attribute as FloatRangeSliderAttribute;
		EditorGUI.MinMaxSlider(
			position, ref minValue, ref maxValue, limit.Min, limit.Max
		);
		position.x += sliderWidth + 4f;
		position.width = fieldWidth;
		maxValue = EditorGUI.FloatField(position, maxValue);
		if (minValue &lt; limit.Min) {
			minValue = limit.Min;
		}
		if (maxValue &lt; minValue) {
			maxValue = minValue;
		}
		else if (maxValue > limit.Max) {
			maxValue = limit.Max;
		}
		minProperty.floatValue = minValue;
		maxProperty.floatValue = maxValue;

		EditorGUI.EndProperty();
		EditorGUI.indentLevel = originalIndentLevel;
	}
}</code></pre><br/>
<h3>Масштаб модели</h3><br/>
Начнём мы с изменения масштаба врага. Добавим в <code>EnemyFactory</code> опцию настройки масштаба. Интервал масштабов не должен быть слишком большим, но достаточным для создания миниатюрных и гигантски разновидностей врагов. Что-нибудь в пределах 0.5–2 со стандартным значением 1. Будем выбирать случайный масштаб в этом интервале в <code>Get</code> и передавать его врагу через новый метод <code>Initialize</code>.<br/>
<br/>
<pre><code class="cs">	[SerializeField, FloatRangeSlider(0.5f, 2f)]
	FloatRange scale = new FloatRange(1f);

	public Enemy Get () {
		Enemy instance = CreateGameObjectInstance(prefab);
		instance.OriginFactory = this;
		instance.Initialize(scale.RandomValueInRange);
		return instance;
	}</code></pre><br/>
Метод <code>Enemy.Initialize</code> просто задаёт одинаковый по всем измерениям масштаб его модели.<br/>
<br/>
<pre><code class="cs">	public void Initialize (float scale) {
		model.localScale = new Vector3(scale, scale, scale);
	}</code></pre><br/>
<div style="text-align:center;"><img src="/img/image-loader.svg" height="60" alt="inspector" data-src="https://catlikecoding.com/unity/tutorials/tower-defense/enemies/enemy-variety/scale-slider.png" data-width="320"/></div><br/>
<div style="text-align:center;"><img src="/img/image-loader.svg" height="230" alt="scene" data-src="https://catlikecoding.com/unity/tutorials/tower-defense/enemies/enemy-variety/varied-scales.png" data-width="230"/></div><br/>
<i>Интервал масштабов от 0.5 до 1.5.</i><br/>
<br/>
<h3>Смещение пути</h3><br/>
Чтобы ещё сильнее разрушить однородность потока врагов, мы можем изменить их относительную позицию внутри тайлов. Они движутся вперёд, поэтому смещение в этом направлении всего лишь изменяет тайминг их движения, что не очень заметно. Поэтому мы будем смещать их вбок, в сторону от идеального пути, проходящего через центры тайлов. Добавим в <code>EnemyFactory</code> интервал смещений пути и будем передавать случайное смещение методу <code>Initialize</code>. Смещение может быть отрицательным или положительным, но никогда не больше ½, потому что это сдвинуло бы врага на соседний тайл. Кроме того, мы не хотим, чтобы враги выходили за пределы тайлов, по которым идут, поэтому на самом деле интервал будет меньше, например, 0.4, однако истинные пределы зависят от размера врага.<br/>
<br/>
<pre><code class="cs">	[SerializeField, FloatRangeSlider(-0.4f, 0.4f)]
	FloatRange pathOffset = new FloatRange(0f);

	public Enemy Get () {
		Enemy instance = CreateGameObjectInstance(prefab);
		instance.OriginFactory = this;
		instance.Initialize(
			scale.RandomValueInRange, pathOffset.RandomValueInRange
		);
		return instance;
	}</code></pre><br/>
Так как смещение пути влияет на проходимый путь, <code>Enemy</code> необходимо его отслеживать.<br/>
<br/>
<pre><code class="cs">	float pathOffset;

	…

	public void Initialize (float scale, float pathOffset) {
		model.localScale = new Vector3(scale, scale, scale);
		this.pathOffset = pathOffset;
	}</code></pre><br/>
При движении ровно прямо (во время вводного, завершающего или обычного движения вперёд) мы просто применяем смещение непосредственно к модели. То же самое происходит и при повороте назад. При правом или левом повороте мы уже смещаем модель, которая становится относительной к смещению пути.<br/>
<br/>
<pre><code class="cs">	void PrepareForward () {
		transform.localRotation = direction.GetRotation();
		directionAngleTo = direction.GetAngle();
		model.localPosition = new Vector3(pathOffset, 0f);
		progressFactor = 1f;
	}

	void PrepareTurnRight () {
		directionAngleTo = directionAngleFrom + 90f;
		model.localPosition = new Vector3(pathOffset - 0.5f, 0f);
		transform.localPosition = positionFrom + direction.GetHalfVector();
		progressFactor = 1f / (Mathf.PI * 0.25f);
	}

	void PrepareTurnLeft () {
		directionAngleTo = directionAngleFrom - 90f;
		model.localPosition = new Vector3(pathOffset + 0.5f, 0f);
		transform.localPosition = positionFrom + direction.GetHalfVector();
		progressFactor = 1f / (Mathf.PI * 0.25f);
	}

	void PrepareTurnAround () {
		directionAngleTo = directionAngleFrom + 180f;
		model.localPosition = new Vector3(pathOffset, 0f);
		transform.localPosition = positionFrom;
		progressFactor = 2f;
	}

	void PrepareIntro () {
		…
		model.localPosition = new Vector3(pathOffset, 0f);
		transform.localRotation = direction.GetRotation();
		progressFactor = 2f;
	}

	void PrepareOutro () {
		…
		model.localPosition = new Vector3(pathOffset, 0f);
		transform.localRotation = direction.GetRotation();
		progressFactor = 2f;
	}</code></pre><br/>
Так как смещение пути при повороте изменяет радиус, нам необходимо изменить процесс вычисления множителя progress. Смещение пути должно вычитаться из ½, чтобы получить радиус поворота вправо, и прибавляться в случае поворота влево.<br/>
<br/>
<pre><code class="cs">	void PrepareTurnRight () {
		…
		progressFactor = 1f / (Mathf.PI * 0.5f * (0.5f - pathOffset));
	}

	void PrepareTurnLeft () {
		…
		progressFactor = 1f / (Mathf.PI * 0.5f * (0.5f + pathOffset));
	}</code></pre><br/>
Также мы получаем радиус поворота при повороте на 180°. В этом случае мы покрываем половину окружности радиусом, равным смещению пути, поэтому расстояние равно π, умноженному на смещение. Однако это не срабатывает, когда смещение равно нулю, а при малых смещениях повороты получаются слишком быстрыми. Чтобы избежать мгновенных поворотов, мы можем принудительно задать минимальный радиус для вычисления скорости, допустим, 0.2.<br/>
<br/>
<pre><code class="cs">	void PrepareTurnAround () {
		directionAngleTo = directionAngleFrom + (pathOffset &lt; 0f ? 180f : -180f);
		model.localPosition = new Vector3(pathOffset, 0f);
		transform.localPosition = positionFrom;
		progressFactor =
			1f / (Mathf.PI * Mathf.Max(Mathf.Abs(pathOffset), 0.2f));
	}</code></pre><br/>
<div style="text-align:center;"><img src="/img/image-loader.svg" height="40" alt="inspector" data-src="https://catlikecoding.com/unity/tutorials/tower-defense/enemies/enemy-variety/path-offset-slider.png" data-width="320"/></div><br/>
<div class="oembed"><div style="max-width: 100vh;"><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 100%;"><div class="tm-iframe_temp" data-src="https://gfycat.com/ifr/ablesneakybull" data-style="border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;" id="" width=""></div></div></div></div><br/>
<i>Смещение пути в интервале −0.25–0.25.</i><br/>
<br/>
Заметьте, что теперь враги никогда не меняют своё относительное смещение пути, даже при повороте. Поэтому общая длина пути у каждого врага своя.<br/>
<br/>
Чтобы враги не выходили на соседние тайлы, надо также учитывать их максимальный возможный масштаб. Я просто ограничил размер максимальным значением 1, поэтому максимальное допустимое смещение для куба равно 0.25. Если бы максимальный размер был равен 1.5, то максимум смещения надо было снизить до 0.125.<br/>
<br/>
<h3>Скорость</h3><br/>
Последнее, что мы рандомизируем — это скорость врагов. Добавим ещё один интервал для неё в <code>EnemyFactory</code> и будем передавать значение созданному экземпляру врага. Сделаем его вторым аргументом метода <code>Initialize</code>. Враги не должны быть слишком медленными или быстрыми, чтобы игра не стала тривиально простой или невозможно трудной. Давайте ограничим интервал в пределах 0.2–5. Скорость выражается в единицах в секунду, что соответствует тайлам в секунду только при движении вперёд.<br/>
<br/>
<pre><code class="cs">	[SerializeField, FloatRangeSlider(0.2f, 5f)]
	FloatRange speed = new FloatRange(1f);

	[SerializeField, FloatRangeSlider(-0.4f, 0.4f)]
	FloatRange pathOffset = new FloatRange(0f);

	public Enemy Get () {
		Enemy instance = CreateGameObjectInstance(prefab);
		instance.OriginFactory = this;
		instance.Initialize(
			scale.RandomValueInRange,
			speed.RandomValueInRange,
			pathOffset.RandomValueInRange
		);
		return instance;
	}</code></pre><br/>
Теперь <code>Enemy</code> должен отслеживать и скорость.<br/>
<br/>
<pre><code class="cs">	float speed;

	…

	public void Initialize (float scale, float speed, float pathOffset) {
		model.localScale = new Vector3(scale, scale, scale);
		this.speed = speed;
		this.pathOffset = pathOffset;
	}</code></pre><br/>
Когда мы не задавали скорость явно, то просто всегда использовали значение 1. Теперь нам просто создать зависимость множителя progress от скорости.<br/>
<br/>
<pre><code class="cs">	void PrepareForward () {
		…
		progressFactor = speed;
	}

	void PrepareTurnRight () {
		…
		progressFactor = speed / (Mathf.PI * 0.5f * (0.5f - pathOffset));
	}

	void PrepareTurnLeft () {
		…
		progressFactor = speed / (Mathf.PI * 0.5f * (0.5f + pathOffset));
	}

	void PrepareTurnAround () {
		…
		progressFactor =
			speed / (Mathf.PI * Mathf.Max(Mathf.Abs(pathOffset), 0.2f));
	}

	void PrepareIntro () {
		…
		progressFactor = 2f * speed;
	}

	void PrepareOutro () {
		…
		progressFactor = 2f * speed;
	}</code></pre><br/>
<div style="text-align:center;"><img src="/img/image-loader.svg" height="60" data-src="https://catlikecoding.com/unity/tutorials/tower-defense/enemies/enemy-variety/speed-slider.png" data-width="320"/></div><br/>
<div class="oembed"><div style="max-width: 100vh;"><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 100%;"><div class="tm-iframe_temp" data-src="https://gfycat.com/ifr/portlyspitefulhairstreakbutterfly" data-style="border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;" id="" width=""></div></div></div></div><br/>
<i>Скорость в интервале 0.75–1.25.</i><br/>
<br/>
Итак, мы получили красивый поток врагов, движущихся к конечной точке. В следующем туториале мы научимся с ними бороться. Хотите знать, когда он выйдет? Следите за моей страницей на <a href="https://www.patreon.com/catlikecoding">Patreon</a>!<br/>
<br/>
<a href="https://bitbucket.org/catlikecodingunitytutorials/tower-defense-02-enemies/">репозиторий</a><br/>
<br/>
<a href="https://catlikecoding.com/unity/tutorials/tower-defense/enemies/Enemies.pdf">Статья в PDF</a></div></div> <!----> <!----></div> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Btower%20defense%5D" class="tm-tags-list__link">tower defense</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Btiles%5D" class="tm-tags-list__link">tiles</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D1%82%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D1%8B%D0%B5%20%D0%BA%D0%B0%D1%80%D1%82%D1%8B%5D" class="tm-tags-list__link">тайловые карты</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D1%84%D0%B0%D0%B1%D1%80%D0%B8%D0%BA%D0%B0%20%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2%5D" class="tm-tags-list__link">фабрика объектов</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D0%BF%D0%BE%D0%BB%D1%8F%D1%86%D0%B8%D1%8F%5D" class="tm-tags-list__link">интерполяция</a></li><li class="tm-separated-list__item"><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bunity3d%5D" class="tm-tags-list__link">unity3d</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="/ru/hub/gamedev/" class="tm-hubs-list__link">
    Разработка игр
  </a></li><li class="tm-separated-list__item"><a href="/ru/hub/unity/" class="tm-hubs-list__link">
    Unity
  </a></li></ul></div></div></article></div> <!----></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="16" width="16" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_medium"><title>Всего голосов 26: ↑26 и ↓0</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-rating"></use></svg> <span title="Всего голосов 26: ↑26 и ↓0" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_medium">+26</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="16" width="16" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">7.5K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    99
  </span></button> <!----> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="tm-sharing__icon"><path fill="currentColor" d="M10.33.275l9.047 7.572a.2.2 0 010 .306l-9.048 7.572a.2.2 0 01-.328-.153V11c-8 0-9.94 6-9.94 6S-1 5 10 5V.428a.2.2 0 01.328-.153z"></path></svg></button> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> </div></div> <!----> <!----> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="/ru/users/PatientZero/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><img alt="" src="//habrastorage.org/getpro/habr/avatars/8de/9c5/34a/8de9c534a18a6cb8693270a2b528d4c0.png" class="tm-entity-image__pic"></div></a> <div class="tm-user-card__meta"><div title=" 1325 голосов " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    1197
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">84.4</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title_variant-article"><!----> <a href="/ru/users/PatientZero/" class="tm-user-card__nickname tm-user-card__nickname_variant-article">
          @PatientZero
        </a> <!----></div> <p class="tm-user-card__short-info tm-user-card__short-info_variant-article">Переводчик-фрилансер</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-article"><!----> <!----> <button type="submit" class="tm-user-card__button btn btn_transparent btn_small">
      Задонатить
    </button> <!----> <!----></div></div> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----></section> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="/ru/post/452756/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="16" width="16" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v24.ce74655c.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментарии 1 
    </span></a> <!----></div></div></div> <div class="tm-ad-banner__container tm-page-article__banner"><!----> <div id="articleBottomBanner" class="tm-ad-banner"></div></div> <!----> <!----> <!----> <!----> </div></div></div></div></div> <div class="tm-page__sidebar"><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__ads tm-layout-sidebar__ads_initial"><div class="tm-ad-banner__container tm-layout-sidebar__banner"><!----> <div id="sidebarBanner" class="tm-ad-banner"></div></div></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----> <!----></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr/?back=/ru/post/452756/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="/kek/v1/auth/habrahabr-register/?back=/ru/post/452756/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2021 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"452756":{"id":"452756","timePublished":"2019-05-22T09:53:45+00:00","isCorporative":false,"lang":"ru","titleHtml":"Создание игры Tower Defense в Unity: враги","leadData":{"textHtml":"\u003Ci\u003E[\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F449798\u002F\"\u003EПервая часть: тайлы и поиск пути\u003C\u002Fa\u003E]\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EРазмещение точек создания врагов.\u003C\u002Fli\u003E\r\n\u003Cli\u003EПоявление врагов и их движение по полю.\u003C\u002Fli\u003E\r\n\u003Cli\u003EСоздание плавного движения с постоянной скоростью.\u003C\u002Fli\u003E\r\n\u003Cli\u003EИзменение размера, скорости и размещения врагов.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nЭто вторая часть туториала, посвящённого простой игре в жанре \u003Ca href=\"https:\u002F\u002Fcatlikecoding.com\u002Funity\u002Ftutorials\u002Ftower-defense\u002F\"\u003Etower defense\u003C\u002Fa\u003E. В ней рассматривается процесс создания врагов и их движения к ближайшей конечной точке.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДанный туториал выполнен в Unity 2018.3.0f2.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg  src=\"https:\u002F\u002Fcatlikecoding.com\u002Funity\u002Ftutorials\u002Ftower-defense\u002Fenemies\u002Ftutorial-image.jpg\" width=\"512\" height=\"256\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EВраги на пути к конечной точке.\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n","imageUrl":null,"buttonTextHtml":null,"image":null},"editorVersion":"1.0","postType":"article","postLabels":[{"type":"translation","data":{"originalAuthorName":"Jasper Flick","originalUrl":"https:\u002F\u002Fcatlikecoding.com\u002Funity\u002Ftutorials\u002Ftower-defense\u002Fenemies\u002F"}}],"author":{"scoreStats":{"score":1197,"votesCount":1325},"rating":84.4,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":"410013829899665","paymentPayPalMe":"vadimivshin","paymentWebmoney":null},"id":"78894","alias":"PatientZero","fullname":null,"avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F8de\u002F9c5\u002F34a\u002F8de9c534a18a6cb8693270a2b528d4c0.png","speciality":"Переводчик-фрилансер"},"statistics":{"commentsCount":1,"favoritesCount":99,"readingCount":7500,"score":26,"votesCount":26},"hubs":[{"relatedData":null,"id":"7773","alias":"gamedev","type":"collective","title":"Разработка игр","titleHtml":"Разработка игр","isProfiled":true},{"relatedData":null,"id":"17831","alias":"unity","type":"collective","title":"Unity","titleHtml":"Unity","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Ci\u003E[\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fpost\u002F449798\u002F\"\u003EПервая часть: тайлы и поиск пути\u003C\u002Fa\u003E]\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EРазмещение точек создания врагов.\u003C\u002Fli\u003E\r\n\u003Cli\u003EПоявление врагов и их движение по полю.\u003C\u002Fli\u003E\r\n\u003Cli\u003EСоздание плавного движения с постоянной скоростью.\u003C\u002Fli\u003E\r\n\u003Cli\u003EИзменение размера, скорости и размещения врагов.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nЭто вторая часть туториала, посвящённого простой игре в жанре \u003Ca href=\"https:\u002F\u002Fcatlikecoding.com\u002Funity\u002Ftutorials\u002Ftower-defense\u002F\"\u003Etower defense\u003C\u002Fa\u003E. В ней рассматривается процесс создания врагов и их движения к ближайшей конечной точке.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДанный туториал выполнен в Unity 2018.3.0f2.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002Fcatlikecoding.com\u002Funity\u002Ftutorials\u002Ftower-defense\u002Fenemies\u002Ftutorial-image.jpg\" width=\"512\" height=\"256\" data-src=\"https:\u002F\u002Fcatlikecoding.com\u002Funity\u002Ftutorials\u002Ftower-defense\u002Fenemies\u002Ftutorial-image.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EВраги на пути к конечной точке.\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"habracut\"\u003E\u003C\u002Fa\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EТочки создания (спауна) врагов\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nПрежде чем начать создавать врагов, нам нужно решить, где разместить их на поле. Для этого мы создадим точки спауна.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EСодержимое тайлов\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nТочка спауна — это ещё один тип содержимого тайлов, поэтому добавим запись для него в \u003Ccode\u003EGameTileContentType\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003Epublic enum GameTileContentType {\n\tEmpty, Destination, Wall, SpawnPoint\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nА затем создадим префаб, чтобы визуализировать его. Нам вполне подойдёт дубликат префаба начальной точки, просто изменим его тип содержимого и дадим ему другой материал. Я сделал его оранжевым.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"104\" data-src=\"https:\u002F\u002Fcatlikecoding.com\u002Funity\u002Ftutorials\u002Ftower-defense\u002Fenemies\u002Fspawn-points\u002Fspawn-point-inspector.png\" data-width=\"320\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EКонфигурация точек спауна.\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДобавим поддержку точек спауна в фабрику содержимого и дадим ему ссылку на префаб.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\t[SerializeField]\n\tGameTileContent spawnPointPrefab = default;\n\n\t…\n\n\tpublic GameTileContent Get (GameTileContentType type) {\n\t\tswitch (type) {\n\t\t\tcase GameTileContentType.Destination: return Get(destinationPrefab);\n\t\t\tcase GameTileContentType.Empty: return Get(emptyPrefab);\n\t\t\tcase GameTileContentType.Wall: return Get(wallPrefab);\n\t\t\tcase GameTileContentType.SpawnPoint: return Get(spawnPointPrefab);\n\t\t}\n\t\tDebug.Assert(false, \"Unsupported type: \" + type);\n\t\treturn null;\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"142\" data-src=\"https:\u002F\u002Fcatlikecoding.com\u002Funity\u002Ftutorials\u002Ftower-defense\u002Fenemies\u002Fspawn-points\u002Ffactory.png\" data-width=\"320\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EФабрика с поддержкой точек спауна.\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EВключение и отключение точек спауна\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nМетод для переключения состояния точки спауна, как и другие методы переключения, мы добавим в \u003Ccode\u003EGameBoard\u003C\u002Fcode\u003E. Но точки спауна не влияют на поиск пути, поэтому после изменения нам не нужно искать новые пути.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tpublic void ToggleSpawnPoint (GameTile tile) {\n\t\tif (tile.Content.Type == GameTileContentType.SpawnPoint) {\n\t\t\ttile.Content = contentFactory.Get(GameTileContentType.Empty);\n\t\t}\n\t\telse if (tile.Content.Type == GameTileContentType.Empty) {\n\t\t\ttile.Content = contentFactory.Get(GameTileContentType.SpawnPoint);\n\t\t}\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nИгра имеет смысл только если у нас есть враги, а для них необходимы точки спауна. Поэтому поле игры должно содержать хотя бы одну точку спауна. Также нам потребуется доступ к точкам спауна в дальнейшем, когда мы будем добавлять врагов, поэтому давайте воспользуемся списком, чтобы отслеживать все тайлы с этими точками. Будем обновлять список при переключении состояния точки спауна и предотвращать удаление последней точки спауна.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tList&lt;GameTile\u003E spawnPoints = new List&lt;GameTile\u003E();\n\n\t…\n\n\tpublic void ToggleSpawnPoint (GameTile tile) {\n\t\tif (tile.Content.Type == GameTileContentType.SpawnPoint) {\n\t\t\tif (spawnPoints.Count \u003E 1) {\n\t\t\t\tspawnPoints.Remove(tile);\n\t\t\t\ttile.Content = contentFactory.Get(GameTileContentType.Empty);\n\t\t\t}\n\t\t}\n\t\telse if (tile.Content.Type == GameTileContentType.Empty) {\n\t\t\ttile.Content = contentFactory.Get(GameTileContentType.SpawnPoint);\n\t\t\tspawnPoints.Add(tile);\n\t\t}\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nМетод \u003Ccode\u003EInitialize\u003C\u002Fcode\u003E теперь должен задать точку спауна, чтобы создать исходное правильное состояние поля. Давайте просто включим первый тайл, который находится в левом нижнем углу.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tpublic void Initialize (\n\t\tVector2Int size, GameTileContentFactory contentFactory\n\t) {\n\t\t…\n\n\t\tToggleDestination(tiles[tiles.Length \u002F 2]);\n\t\tToggleSpawnPoint(tiles[0]);\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nМы сделаем так, чтобы теперь альтернативное касание переключало состояние точек спауна, но при зажатом левом Shift (нажатие клавиши проверяется методом \u003Ccode\u003EInput.GetKey\u003C\u002Fcode\u003E) будет переключаться состояние конечной точки\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tvoid HandleAlternativeTouch () {\n\t\tGameTile tile = board.GetTile(TouchRay);\n\t\tif (tile != null) {\n\t\t\tif (Input.GetKey(KeyCode.LeftShift)) {\n\t\t\t\tboard.ToggleDestination(tile);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tboard.ToggleSpawnPoint(tile);\n\t\t\t}\n\t\t}\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"230\" data-src=\"https:\u002F\u002Fcatlikecoding.com\u002Funity\u002Ftutorials\u002Ftower-defense\u002Fenemies\u002Fspawn-points\u002Fboard-with-spawn-points.png\" data-width=\"230\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EПоле с точками спауна.\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EПолучение доступа к точкам спауна\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nПоле занимается всеми своими тайлами, но враги — это не его ответственность. Мы сделаем так, чтобы можно было получать доступ к его точкам спауна через общий метод \u003Ccode\u003EGetSpawnPoint\u003C\u002Fcode\u003E с параметром-индексом.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tpublic GameTile GetSpawnPoint (int index) {\n\t\treturn spawnPoints[index];\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЧтобы знать, какие индексы верны, необходима информация о количестве точек спауна, поэтому сделаем её общей с помощью общего свойства-геттера.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tpublic int SpawnPointCount =\u003E spawnPoints.Count;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EСпаунинг врагов\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nСпаунинг врага чем-то похож на создание содержимого тайла. Мы создаём через фабрику экземпляр префаба, который затем помещаем на поле.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EФабрики\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nМы создадим для врагов фабрику, которая будет помещать всё создаваемое ею на собственную сцену. Этот функционал является общим с той фабрикой, которая у нас уже есть, поэтому давайте поместим код для него в общий базовый класс \u003Ccode\u003EGameObjectFactory\u003C\u002Fcode\u003E. Нам будет достаточно одного метода \u003Ccode\u003ECreateGameObjectInstance\u003C\u002Fcode\u003E с общим параметром префаба, который создаёт и возвращает экземпляр, а также занимается управлением всей сценой. Сделаем метод \u003Ccode\u003Eprotected\u003C\u002Fcode\u003E, то есть он будет доступен только классу и всем типам, которые от него наследуют. Это всё, что делает класс, он не предназначен для использования в качестве полнофункциональной фабрики. Поэтому пометим его как \u003Ccode\u003Eabstract\u003C\u002Fcode\u003E, что не позволит создавать экземпляры его объектов.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003Eusing UnityEngine;\nusing UnityEngine.SceneManagement;\n\npublic abstract class GameObjectFactory : ScriptableObject {\n\n\tScene scene;\n\n\tprotected T CreateGameObjectInstance&lt;T\u003E (T prefab) where T : MonoBehaviour {\n\t\tif (!scene.isLoaded) {\n\t\t\tif (Application.isEditor) {\n\t\t\t\tscene = SceneManager.GetSceneByName(name);\n\t\t\t\tif (!scene.isLoaded) {\n\t\t\t\t\tscene = SceneManager.CreateScene(name);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tscene = SceneManager.CreateScene(name);\n\t\t\t}\n\t\t}\n\t\tT instance = Instantiate(prefab);\n\t\tSceneManager.MoveGameObjectToScene(instance.gameObject, scene);\n\t\treturn instance;\n\t}\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nИзменим \u003Ccode\u003EGameTileContentFactory\u003C\u002Fcode\u003E так, чтобы он наследовал этот тип фабрики и использовал \u003Ccode\u003ECreateGameObjectInstance\u003C\u002Fcode\u003E в своём методе \u003Ccode\u003EGet\u003C\u002Fcode\u003E, а затем уберём из него код управления сценой.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003Eusing UnityEngine;\n\n[CreateAssetMenu]\npublic class GameTileContentFactory : GameObjectFactory {\n\n\t…\n\n\t\u002F\u002FScene contentScene;\n\n\t…\n\n\tGameTileContent Get (GameTileContent prefab) {\n\t\tGameTileContent instance = CreateGameObjectInstance(prefab);\n\t\tinstance.OriginFactory = this;\n\t\t\u002F\u002FMoveToFactoryScene(instance.gameObject);\n\t\treturn instance;\n\t}\n\n\t\u002F\u002Fvoid MoveToFactoryScene (GameObject o) {\n\t\u002F\u002F\t…\n        \u002F\u002F}\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПосле этого создадим новый тип \u003Ccode\u003EEnemyFactory\u003C\u002Fcode\u003E, который создаёт экземпляр одного префаба \u003Ccode\u003EEnemy\u003C\u002Fcode\u003E с помощью метода \u003Ccode\u003EGet\u003C\u002Fcode\u003E вместе с сопровождающим методом \u003Ccode\u003EReclaim\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003Eusing UnityEngine;\n\n[CreateAssetMenu]\npublic class EnemyFactory : GameObjectFactory {\n\t\n\t[SerializeField]\n\tEnemy prefab = default;\n\n\tpublic Enemy Get () {\n\t\tEnemy instance = CreateGameObjectInstance(prefab);\n\t\tinstance.OriginFactory = this;\n\t\treturn instance;\n\t}\n\n\tpublic void Reclaim (Enemy enemy) {\n\t\tDebug.Assert(enemy.OriginFactory == this, \"Wrong factory reclaimed!\");\n\t\tDestroy(enemy.gameObject);\n\t}\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nНовый тип \u003Ccode\u003EEnemy\u003C\u002Fcode\u003E изначально должен только отслеживать свою исходную фабрику.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003Eusing UnityEngine;\n\npublic class Enemy : MonoBehaviour {\n\n\tEnemyFactory originFactory;\n\n\tpublic EnemyFactory OriginFactory {\n\t\tget =\u003E originFactory;\n\t\tset {\n\t\t\tDebug.Assert(originFactory == null, \"Redefined origin factory!\");\n\t\t\toriginFactory = value;\n\t\t}\n\t}\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EПрефаб\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nВрагам нужна визуализация, которая может быть любой — робот, паук, призрак, что-то более простое, например, куб, который мы и используем. Но в общем случае враг имеет 3D-модель любой сложности. Чтобы обеспечить её удобную поддержку, мы воспользуемся для иерархии префаба врага корневым объектом, к которому прикреплён только компонент \u003Ccode\u003EEnemy\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"160\" data-src=\"https:\u002F\u002Fcatlikecoding.com\u002Funity\u002Ftutorials\u002Ftower-defense\u002Fenemies\u002Fspawning-enemies\u002Fprefab-root.png\" data-width=\"320\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EКорень префаба.\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСоздадим этому объекту единственный дочерний элемент, который будет корнем модели. Он должен иметь единичные значения Transform.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"120\" data-src=\"https:\u002F\u002Fcatlikecoding.com\u002Funity\u002Ftutorials\u002Ftower-defense\u002Fenemies\u002Fspawning-enemies\u002Fmodel-root.png\" data-width=\"320\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EКорень модели.\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЗадача этого корня модели — расположить 3D-модель относительно локальной точки начала координат врага, чтобы он считал её опорной точкой, над которой враг стоит или висит. В нашем случае модель будет стандартным кубом половинного размера, которому я придам тёмно-синий цвет. Сделаем его дочерним элементом корня модели и присвоим позиции по Y значение 0.25, чтобы он стоял на земле.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"206\" data-src=\"https:\u002F\u002Fcatlikecoding.com\u002Funity\u002Ftutorials\u002Ftower-defense\u002Fenemies\u002Fspawning-enemies\u002Fcube.png\" data-width=\"320\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EМодель куба.\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТаким образом, префаб врага состоит из трёх вложенных объектов: корня префаба, корня модели и куба. Может показаться, что для простого куба это перебор, но такая система позволяет перемещать и анимировать любого врага, не беспокоясь о его особенностях.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"74\" data-src=\"https:\u002F\u002Fcatlikecoding.com\u002Funity\u002Ftutorials\u002Ftower-defense\u002Fenemies\u002Fspawning-enemies\u002Fprefab-hierarchy.png\" data-width=\"225\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EИерархия префаба врага.\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСоздадим фабрику врагов и назначим ей префаб.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"88\" data-src=\"https:\u002F\u002Fcatlikecoding.com\u002Funity\u002Ftutorials\u002Ftower-defense\u002Fenemies\u002Fspawning-enemies\u002Ffactory.png\" data-width=\"320\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EАссет фабрики.\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EРазмещение врагов на поле\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nЧтобы поместить врагов на поле, \u003Ccode\u003EGame\u003C\u002Fcode\u003E должен получит ссылку на фабрику врагов. Так как нам нужно много врагов, добавим опцию конфигурации для настройки скорости спаунинга, выражаемую в количестве врагов за секунду. Приемлемым кажется интервал 0.1–10 со значением 1 по умолчанию.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\t[SerializeField]\n\tEnemyFactory enemyFactory = default;\n\n\t[SerializeField, Range(0.1f, 10f)]\n\tfloat spawnSpeed = 1f;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"144\" data-src=\"https:\u002F\u002Fcatlikecoding.com\u002Funity\u002Ftutorials\u002Ftower-defense\u002Fenemies\u002Fspawning-enemies\u002Fgame.png\" data-width=\"320\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EGame с фабрикой врагов и скоростью спаунинга 4.\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nProgress спаунинга будем отслеживать в \u003Ccode\u003EUpdate\u003C\u002Fcode\u003E, увеличивая его на скорость, умноженную на дельту времени. Если величина prggress превышает 1, то выполняем его декремент и спауним врага с помощью нового метода \u003Ccode\u003ESpawnEnemy\u003C\u002Fcode\u003E. Продолжаем это делать, пока progress превышает 1 на случай, если скорость слишком высока и время кадра оказалось очень длинным, чтобы одновременно не создалось несколько врагов.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tfloat spawnProgress;\n\n\t…\n\n\tvoid Update () {\n\t\t…\n\n\t\tspawnProgress += spawnSpeed * Time.deltaTime;\n\t\twhile (spawnProgress \u003E= 1f) {\n\t\t\tspawnProgress -= 1f;\n\t\t\tSpawnEnemy();\n\t\t}\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EРазве не нужно обновлять progress в FixedUpdate?\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003EДа, это возможно, но для игры жанра tower defense такие точные тайминги не нужны. Мы просто будем обновлять состояние игры каждый кадр и сделаем так, чтобы она работала достаточно хорошо при любой дельте времени.\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nПусть \u003Ccode\u003ESpawnEnemy\u003C\u002Fcode\u003E получит случайную точку спауна с поля и создаст в этом тайле врага. Мы дадим \u003Ccode\u003EEnemy\u003C\u002Fcode\u003E метод \u003Ccode\u003ESpawnOn\u003C\u002Fcode\u003E, чтобы он правильно себя спозицинировал.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tvoid SpawnEnemy () {\n\t\tGameTile spawnPoint =\n\t\t\tboard.GetSpawnPoint(Random.Range(0, board.SpawnPointCount));\n\t\tEnemy enemy = enemyFactory.Get();\n\t\tenemy.SpawnOn(spawnPoint);\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПока всё, что должен делать \u003Ccode\u003ESpawnOn\u003C\u002Fcode\u003E — это задавать собственную позицию равной центру тайла. Так как модель префаба расположена правильно, куб-враг окажется поверх этого тайла.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tpublic void SpawnOn (GameTile tile) {\n\t\ttransform.localPosition = tile.transform.localPosition;\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"230\" data-src=\"https:\u002F\u002Fcatlikecoding.com\u002Funity\u002Ftutorials\u002Ftower-defense\u002Fenemies\u002Fspawning-enemies\u002Fspawned-enemies.png\" data-width=\"230\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EВраги появляются в точках спауна.\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EПеремещение врагов\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nПосле появления врага он должен начать двигаться по пути к ближайшей конечной точке. Чтобы добиться этого, нужно анимировать врагов. Мы начнём с простого плавного скольжения от тайла к тайлу, а затем сделаем их движение более сложным.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EКоллекция врагов\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nДля обновления состояния врагов мы воспользуемся тем же подходом, который исоплзовали в серии туториалов \u003Ca href=\"https:\u002F\u002Fcatlikecoding.com\u002Funity\u002Ftutorials\u002Fobject-management\u002F\"\u003EObject Management\u003C\u002Fa\u003E. Добавим \u003Ccode\u003EEnemy\u003C\u002Fcode\u003E общий метод \u003Ccode\u003EGameUpdate\u003C\u002Fcode\u003E, возвращающий информацию о том, жив ли он, что на данном этапе всегда будет истиной. Пока просто заставим его двигаться вперёд согласно дельте времени.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tpublic bool GameUpdate () {\n\t\ttransform.localPosition += Vector3.forward * Time.deltaTime;\n\t\treturn true;\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nКроме того, нам нужно вести список живых врагов и всех их обновлять, удаляя из списка мёртвых врагов. Мы можем поместить весь этот код в \u003Ccode\u003EGame\u003C\u002Fcode\u003E, но давайте вместо этого изолируем его и создадим тип \u003Ccode\u003EEnemyCollection\u003C\u002Fcode\u003E. Это сериализуемый класс, который ни от чего не наследует. Дадим ему общий метод для добавления врага и ещё один метод для обновления всей коллекции.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003Eusing System.Collections.Generic;\n\n[System.Serializable]\npublic class EnemyCollection {\n\n\tList&lt;Enemy\u003E enemies = new List&lt;Enemy\u003E();\n\n\tpublic void Add (Enemy enemy) {\n\t\tenemies.Add(enemy);\n\t}\n\n\tpublic void GameUpdate () {\n\t\tfor (int i = 0; i &lt; enemies.Count; i++) {\n\t\t\tif (!enemies[i].GameUpdate()) {\n\t\t\t\tint lastIndex = enemies.Count - 1;\n\t\t\t\tenemies[i] = enemies[lastIndex];\n\t\t\t\tenemies.RemoveAt(lastIndex);\n\t\t\t\ti -= 1;\n\t\t\t}\n\t\t}\n\t}\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТеперь \u003Ccode\u003EGame\u003C\u002Fcode\u003E будет достаточно создать всего одну такую коллекцию, в каждом кадре обновлять её и добавлять в неё созданных врагов. Врагов будем обновлять сразу же после возможного спаунинга нового врага, чтобы обновление происходило мгновенно.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tEnemyCollection enemies = new EnemyCollection();\n\n\t…\n\n\tvoid Update () {\n\t\t…\n\t\tenemies.GameUpdate();\n\t}\n\n\t…\n\n\tvoid SpawnEnemy () {\n\t\t…\n\t\tenemies.Add(enemy);\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"230\" data-src=\"https:\u002F\u002Fcatlikecoding.com\u002Funity\u002Ftutorials\u002Ftower-defense\u002Fenemies\u002Fmoving-enemies\u002Fmoving-forward.png\" data-width=\"230\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EВраги движутся вперёд.\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EДвижение по пути\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nВраги уже перемещаются, но пока не следуют по пути. Для этого им нужно знать, куда двигаться дальше. Поэтому дадим \u003Ccode\u003EGameTile\u003C\u002Fcode\u003E общее свойство-геттер для получения следующего тайла на пути.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tpublic GameTile NextTileOnPath =\u003E nextOnPath;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЗная тайл, из которого нужно выйти, и тайл, в который нужно попасть, враги могут определить начальную и конечную точки для перемещения на один тайл. Враг может интерполировать положение между этими двумя точками, отслеживая своё перемещение. После завершения перемещения этот процесс повторяется для следующего тайла. Но пути могут в любой момент измениться. Вместо того, чтобы определять, куда двигаться дальше в процессе движения, мы просто продолжает двигаться вдоль запланированного маршрута и проверяем его, достигнув следующего тайла.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПусть \u003Ccode\u003EEnemy\u003C\u002Fcode\u003E отслеживает оба тайла, чтобы на него не влияло изменение пути. Также он будет отслеживать позиции, чтобы нам не приходилось получать их в каждом кадре, и отслеживать процесс перемещения.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tGameTile tileFrom, tileTo;\n\tVector3 positionFrom, positionTo;\n\tfloat progress;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nИнициализируем эти поля в \u003Ccode\u003ESpawnOn\u003C\u002Fcode\u003E. Первая точка — это тайл, из которого движется враг, а конечная точка — следующий тайл на пути. Это предполагает, что существует следующий тайл, если только враг не был создан в конечной точке, что должно быть невозможным. Тогда мы кэшируем позиции тайлов и обнулим progress. Позицию врага нам задавать здесь не нужно, потому что его метод \u003Ccode\u003EGameUpdate\u003C\u002Fcode\u003E вызывается в том же кадре.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tpublic void SpawnOn (GameTile tile) {\n\t\t\u002F\u002Ftransform.localPosition = tile.transform.localPosition;\n\t\tDebug.Assert(tile.NextTileOnPath != null, \"Nowhere to go!\", this);\n\t\ttileFrom = tile;\n\t\ttileTo = tile.NextTileOnPath;\n\t\tpositionFrom = tileFrom.transform.localPosition;\n\t\tpositionTo = tileTo.transform.localPosition;\n\t\tprogress = 0f;\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nИнкремент progress будем выполнять в \u003Ccode\u003EGameUpdate\u003C\u002Fcode\u003E. Прибавим неизменную дельту времени, чтобы враги двигались со скоростью один тайл в секунду. Когда движение (progress) завершено, смещаем данные так, чтобы \u003Ccode\u003ETo\u003C\u002Fcode\u003E становилось значение \u003Ccode\u003EFrom\u003C\u002Fcode\u003E, а новым \u003Ccode\u003ETo\u003C\u002Fcode\u003E — следующий тайл на пути. Затем выполняем декремент progress. Когда данные становятся актуальными, интерполируем позицию врага между \u003Ccode\u003EFrom\u003C\u002Fcode\u003E и \u003Ccode\u003ETo\u003C\u002Fcode\u003E. Так как интерполятором является progress, его значение обязательно находится в интервале от 0 и 1, моэтому мы можем использовать s\u003Ccode\u003EVector3.LerpUnclamped\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tpublic bool GameUpdate () {\n\t\tprogress += Time.deltaTime;\n\t\twhile (progress \u003E= 1f) {\n\t\t\ttileFrom = tileTo;\n\t\t\ttileTo = tileTo.NextTileOnPath;\n\t\t\tpositionFrom = positionTo;\n\t\t\tpositionTo = tileTo.transform.localPosition;\n\t\t\tprogress -= 1f;\n\t\t}\n\t\ttransform.localPosition =\n\t\t\tVector3.LerpUnclamped(positionFrom, positionTo, progress);\n\t\treturn true;\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЭто заставляет врагов следовать по пути, но не будет действовать при достижении конечной точки. Поэтому прежде чем изменять позиции \u003Ccode\u003EFrom\u003C\u002Fcode\u003E и \u003Ccode\u003ETo\u003C\u002Fcode\u003E, нужно сравнивать следующий тайл на пути с \u003Ccode\u003Enull\u003C\u002Fcode\u003E. Если это так, то мы достигли конечной точки и враг закончил движение. Выполняем для него Reclaim и возвращаем \u003Ccode\u003Efalse\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\t\twhile (progress \u003E= 1f) {\n\t\t\ttileFrom = tileTo;\n\t\t\ttileTo = tileTo.NextTileOnPath;\n\t\t\tif (tileTo == null) {\n\t\t\t\tOriginFactory.Reclaim(this);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpositionFrom = positionTo;\n\t\t\tpositionTo = tileTo.transform.localPosition;\n\t\t\tprogress -= 1f;\n\t\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"oembed\"\u003E\u003Cdiv style=\"max-width: 100vh;\"\u003E\u003Cdiv style=\"left: 0; width: 100%; height: 0; position: relative; padding-bottom: 100%;\"\u003E\u003Cdiv class=\"tm-iframe_temp\" data-src=\"https:\u002F\u002Fgfycat.com\u002Fifr\u002Ffaroffhandyenglishpointer\" data-style=\"border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;\" id=\"\" width=\"\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EВраги следуют по кратчайшему пути.\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВраги теперь движутся от центра одного тайла к другому. Стоит учесть, что они меняют своё состояние движения только в центрах тайлов, поэтому не могут мгновенно реагировать на изменения на поле. Это означает, что иногда враги будут двигаться сквозь только что поставленные стены. Как только они начали двигаться в сторону ячейки, их ничто не остановит. Именно поэтому стенам тоже нужны действительные пути.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"oembed\"\u003E\u003Cdiv style=\"max-width: 100vh;\"\u003E\u003Cdiv style=\"left: 0; width: 100%; height: 0; position: relative; padding-bottom: 100%;\"\u003E\u003Cdiv class=\"tm-iframe_temp\" data-src=\"https:\u002F\u002Fgfycat.com\u002Fifr\u002Fpoorsimplistickillerwhale\" data-style=\"border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;\" id=\"\" width=\"\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EВраги реагируют на изменение пути.\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EДвижение от края к краю\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nДвижение между центрами тайлов и резкая смена направлений выглядит нормально для абстрактной игры, в которой врагами являются подвижные кубики, но обычно красивее выглядит плавное движение. Первый шаг к его реализации — движение не по центрам, а по краям тайлов.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТочку края между соседними тайлами можно найти усреднением их позиций. Вместо того, чтобы вычислять её на каждом шагу для каждого врага, мы будем вычислять её только при изменении пути в \u003Ccode\u003EGameTile.GrowPathTo\u003C\u002Fcode\u003E. Сделаем её доступной с помощью свойства \u003Ccode\u003EExitPoint\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tpublic Vector3 ExitPoint { get; private set; }\n\n\t…\n\t\n\tGameTile GrowPathTo (GameTile neighbor) {\n\t\t…\n\t\tneighbor.ExitPoint =\n\t\t\t(neighbor.transform.localPosition + transform.localPosition) * 0.5f;\n\t\treturn\n\t\t\tneighbor.Content.Type != GameTileContentType.Wall ? neighbor : null;\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЕдинственным особым случаем является конечная ячейка, точкой выхода которой будет её центр.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tpublic void BecomeDestination () {\n\t\tdistance = 0;\n\t\tnextOnPath = null;\n\t\tExitPoint = transform.localPosition;\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nИзменим \u003Ccode\u003EEnemy\u003C\u002Fcode\u003E таким образом, чтобы он использовал точки выхода, а не центры тайлов.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tpublic bool GameUpdate () {\n\t\tprogress += Time.deltaTime;\n\t\twhile (progress \u003E= 1f) {\n\t\t\t…\n\t\t\tpositionTo = tileFrom.ExitPoint;\n\t\t\tprogress -= 1f;\n\t\t}\n\t\ttransform.localPosition = Vector3.Lerp(positionFrom, positionTo, progress);\n\t\treturn true;\n\t}\n\t\n\tpublic void SpawnOn (GameTile tile) {\n\t\t…\n\t\tpositionTo = tileFrom.ExitPoint;\n\t\tprogress = 0f;\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"oembed\"\u003E\u003Cdiv style=\"max-width: 100vh;\"\u003E\u003Cdiv style=\"left: 0; width: 100%; height: 0; position: relative; padding-bottom: 100%;\"\u003E\u003Cdiv class=\"tm-iframe_temp\" data-src=\"https:\u002F\u002Fgfycat.com\u002Fifr\u002Fbigheartedenviousduckbillplatypus\" data-style=\"border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;\" id=\"\" width=\"\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EВраги движутся между краями.\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПобочный эффект этого изменения заключается в том, что когда враги поворачивают вследствие изменения пути, то они на секунду остаются неподвижными.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"oembed\"\u003E\u003Cdiv style=\"max-width: 100vh;\"\u003E\u003Cdiv style=\"left: 0; width: 100%; height: 0; position: relative; padding-bottom: 100%;\"\u003E\u003Cdiv class=\"tm-iframe_temp\" data-src=\"https:\u002F\u002Fgfycat.com\u002Fifr\u002Fsophisticatedamusinggreatdane\" data-style=\"border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;\" id=\"\" width=\"\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EПри повороте враги останавливаются.\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EОриентация\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nХотя враги движутся по путям, пока они не меняют своей ориентации. Чтобы они могли смотреть в сторону движения, им необходимо знать направление пути, по которому они следуют. Это мы тоже будем определять во время поиска путей, чтобы этого не приходилось делать врагам.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nУ нас есть четыре направления: север, восток, юг и запад. Зададим для них перечисление.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003Epublic enum Direction {\n\tNorth, East, South, West\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЗатем дадим \u003Ccode\u003EGameTile\u003C\u002Fcode\u003E свойство, чтобы хранить направление его пути.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tpublic Direction PathDirection { get; private set; }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nДобавим параметр направления к \u003Ccode\u003EGrowTo\u003C\u002Fcode\u003E, который задаёт свойство. Так как мы выращиваем путь с конца в начало, направление будет противоположным к тому, откуда мы выращиваем путь.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tpublic GameTile GrowPathNorth () =\u003E GrowPathTo(north, Direction.South);\n\n\tpublic GameTile GrowPathEast () =\u003E GrowPathTo(east, Direction.West);\n\n\tpublic GameTile GrowPathSouth () =\u003E GrowPathTo(south, Direction.North);\n\n\tpublic GameTile GrowPathWest () =\u003E GrowPathTo(west, Direction.East);\n\n\tGameTile GrowPathTo (GameTile neighbor, Direction direction) {\n\t\t…\n\t\tneighbor.PathDirection = direction;\n\t\treturn\n\t\t\tneighbor.Content.Type != GameTileContentType.Wall ? neighbor : null;\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nНам нужно преобразовать направления в повороты, выраженные в виде кватернионов. Было бы удобно, если бы мы просто могли вызывать \u003Ccode\u003EGetRotation\u003C\u002Fcode\u003E для направления, поэтому давайте сделаем это, создав расширяющий метод. Добавим общий статический метод \u003Ccode\u003EDirectionExtensions\u003C\u002Fcode\u003E, дадим ему массив для кэширования необходимых кватернионов, а также метод \u003Ccode\u003EGetRotation\u003C\u002Fcode\u003E для возврата соответствующего значения направления. В данном случае имеет смысл поместить расширяющий класс в тот же файл, что и тип перечисления.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003Eusing UnityEngine;\n\npublic enum Direction {\n\tNorth, East, South, West\n}\n\npublic static class DirectionExtensions {\n\n\tstatic Quaternion[] rotations = {\n\t\tQuaternion.identity,\n\t\tQuaternion.Euler(0f, 90f, 0f),\n\t\tQuaternion.Euler(0f, 180f, 0f),\n\t\tQuaternion.Euler(0f, 270f, 0f)\n\t};\n\n\tpublic static Quaternion GetRotation (this Direction direction) {\n\t\treturn rotations[(int)direction];\n\t}\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EЧто такое расширяющий метод (extension method)?\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003EРасширяющий метод — это статический метод внутри статического класса, ведущий себя как метод экземпляра какого-то типа. Этот тип может быть классом, интерфейсом, структурой, примитивным значением или перечислением. Первый аргумент расширяющего метода должен иметь ключевое слово \u003Ccode\u003Ethis\u003C\u002Fcode\u003E. Он определяет значение типа и экземпляра, с которым будет работать метод. Такой подход обозначает, что расширяющие свойства невозможны.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПозволяет ли это добавлять методы к чему угодно? Да, так же, как вы можете написать любой статический метод, параметром которого является любой тип.\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nТеперь мы можем поворачивать \u003Ccode\u003EEnemy\u003C\u002Fcode\u003E при спаунинге и каждый раз, когда мы входим в новый тайл. После обновления данных тайл \u003Ccode\u003EFrom\u003C\u002Fcode\u003E даёт нам направление.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tpublic bool GameUpdate () {\n\t\tprogress += Time.deltaTime;\n\t\twhile (progress \u003E= 1f) {\n\t\t\t…\n\t\t\ttransform.localRotation = tileFrom.PathDirection.GetRotation();\n\t\t\tprogress -= 1f;\n\t\t}\n\t\ttransform.localPosition =\n\t\t\tVector3.LerpUnclamped(positionFrom, positionTo, progress);\n\t\treturn true;\n\t}\n\n\tpublic void SpawnOn (GameTile tile) {\n\t\t…\n\t\ttransform.localRotation = tileFrom.PathDirection.GetRotation();\n\t\tprogress = 0f;\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EСмена направления\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nВместо того, чтобы мгновенно менять направление, лучше интерполировать значения между поворотами, аналогично тому, как мы интерполировали между позициями. Чтобы перейти от одной ориентации к другой, нам нужно знать смену направления, которую необходимо выполнить: без поворота, поворот вправо, поворот влево или поворот назад. Добавим для этого перечисление, которое опять же можно разместить в том же файле, что и \u003Ccode\u003EDirection\u003C\u002Fcode\u003E, потому что они малы и тесно связаны.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003Epublic enum Direction {\n\tNorth, East, South, West\n}\n\npublic enum DirectionChange {\n\tNone, TurnRight, TurnLeft, TurnAround\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nДобавим ещё один расширяющий метод, на этот раз \u003Ccode\u003EGetDirectionChangeTo\u003C\u002Fcode\u003E, который возвращает смену направления от текущего направления к следующему. Если направления совпадают, то смены нет. Если следующее на один больше текущего, то это поворот направо. Но так как направления повторяются такая же ситуация будет, когда следующее на три меньше текущего. С поворотом налево будет то же самое, только сложение и вычитание поменяются местами. Единственный оставшийся случай — это поворот назад.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tpublic static DirectionChange GetDirectionChangeTo (\n\t\tthis Direction current, Direction next\n\t) {\n\t\tif (current == next) {\n\t\t\treturn DirectionChange.None;\n\t\t}\n\t\telse if (current + 1 == next || current - 3 == next) {\n\t\t\treturn DirectionChange.TurnRight;\n\t\t}\n\t\telse if (current - 1 == next || current + 3 == next) {\n\t\t\treturn DirectionChange.TurnLeft;\n\t\t}\n\t\treturn DirectionChange.TurnAround;\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nМы совершаем поворот только в одном измерении, поэтому нам достаточно будет линейной интерполяции углов. Добавим ещё один расширяющий метод, который получает угол направления в градусах.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tpublic static float GetAngle (this Direction direction) {\n\t\treturn (float)direction * 90f;\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТеперь \u003Ccode\u003EEnemy\u003C\u002Fcode\u003E придётся отслеживать направление, смену направления и углы, между которыми нужно выполнять интерполяцию.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tDirection direction;\n\tDirectionChange directionChange;\n\tfloat directionAngleFrom, directionAngleTo;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ccode\u003ESpawnOn\u003C\u002Fcode\u003E становится сложнее, поэтому давайте переместим код подготовки состояния в другой метод. Мы назначим исходное состояние врага как вводное состояние, поэтому назовём его \u003Ccode\u003EPrepareIntro\u003C\u002Fcode\u003E. В этом состоянии враг перемещается от центра к краю своего начального тайла, поэтому смена направления не происходит. Углы \u003Ccode\u003EFrom\u003C\u002Fcode\u003E и \u003Ccode\u003ETo\u003C\u002Fcode\u003E одинаковы.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tpublic void SpawnOn (GameTile tile) {\n\t\tDebug.Assert(tile.NextTileOnPath != null, \"Nowhere to go!\", this);\n\t\ttileFrom = tile;\n\t\ttileTo = tile.NextTileOnPath;\n\t\t\u002F\u002FpositionFrom = tileFrom.transform.localPosition;\n\t\t\u002F\u002FpositionTo = tileFrom.ExitPoint;\n\t\t\u002F\u002Ftransform.localRotation = tileFrom.PathDirection.GetRotation();\n\t\tprogress = 0f;\n\t\tPrepareIntro();\n\t}\n\n\tvoid PrepareIntro () {\n\t\tpositionFrom = tileFrom.transform.localPosition;\n\t\tpositionTo = tileFrom.ExitPoint;\n\t\tdirection = tileFrom.PathDirection;\n\t\tdirectionChange = DirectionChange.None;\n\t\tdirectionAngleFrom = directionAngleTo = direction.GetAngle();\n\t\ttransform.localRotation = direction.GetRotation();\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nНа этом этапе мы создаём нечто наподобие небольшого конечного автомата. Чтобы не усложнять \u003Ccode\u003EGameUpdate\u003C\u002Fcode\u003E, переместим код изменения состояния в новый метод \u003Ccode\u003EPrepareNextState\u003C\u002Fcode\u003E. Оставим только изменения тайлов \u003Ccode\u003EFrom\u003C\u002Fcode\u003E и \u003Ccode\u003ETo\u003C\u002Fcode\u003E, потому что мы используем их здесь для проверки того, закончил ли враг путь.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tpublic bool GameUpdate () {\n\t\tprogress += Time.deltaTime;\n\t\twhile (progress \u003E= 1f) {\n\t\t\t…\n\t\t\t\u002F\u002FpositionFrom = positionTo;\n\t\t\t\u002F\u002FpositionTo = tileFrom.ExitPoint;\n\t\t\t\u002F\u002Ftransform.localRotation = tileFrom.PathDirection.GetRotation();\n\t\t\tprogress -= 1f;\n\t\t\tPrepareNextState();\n\t\t}\n\t\t…\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПри переходе в новое состояние всегда нужно изменять позиции, находить смену направления, обновлять текущее направление и смещать угол \u003Ccode\u003ETo\u003C\u002Fcode\u003E к \u003Ccode\u003EFrom\u003C\u002Fcode\u003E. Поворот мы больше не задаём.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tvoid PrepareNextState () {\n\t\tpositionFrom = positionTo;\n\t\tpositionTo = tileFrom.ExitPoint;\n\t\tdirectionChange = direction.GetDirectionChangeTo(tileFrom.PathDirection);\n\t\tdirection = tileFrom.PathDirection;\n\t\tdirectionAngleFrom = directionAngleTo;\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nДругие действия зависят от смены направления. Давайте добавим метод для каждого варианта. В случае, если мы движемся вперёд, то угол \u003Ccode\u003ETo\u003C\u002Fcode\u003E совпадает с направлением пути текущей ячейки. Кроме того, нам нужно задать поворот, чтобы враг смотрел прямо вперёд.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tvoid PrepareForward () {\n\t\ttransform.localRotation = direction.GetRotation();\n\t\tdirectionAngleTo = direction.GetAngle();\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nВ случае поворота мы не поворачиваемся мгновенно. Нам нужно интерполировать к другому углу: на 90° больше для поворота вправо, на 90° меньше для поворота влево, и на 180° больше для поворота назад. Чтобы избежать поворота не в том направлении из-за смены значений углов от 359° к 0°, угол \u003Ccode\u003ETo\u003C\u002Fcode\u003E должен указываться относительно текущего направления. Нам не нужно волноваться, что угол станет меньше 0° или больше 360°, потому что \u003Ccode\u003EQuaternion.Euler\u003C\u002Fcode\u003E может справиться с этим.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tvoid PrepareTurnRight () {\n\t\tdirectionAngleTo = directionAngleFrom + 90f;\n\t}\n\n\tvoid PrepareTurnLeft () {\n\t\tdirectionAngleTo = directionAngleFrom - 90f;\n\t}\n\n\tvoid PrepareTurnAround () {\n\t\tdirectionAngleTo = directionAngleFrom + 180f;\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nВ конце \u003Ccode\u003EPrepareNextState\u003C\u002Fcode\u003E мы можем использовать \u003Ccode\u003Eswitch\u003C\u002Fcode\u003E для смены направления, чтобы решить, какой из четырёх методов вызывать.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tvoid PrepareNextState () {\n\t\t…\n\t\tswitch (directionChange) {\n\t\t\tcase DirectionChange.None: PrepareForward(); break;\n\t\t\tcase DirectionChange.TurnRight: PrepareTurnRight(); break;\n\t\t\tcase DirectionChange.TurnLeft: PrepareTurnLeft(); break;\n\t\t\tdefault: PrepareTurnAround(); break;\n\t\t}\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТеперь в конце \u003Ccode\u003EGameUpdate\u003C\u002Fcode\u003E нам нужно проверять, произошла ли смена направления. Если да, то выполнить интерполяцию между двумя углами и задать поворот.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tpublic bool GameUpdate () {\n\t\t…\n\t\ttransform.localPosition =\n\t\t\tVector3.LerpUnclamped(positionFrom, positionTo, progress);\n\t\tif (directionChange != DirectionChange.None) {\n\t\t\tfloat angle = Mathf.LerpUnclamped(\n\t\t\t\tdirectionAngleFrom, directionAngleTo, progress\n\t\t\t);\n\t\t\ttransform.localRotation = Quaternion.Euler(0f, angle, 0f);\n\t\t}\n\t\treturn true;\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"oembed\"\u003E\u003Cdiv style=\"max-width: 100vh;\"\u003E\u003Cdiv style=\"left: 0; width: 100%; height: 0; position: relative; padding-bottom: 100%;\"\u003E\u003Cdiv class=\"tm-iframe_temp\" data-src=\"https:\u002F\u002Fgfycat.com\u002Fifr\u002Fhilariouselectricduckbillplatypus\" data-style=\"border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;\" id=\"\" width=\"\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EВраги поворачиваются.\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EДвижение по кривой\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nМы можем улучшить движение, заставив врагов при повороте двигаться по кривой. Вместо того, чтобы ходить от края к краю тайлов, пусть ходят по четверти окружности. Центр этой окружности лежит в углу, общем для тайлов \u003Ccode\u003EFrom\u003C\u002Fcode\u003E и \u003Ccode\u003ETo\u003C\u002Fcode\u003E, на том же самом краю, по которому враг вошёл на тайл \u003Ccode\u003EFrom\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"256\" data-src=\"https:\u002F\u002Fcatlikecoding.com\u002Funity\u002Ftutorials\u002Ftower-defense\u002Fenemies\u002Fmoving-enemies\u002Frotating.png\" data-width=\"256\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EВращение на четверть круга для поворота вправо.\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nМы можем реализовать это, двигая врага по дуге с помощью тригонометрии, в то же время поворачивая его. Но это можно и упростить, использовав только поворот, временно переместив локальное начало координат врага в центр круга. Чтобы сделать это, нам нужно изменить позицию модели врага, поэтому дадим \u003Ccode\u003EEnemy\u003C\u002Fcode\u003E ссылку на эту модель, доступную через поле конфигурации.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\t[SerializeField]\n\tTransform model = default;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"56\" data-src=\"https:\u002F\u002Fcatlikecoding.com\u002Funity\u002Ftutorials\u002Ftower-defense\u002Fenemies\u002Fmoving-enemies\u002Fmodel-reference.png\" data-width=\"320\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EEnemy со ссылкой на модель.\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПри подготовке к движению вперёд или повороту назад модель должна перемещаться в стандартное положение, в локальное начало координат врага. В противном случае модель нужно смещать на половину единицы измерения — радиус окружности поворота, вдаль от точки поворота.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tvoid PrepareForward () {\n\t\ttransform.localRotation = direction.GetRotation();\n\t\tdirectionAngleTo = direction.GetAngle();\n\t\tmodel.localPosition = Vector3.zero;\n\t}\n\n\tvoid PrepareTurnRight () {\n\t\tdirectionAngleTo = directionAngleFrom + 90f;\n\t\tmodel.localPosition = new Vector3(-0.5f, 0f);\n\t}\n\n\tvoid PrepareTurnLeft () {\n\t\tdirectionAngleTo = directionAngleFrom - 90f;\n\t\tmodel.localPosition = new Vector3(0.5f, 0f);\n\t}\n\n\tvoid PrepareTurnAround () {\n\t\tdirectionAngleTo = directionAngleFrom + 180f;\n\t\tmodel.localPosition = Vector3.zero;\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТеперь самого врага нужно переместить в точку поворота. Для этого его нужно тоже переместить на половину единицы измерения, но точное смещение зависит от направления. Давайте добавим в \u003Ccode\u003EDirection\u003C\u002Fcode\u003E для этого вспомогательный расширяющий метод \u003Ccode\u003EGetHalfVector\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tstatic Vector3[] halfVectors = {\n\t\tVector3.forward * 0.5f,\n\t\tVector3.right * 0.5f,\n\t\tVector3.back * 0.5f,\n\t\tVector3.left * 0.5f\n\t};\n\n\t…\n\n\tpublic static Vector3 GetHalfVector (this Direction direction) {\n\t\treturn halfVectors[(int)direction];\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПрибавляем соответствующий вектор при повороте вправо или влево.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tvoid PrepareTurnRight () {\n\t\tdirectionAngleTo = directionAngleFrom + 90f;\n\t\tmodel.localPosition = new Vector3(-0.5f, 0f);\n\t\ttransform.localPosition = positionFrom + direction.GetHalfVector();\n\t}\n\n\tvoid PrepareTurnLeft () {\n\t\tdirectionAngleTo = directionAngleFrom - 90f;\n\t\tmodel.localPosition = new Vector3(0.5f, 0f);\n\t\ttransform.localPosition = positionFrom + direction.GetHalfVector();\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nА при повороте назад позиция должна быть обычной начальной точкой.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tvoid PrepareTurnAround () {\n\t\tdirectionAngleTo = directionAngleFrom + 180f;\n\t\tmodel.localPosition = Vector3.zero;\n\t\ttransform.localPosition = positionFrom;\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nКроме того, мы можем при вычислении точки выхода использовать в \u003Ccode\u003EGameTile.GrowPathTo\u003C\u002Fcode\u003E половину вектора, чтобы нам не нужен был доступ к двум позициям тайлов.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\t\tneighbor.ExitPoint =\n\t\t\tneighbor.transform.localPosition + direction.GetHalfVector();\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТеперь при смене направления мы не должны интерполировать позицию в \u003Ccode\u003EEnemy.GameUpdate\u003C\u002Fcode\u003E, потому что движением занимается поворот.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tpublic bool GameUpdate () {\n\t\t…\n\t\tif (directionChange == DirectionChange.None) {\n\t\t\ttransform.localPosition =\n\t\t\t\tVector3.LerpUnclamped(positionFrom, positionTo, progress);\n\t\t}\n\t\t\u002F\u002Fif (directionChange != DirectionChange.None) {\n\t\telse {\n\t\t\tfloat angle = Mathf.LerpUnclamped(\n\t\t\t\tdirectionAngleFrom, directionAngleTo, progress\n\t\t\t);\n\t\t\ttransform.localRotation = Quaternion.Euler(0f, angle, 0f);\n\t\t}\n\t\treturn true;\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"oembed\"\u003E\u003Cdiv style=\"max-width: 100vh;\"\u003E\u003Cdiv style=\"left: 0; width: 100%; height: 0; position: relative; padding-bottom: 100%;\"\u003E\u003Cdiv class=\"tm-iframe_temp\" data-src=\"https:\u002F\u002Fgfycat.com\u002Fifr\u002Foldteemingleafwing\" data-style=\"border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;\" id=\"\" width=\"\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EВраги плавно огибают углы.\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EПостоянная скорость\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nДо этого момента скорость врагов всегда была равна одному тайлу в секунду, вне зависимости от того, как они движутся внутри тайла. Но покрываемое ими расстояние зависит от их состояния, поэтому их скорость, выражаемая в единицах в секунду, изменяется. Чтобы эта скорость была постоянной, нам нужно изменять скорость progress в зависимости от состояния. Поэтому добавим поле множителя progress и используем его для масштабирования дельты в \u003Ccode\u003EGameUpdate\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tfloat progress, progressFactor;\n\n\t…\n\n\tpublic bool GameUpdate () {\n\t\tprogress += Time.deltaTime * progressFactor;\n\t\t…\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nНо если progress меняется в зависимости от состояния, оставшееся значение progress невозможно напрямую использовать для следующего состояния. Поэтому перед подготовкой к новому состоянию нам нужно нормализовать progress и применить новый множитель уже в новом состоянии.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tpublic bool GameUpdate () {\n\t\tprogress += Time.deltaTime * progressFactor;\n\t\twhile (progress \u003E= 1f) {\n\t\t\t…\n\t\t\t\u002F\u002Fprogress -= 1f;\n\t\t\tprogress = (progress - 1f) \u002F progressFactor;\n\t\t\tPrepareNextState();\n\t\t\tprogress *= progressFactor;\n\t\t}\n\t\t…\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nДвижение вперёд не требует изменений, поэтому использует множитель 1. При повороте вправо или влево враг проходит четверть окружности с радиусом ½, поэтому покрываемое расстояние равно ¼π. \u003Ccode\u003Eprogress\u003C\u002Fcode\u003E равен единице, разделённой на эту величину. Поворот назад не должен занимать слишком много времени, поэтому удвоим progress, чтобы он занимал полсекунды. Наконец, вводное движение покрывает только половину тайла, поэтому для сохранения постоянной скорости его progress тоже нужно удвоить.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tvoid PrepareForward () {\n\t\t…\n\t\tprogressFactor = 1f;\n\t}\n\n\tvoid PrepareTurnRight () {\n\t\t…\n\t\tprogressFactor = 1f \u002F (Mathf.PI * 0.25f);\n\t}\n\n\tvoid PrepareTurnLeft () {\n\t\t…\n\t\tprogressFactor = 1f \u002F (Mathf.PI * 0.25f);\n\t}\n\n\tvoid PrepareTurnAround () {\n\t\t…\n\t\tprogressFactor = 2f;\n\t}\n\n\tvoid PrepareIntro () {\n\t\t…\n\t\tprogressFactor = 2f;\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EПочему расстояние равно 1\u002F4*pi?\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003EДлина окружности равна 2π, умноженному на радиус. Поворот вправо или влево покрывает всего четверть этой длины, а радиус равен ½, поэтому расстояние равно ½π × ½.\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EЗавершающее состояние\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nТак как у нас есть вводное состояние, давайте добавим и завершающее. В данный момент враги исчезают сразу после достижения конечной точки, но давайте отложим их исчезновение, пока они не достигнут центра конечного тайла. Создадим для этого метод \u003Ccode\u003EPrepareOutro\u003C\u002Fcode\u003E, зададим движение вперёд, но только до центра тайла с удвоенным progress для сохранения постоянной скорости.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tvoid PrepareOutro () {\n\t\tpositionTo = tileFrom.transform.localPosition;\n\t\tdirectionChange = DirectionChange.None;\n\t\tdirectionAngleTo = direction.GetAngle();\n\t\tmodel.localPosition = Vector3.zero;\n\t\ttransform.localRotation = direction.GetRotation();\n\t\tprogressFactor = 2f;\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЧтобы \u003Ccode\u003EGameUpdate\u003C\u002Fcode\u003E не уничтожал врага слишком рано, удалим из него сдвиг тайлов. Им теперь займётся \u003Ccode\u003EPrepareNextState\u003C\u002Fcode\u003E. Таким образом, проверка на \u003Ccode\u003Enull\u003C\u002Fcode\u003E вернёт \u003Ccode\u003Etrue\u003C\u002Fcode\u003E только после конца завершающего состояния.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tpublic bool GameUpdate () {\n\t\tprogress += Time.deltaTime * progressFactor;\n\t\twhile (progress \u003E= 1f) {\n\t\t\t\u002F\u002FtileFrom = tileTo;\n\t\t\t\u002F\u002FtileTo = tileTo.NextTileOnPath;\n\t\t\tif (tileTo == null) {\n\t\t\t\tOriginFactory.Reclaim(this);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t…\n\t\t}\n\t\t…\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nВ \u003Ccode\u003EPrepareNextState\u003C\u002Fcode\u003E мы начнём со сдвига тайлов. Затем после задания позиции \u003Ccode\u003EFrom\u003C\u002Fcode\u003E, но перед заданием позиции \u003Ccode\u003ETo\u003C\u002Fcode\u003E будем проверять, равен ли тайл \u003Ccode\u003ETo\u003C\u002Fcode\u003E значению \u003Ccode\u003Enull\u003C\u002Fcode\u003E. Если да, то подготавливаем завершающее состояние и пропускаем остальную часть метода.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tvoid PrepareNextState () {\n\t\ttileFrom = tileTo;\n\t\ttileTo = tileTo.NextTileOnPath;\n\t\tpositionFrom = positionTo;\n\t\tif (tileTo == null) {\n\t\t\tPrepareOutro();\n\t\t\treturn;\n\t\t}\n\t\tpositionTo = tileFrom.ExitPoint;\n\t\t…\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"oembed\"\u003E\u003Cdiv style=\"max-width: 100vh;\"\u003E\u003Cdiv style=\"left: 0; width: 100%; height: 0; position: relative; padding-bottom: 100%;\"\u003E\u003Cdiv class=\"tm-iframe_temp\" data-src=\"https:\u002F\u002Fgfycat.com\u002Fifr\u002Fagileimpolitegnat\" data-style=\"border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;\" id=\"\" width=\"\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EВраги с постоянной скоростью и завершающим состоянием.\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EВариативность врагов\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nУ нас есть поток врагов, и все они являются одинаковым кубом, движущимся с одинаковой скоростью. Получившийся результат больше походит на длинную змею, чем на отдельных врагов. Давайте сделаем их более отличающимися, рандомизировав их размер, смещение и скорость.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EИнтервал значений Float\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nМы будем изменять параметры врагов, случайным образом выбирая их характеристики из интервала значений. Здесь будет полезна структура \u003Ccode\u003EFloatRange\u003C\u002Fcode\u003E, которую мы создали в статье \u003Ca href=\"https:\u002F\u002Fcatlikecoding.com\u002Funity\u002Ftutorials\u002Fobject-management\u002Fconfiguring-shapes\u002F\"\u003EObject Management, Configuring Shapes\u003C\u002Fa\u003E, поэтому давайте её скопируем. Единственными изменениями стали добавление конструктора с одним параметром и открытие доступа к минимуму и максимуму с помощью readonly-свойств, чтобы интервал был неизменяемым.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003Eusing UnityEngine;\n\n[System.Serializable]\npublic struct FloatRange {\n\n\t[SerializeField]\n\tfloat min, max;\n\n\tpublic float Min =\u003E min;\n\n\tpublic float Max =\u003E max;\n\t\n\tpublic float RandomValueInRange {\n\t\tget {\n\t\t\treturn Random.Range(min, max);\n\t\t}\n\t}\n\t\n\tpublic FloatRange(float value) {\n\t\tmin = max = value;\n\t}\n\n\tpublic FloatRange (float min, float max) {\n\t\tthis.min = min;\n\t\tthis.max = max &lt; min ? min : max;\n\t}\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТакже скопируем заданный ему атрибут, чтобы ограничить его интервал.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003Eusing UnityEngine;\n\npublic class FloatRangeSliderAttribute : PropertyAttribute {\n\n\tpublic float Min { get; private set; }\n\n\tpublic float Max { get; private set; }\n\n\tpublic FloatRangeSliderAttribute (float min, float max) {\n\t\tMin = min;\n\t\tMax = max &lt; min ? min : max;\n\t}\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nНам нужна только визуализация ползунка, поэтому скопируем \u003Ccode\u003EFloatRangeSliderDrawer\u003C\u002Fcode\u003E в папку \u003Cem\u003EEditor\u003C\u002Fem\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003Eusing UnityEditor;\nusing UnityEngine;\n\n[CustomPropertyDrawer(typeof(FloatRangeSliderAttribute))]\npublic class FloatRangeSliderDrawer : PropertyDrawer {\n\n\tpublic override void OnGUI (\n\t\tRect position, SerializedProperty property, GUIContent label\n\t) {\n\t\tint originalIndentLevel = EditorGUI.indentLevel;\n\t\tEditorGUI.BeginProperty(position, label, property);\n\n\t\tposition = EditorGUI.PrefixLabel(\n\t\t\tposition, GUIUtility.GetControlID(FocusType.Passive), label\n\t\t);\n\t\tEditorGUI.indentLevel = 0;\n\t\tSerializedProperty minProperty = property.FindPropertyRelative(\"min\");\n\t\tSerializedProperty maxProperty = property.FindPropertyRelative(\"max\");\n\t\tfloat minValue = minProperty.floatValue;\n\t\tfloat maxValue = maxProperty.floatValue;\n\t\tfloat fieldWidth = position.width \u002F 4f - 4f;\n\t\tfloat sliderWidth = position.width \u002F 2f;\n\t\tposition.width = fieldWidth;\n\t\tminValue = EditorGUI.FloatField(position, minValue);\n\t\tposition.x += fieldWidth + 4f;\n\t\tposition.width = sliderWidth;\n\t\tFloatRangeSliderAttribute limit = attribute as FloatRangeSliderAttribute;\n\t\tEditorGUI.MinMaxSlider(\n\t\t\tposition, ref minValue, ref maxValue, limit.Min, limit.Max\n\t\t);\n\t\tposition.x += sliderWidth + 4f;\n\t\tposition.width = fieldWidth;\n\t\tmaxValue = EditorGUI.FloatField(position, maxValue);\n\t\tif (minValue &lt; limit.Min) {\n\t\t\tminValue = limit.Min;\n\t\t}\n\t\tif (maxValue &lt; minValue) {\n\t\t\tmaxValue = minValue;\n\t\t}\n\t\telse if (maxValue \u003E limit.Max) {\n\t\t\tmaxValue = limit.Max;\n\t\t}\n\t\tminProperty.floatValue = minValue;\n\t\tmaxProperty.floatValue = maxValue;\n\n\t\tEditorGUI.EndProperty();\n\t\tEditorGUI.indentLevel = originalIndentLevel;\n\t}\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EМасштаб модели\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nНачнём мы с изменения масштаба врага. Добавим в \u003Ccode\u003EEnemyFactory\u003C\u002Fcode\u003E опцию настройки масштаба. Интервал масштабов не должен быть слишком большим, но достаточным для создания миниатюрных и гигантски разновидностей врагов. Что-нибудь в пределах 0.5–2 со стандартным значением 1. Будем выбирать случайный масштаб в этом интервале в \u003Ccode\u003EGet\u003C\u002Fcode\u003E и передавать его врагу через новый метод \u003Ccode\u003EInitialize\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\t[SerializeField, FloatRangeSlider(0.5f, 2f)]\n\tFloatRange scale = new FloatRange(1f);\n\n\tpublic Enemy Get () {\n\t\tEnemy instance = CreateGameObjectInstance(prefab);\n\t\tinstance.OriginFactory = this;\n\t\tinstance.Initialize(scale.RandomValueInRange);\n\t\treturn instance;\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nМетод \u003Ccode\u003EEnemy.Initialize\u003C\u002Fcode\u003E просто задаёт одинаковый по всем измерениям масштаб его модели.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tpublic void Initialize (float scale) {\n\t\tmodel.localScale = new Vector3(scale, scale, scale);\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"60\" alt=\"inspector\" data-src=\"https:\u002F\u002Fcatlikecoding.com\u002Funity\u002Ftutorials\u002Ftower-defense\u002Fenemies\u002Fenemy-variety\u002Fscale-slider.png\" data-width=\"320\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"230\" alt=\"scene\" data-src=\"https:\u002F\u002Fcatlikecoding.com\u002Funity\u002Ftutorials\u002Ftower-defense\u002Fenemies\u002Fenemy-variety\u002Fvaried-scales.png\" data-width=\"230\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EИнтервал масштабов от 0.5 до 1.5.\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EСмещение пути\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nЧтобы ещё сильнее разрушить однородность потока врагов, мы можем изменить их относительную позицию внутри тайлов. Они движутся вперёд, поэтому смещение в этом направлении всего лишь изменяет тайминг их движения, что не очень заметно. Поэтому мы будем смещать их вбок, в сторону от идеального пути, проходящего через центры тайлов. Добавим в \u003Ccode\u003EEnemyFactory\u003C\u002Fcode\u003E интервал смещений пути и будем передавать случайное смещение методу \u003Ccode\u003EInitialize\u003C\u002Fcode\u003E. Смещение может быть отрицательным или положительным, но никогда не больше ½, потому что это сдвинуло бы врага на соседний тайл. Кроме того, мы не хотим, чтобы враги выходили за пределы тайлов, по которым идут, поэтому на самом деле интервал будет меньше, например, 0.4, однако истинные пределы зависят от размера врага.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\t[SerializeField, FloatRangeSlider(-0.4f, 0.4f)]\n\tFloatRange pathOffset = new FloatRange(0f);\n\n\tpublic Enemy Get () {\n\t\tEnemy instance = CreateGameObjectInstance(prefab);\n\t\tinstance.OriginFactory = this;\n\t\tinstance.Initialize(\n\t\t\tscale.RandomValueInRange, pathOffset.RandomValueInRange\n\t\t);\n\t\treturn instance;\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТак как смещение пути влияет на проходимый путь, \u003Ccode\u003EEnemy\u003C\u002Fcode\u003E необходимо его отслеживать.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tfloat pathOffset;\n\n\t…\n\n\tpublic void Initialize (float scale, float pathOffset) {\n\t\tmodel.localScale = new Vector3(scale, scale, scale);\n\t\tthis.pathOffset = pathOffset;\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПри движении ровно прямо (во время вводного, завершающего или обычного движения вперёд) мы просто применяем смещение непосредственно к модели. То же самое происходит и при повороте назад. При правом или левом повороте мы уже смещаем модель, которая становится относительной к смещению пути.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tvoid PrepareForward () {\n\t\ttransform.localRotation = direction.GetRotation();\n\t\tdirectionAngleTo = direction.GetAngle();\n\t\tmodel.localPosition = new Vector3(pathOffset, 0f);\n\t\tprogressFactor = 1f;\n\t}\n\n\tvoid PrepareTurnRight () {\n\t\tdirectionAngleTo = directionAngleFrom + 90f;\n\t\tmodel.localPosition = new Vector3(pathOffset - 0.5f, 0f);\n\t\ttransform.localPosition = positionFrom + direction.GetHalfVector();\n\t\tprogressFactor = 1f \u002F (Mathf.PI * 0.25f);\n\t}\n\n\tvoid PrepareTurnLeft () {\n\t\tdirectionAngleTo = directionAngleFrom - 90f;\n\t\tmodel.localPosition = new Vector3(pathOffset + 0.5f, 0f);\n\t\ttransform.localPosition = positionFrom + direction.GetHalfVector();\n\t\tprogressFactor = 1f \u002F (Mathf.PI * 0.25f);\n\t}\n\n\tvoid PrepareTurnAround () {\n\t\tdirectionAngleTo = directionAngleFrom + 180f;\n\t\tmodel.localPosition = new Vector3(pathOffset, 0f);\n\t\ttransform.localPosition = positionFrom;\n\t\tprogressFactor = 2f;\n\t}\n\n\tvoid PrepareIntro () {\n\t\t…\n\t\tmodel.localPosition = new Vector3(pathOffset, 0f);\n\t\ttransform.localRotation = direction.GetRotation();\n\t\tprogressFactor = 2f;\n\t}\n\n\tvoid PrepareOutro () {\n\t\t…\n\t\tmodel.localPosition = new Vector3(pathOffset, 0f);\n\t\ttransform.localRotation = direction.GetRotation();\n\t\tprogressFactor = 2f;\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТак как смещение пути при повороте изменяет радиус, нам необходимо изменить процесс вычисления множителя progress. Смещение пути должно вычитаться из ½, чтобы получить радиус поворота вправо, и прибавляться в случае поворота влево.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tvoid PrepareTurnRight () {\n\t\t…\n\t\tprogressFactor = 1f \u002F (Mathf.PI * 0.5f * (0.5f - pathOffset));\n\t}\n\n\tvoid PrepareTurnLeft () {\n\t\t…\n\t\tprogressFactor = 1f \u002F (Mathf.PI * 0.5f * (0.5f + pathOffset));\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТакже мы получаем радиус поворота при повороте на 180°. В этом случае мы покрываем половину окружности радиусом, равным смещению пути, поэтому расстояние равно π, умноженному на смещение. Однако это не срабатывает, когда смещение равно нулю, а при малых смещениях повороты получаются слишком быстрыми. Чтобы избежать мгновенных поворотов, мы можем принудительно задать минимальный радиус для вычисления скорости, допустим, 0.2.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tvoid PrepareTurnAround () {\n\t\tdirectionAngleTo = directionAngleFrom + (pathOffset &lt; 0f ? 180f : -180f);\n\t\tmodel.localPosition = new Vector3(pathOffset, 0f);\n\t\ttransform.localPosition = positionFrom;\n\t\tprogressFactor =\n\t\t\t1f \u002F (Mathf.PI * Mathf.Max(Mathf.Abs(pathOffset), 0.2f));\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"40\" alt=\"inspector\" data-src=\"https:\u002F\u002Fcatlikecoding.com\u002Funity\u002Ftutorials\u002Ftower-defense\u002Fenemies\u002Fenemy-variety\u002Fpath-offset-slider.png\" data-width=\"320\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"oembed\"\u003E\u003Cdiv style=\"max-width: 100vh;\"\u003E\u003Cdiv style=\"left: 0; width: 100%; height: 0; position: relative; padding-bottom: 100%;\"\u003E\u003Cdiv class=\"tm-iframe_temp\" data-src=\"https:\u002F\u002Fgfycat.com\u002Fifr\u002Fablesneakybull\" data-style=\"border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;\" id=\"\" width=\"\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EСмещение пути в интервале −0.25–0.25.\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЗаметьте, что теперь враги никогда не меняют своё относительное смещение пути, даже при повороте. Поэтому общая длина пути у каждого врага своя.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЧтобы враги не выходили на соседние тайлы, надо также учитывать их максимальный возможный масштаб. Я просто ограничил размер максимальным значением 1, поэтому максимальное допустимое смещение для куба равно 0.25. Если бы максимальный размер был равен 1.5, то максимум смещения надо было снизить до 0.125.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EСкорость\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nПоследнее, что мы рандомизируем — это скорость врагов. Добавим ещё один интервал для неё в \u003Ccode\u003EEnemyFactory\u003C\u002Fcode\u003E и будем передавать значение созданному экземпляру врага. Сделаем его вторым аргументом метода \u003Ccode\u003EInitialize\u003C\u002Fcode\u003E. Враги не должны быть слишком медленными или быстрыми, чтобы игра не стала тривиально простой или невозможно трудной. Давайте ограничим интервал в пределах 0.2–5. Скорость выражается в единицах в секунду, что соответствует тайлам в секунду только при движении вперёд.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\t[SerializeField, FloatRangeSlider(0.2f, 5f)]\n\tFloatRange speed = new FloatRange(1f);\n\n\t[SerializeField, FloatRangeSlider(-0.4f, 0.4f)]\n\tFloatRange pathOffset = new FloatRange(0f);\n\n\tpublic Enemy Get () {\n\t\tEnemy instance = CreateGameObjectInstance(prefab);\n\t\tinstance.OriginFactory = this;\n\t\tinstance.Initialize(\n\t\t\tscale.RandomValueInRange,\n\t\t\tspeed.RandomValueInRange,\n\t\t\tpathOffset.RandomValueInRange\n\t\t);\n\t\treturn instance;\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТеперь \u003Ccode\u003EEnemy\u003C\u002Fcode\u003E должен отслеживать и скорость.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tfloat speed;\n\n\t…\n\n\tpublic void Initialize (float scale, float speed, float pathOffset) {\n\t\tmodel.localScale = new Vector3(scale, scale, scale);\n\t\tthis.speed = speed;\n\t\tthis.pathOffset = pathOffset;\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nКогда мы не задавали скорость явно, то просто всегда использовали значение 1. Теперь нам просто создать зависимость множителя progress от скорости.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"cs\"\u003E\tvoid PrepareForward () {\n\t\t…\n\t\tprogressFactor = speed;\n\t}\n\n\tvoid PrepareTurnRight () {\n\t\t…\n\t\tprogressFactor = speed \u002F (Mathf.PI * 0.5f * (0.5f - pathOffset));\n\t}\n\n\tvoid PrepareTurnLeft () {\n\t\t…\n\t\tprogressFactor = speed \u002F (Mathf.PI * 0.5f * (0.5f + pathOffset));\n\t}\n\n\tvoid PrepareTurnAround () {\n\t\t…\n\t\tprogressFactor =\n\t\t\tspeed \u002F (Mathf.PI * Mathf.Max(Mathf.Abs(pathOffset), 0.2f));\n\t}\n\n\tvoid PrepareIntro () {\n\t\t…\n\t\tprogressFactor = 2f * speed;\n\t}\n\n\tvoid PrepareOutro () {\n\t\t…\n\t\tprogressFactor = 2f * speed;\n\t}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"\u002Fimg\u002Fimage-loader.svg\" height=\"60\" data-src=\"https:\u002F\u002Fcatlikecoding.com\u002Funity\u002Ftutorials\u002Ftower-defense\u002Fenemies\u002Fenemy-variety\u002Fspeed-slider.png\" data-width=\"320\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"oembed\"\u003E\u003Cdiv style=\"max-width: 100vh;\"\u003E\u003Cdiv style=\"left: 0; width: 100%; height: 0; position: relative; padding-bottom: 100%;\"\u003E\u003Cdiv class=\"tm-iframe_temp\" data-src=\"https:\u002F\u002Fgfycat.com\u002Fifr\u002Fportlyspitefulhairstreakbutterfly\" data-style=\"border: 0; top: 0; left: 0; width: 100%; height: 100%; position: absolute;\" id=\"\" width=\"\"\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EСкорость в интервале 0.75–1.25.\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИтак, мы получили красивый поток врагов, движущихся к конечной точке. В следующем туториале мы научимся с ними бороться. Хотите знать, когда он выйдет? Следите за моей страницей на \u003Ca href=\"https:\u002F\u002Fwww.patreon.com\u002Fcatlikecoding\"\u003EPatreon\u003C\u002Fa\u003E!\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca href=\"https:\u002F\u002Fbitbucket.org\u002Fcatlikecodingunitytutorials\u002Ftower-defense-02-enemies\u002F\"\u003Eрепозиторий\u003C\u002Fa\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca href=\"https:\u002F\u002Fcatlikecoding.com\u002Funity\u002Ftutorials\u002Ftower-defense\u002Fenemies\u002FEnemies.pdf\"\u003EСтатья в PDF\u003C\u002Fa\u003E\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"tower defense"},{"titleHtml":"tiles"},{"titleHtml":"тайловые карты"},{"titleHtml":"фабрика объектов"},{"titleHtml":"интерполяция"},{"titleHtml":"unity3d"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F452756\u002Fdc75c668a64bb1bc684a819296df6091\u002F","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F452756\u002Fdc75c668a64bb1bc684a819296df6091\u002F?format=vk","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F452756\\\u002F\"},\"headline\":\"Создание игры Tower Defense в Unity: враги\",\"datePublished\":\"2019-05-22T12:53:45+03:00\",\"dateModified\":\"2019-05-22T13:10:01+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"PatientZero\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"[Первая часть: тайлы и поиск пути]   Размещение точек создания врагов. Появление врагов и их движение по полю. Создание плавного движения с постоянной скоростью.\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F452756\\\u002F#post-content-body\",\"about\":[\"h_gamedev\",\"h_unity\",\"f_develop\"],\"image\":[\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F2db\\\u002Fcf3\\\u002F311\\\u002F2dbcf331117740aa403cb12a757ae6fd.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002Fe39\\\u002F522\\\u002F28d\\\u002Fe3952228dacd6801a6f5d2fb53826cc2.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F10f\\\u002F036\\\u002Fa17\\\u002F10f036a17ae271cf7b7f7c9694e01782.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F2f9\\\u002Fcd6\\\u002F22b\\\u002F2f9cd622bf1aa41023e5204e1f4caa9a.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F7c6\\\u002F348\\\u002F428\\\u002F7c6348428b50732e0a13efcdadfc9fff.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002Fce7\\\u002F691\\\u002F330\\\u002Fce7691330dd6c6813d2a64398c582c2a.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F65b\\\u002F7a3\\\u002F808\\\u002F65b7a3808f469e2723b344afccd94f8f.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F62a\\\u002F0c9\\\u002Fabb\\\u002F62a0c9abb59605150235ba6cec73eeb2.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002Fae3\\\u002Fee2\\\u002F345\\\u002Fae3ee23456931ac6f989a763deb8b7b1.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F201\\\u002F56b\\\u002F338\\\u002F20156b3384b45ab95d7aef5ed5397480.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F8b5\\\u002F74a\\\u002Fce9\\\u002F8b574ace93bd2c7f7829d41f9208a138.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F25f\\\u002Feb8\\\u002Fdc6\\\u002F25feb8dc6f0d3a5a66be43f311cd7818.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F1d7\\\u002F8a6\\\u002F3a5\\\u002F1d78a63a58d34a1d8cc9ff56a0b23cc3.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F72b\\\u002F13c\\\u002F28e\\\u002F72b13c28ed9d6a8d34f3e17536e964cd.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F1a7\\\u002Fcc3\\\u002Ff08\\\u002F1a7cc3f082406d5c8672125ceb94913c.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002Fffe\\\u002F396\\\u002F7cf\\\u002Fffe3967cfcfb6391269a5a7691317c60.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F1db\\\u002F8b2\\\u002Fb16\\\u002F1db8b2b164cba05ff6f8fe7ffa0eed71.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F0b8\\\u002Fe55\\\u002Feeb\\\u002F0b8e55eeb25d36349f606f0da60d3720.png\"]}","metaDescription":"[Первая часть: тайлы и поиск пути]\r\n\r\n\r\nРазмещение точек создания врагов.\r\nПоявление врагов и их движение по полю.\r\nСоздание плавного движения с постоянной скоростью.\r\nИзменение размера, скорости и...","mainImageUrl":null,"amp":false},"polls":[],"commentsEnabled":true,"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":true}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[],"hubs":"gamedev,unity"},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{}},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"dfp":{"slotsDict":{}},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.c2c3fc9a.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.c0af73e7.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
</body>
</html>
